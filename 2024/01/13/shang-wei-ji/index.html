<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="c#上位机开发, yijingsong">
    <meta name="description" content="一、C#1.1 编译过程
C# —- 编译器编译 —-IL中间语言 —- 通过.NET平台的CLR动态转换为机器指令

提升开发效率，代码直接转化为机器指令比较耗时

性能较c/c++较低


1.2 代码结构// 命名空间
namespa">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="referrer" content="no-referrer-when-downgrade">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>c#上位机开发 | yijingsong</title>
    <link rel="icon" type="image/png" href="/favicon.png">
    


    <!-- bg-cover style     -->



<link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.min.css">
<link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
<link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
<link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
<link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
<link rel="stylesheet" type="text/css" href="/css/matery.css">
<link rel="stylesheet" type="text/css" href="/css/my.css">
<link rel="stylesheet" type="text/css" href="/css/dark.css" media="none" onload="if(media!='all')media='all'">




    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
    <link rel="stylesheet" href="/css/post.css">




    



    <script src="/libs/jquery/jquery-3.6.0.min.js"></script>
    
<meta name="generator" content="Hexo 6.3.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head>


<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">yijingsong</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
  <li>
    <a href="javascript:;" class="waves-effect waves-light" onclick="switchNightMode()" title="深色/浅色模式" >
      <i id="sum-moon-icon" class="fas fa-sun" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">yijingsong</div>
        <div class="logo-desc">
            
            疾风亦有归途
            
        </div>
    </div>

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/blinkfox/hexo-theme-matery" class="waves-effect waves-light" target="_blank">
                <i class="fab fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>


        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/blinkfox/hexo-theme-matery" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/16.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">c#上位机开发</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <style>
    #toc-content {
        height: calc(100vh - 250px);
        overflow: scroll;
    }
</style>


<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                          <div class="article-tag">
                            <span class="chip bg-color">无标签</span>
                          </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2024-01-13
                </div>
                

                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-check fa-fw"></i>更新日期:&nbsp;&nbsp;
                    2024-03-09
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-file-word fa-fw"></i>文章字数:&nbsp;&nbsp;
                    23.3k
                </div>
                

                

                
            </div>
        </div>
        <hr class="clearfix">

        
        <!-- 是否加载使用自带的 prismjs. -->
        <link rel="stylesheet" href="/libs/prism/prism.min.css">
        

        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <h2 id="一、C"><a href="#一、C" class="headerlink" title="一、C#"></a>一、C#</h2><h3 id="1-1-编译过程"><a href="#1-1-编译过程" class="headerlink" title="1.1 编译过程"></a>1.1 编译过程</h3><ul>
<li><p>C# —- 编译器编译 —-IL中间语言 —- 通过.NET平台的CLR动态转换为机器指令</p>
</li>
<li><p>提升开发效率，代码直接转化为机器指令比较耗时</p>
</li>
<li><p>性能较c/c++较低</p>
</li>
</ul>
<h3 id="1-2-代码结构"><a href="#1-2-代码结构" class="headerlink" title="1.2 代码结构"></a>1.2 代码结构</h3><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 命名空间
namespace HelloWorldCS
{
    // 类型
    internal class Program
    {
        // 函数 方法
        static void Main(String[] args)
        {
            
        }
    }
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h4 id="1-2-1-命名空间"><a href="#1-2-1-命名空间" class="headerlink" title="1.2 1 命名空间"></a>1.2 1 命名空间</h4><ul>
<li><p>命名空间在导入时，可取别名<code>using 别名 = 要调用的命名空间</code></p>
</li>
<li><p>命名空间使用<code>.</code>标识符，进入命名空间下一级</p>
</li>
<li><p>全局命名空间<code>using global::要调用的命名空间</code></p>
</li>
</ul>
<h5 id="1-2-1-1-基本命名空间"><a href="#1-2-1-1-基本命名空间" class="headerlink" title="1.2.1.1 基本命名空间"></a>1.2.1.1 基本命名空间</h5><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">using System;  // 使用基本的数据类型等
using System.Collections.Generic;  // 加载泛型等
using System.ComponentModel;  // 控件组件模型工具
using System.Data;  // 加载与数据库连接类等有关空间
using System.Drawing;  // 绘制
using System.Linq;  // 简化数据增删改查的一种语法
using System.Text;  // 文本空间
using System.Threading.Tasks;  // 线程
using System.Windows.Forms;  // 窗体<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h5 id="1-2-1-2-命名空间定义"><a href="#1-2-1-2-命名空间定义" class="headerlink" title="1.2.1.2 命名空间定义"></a>1.2.1.2 命名空间定义</h5><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">namespace 空间名{
  	
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>



<h3 id="1-3-数据类型"><a href="#1-3-数据类型" class="headerlink" title="1.3 数据类型"></a>1.3 数据类型</h3><h4 id="1-3-1-值类型"><a href="#1-3-1-值类型" class="headerlink" title="1.3.1 值类型"></a>1.3.1 值类型</h4><ul>
<li><p>从类<code>System.ValueType</code>中派生来</p>
</li>
<li><p>值类型变量可以直接分配给一个值</p>
</li>
<li><p>可用值类型</p>
<table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">描述</th>
<th align="center">默认值</th>
</tr>
</thead>
<tbody><tr>
<td align="center">bool</td>
<td align="center">布尔值</td>
<td align="center">False</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">sbyte</td>
<td align="center">8位有符号整数</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">byte</td>
<td align="center">8位无符号整数</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">char</td>
<td align="center">16位Unicode字符</td>
<td align="center">‘\0’</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">short</td>
<td align="center">16 位有符号整数</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">ushort</td>
<td align="center">16 位无符号整数</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">int</td>
<td align="center">32位有符号整数</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">uint</td>
<td align="center">32 位无符号整数</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">long</td>
<td align="center">64位有符号整数</td>
<td align="center">0L</td>
</tr>
<tr>
<td align="center">ulong</td>
<td align="center">64 位无符号整数</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">float</td>
<td align="center">32位单精度浮点型</td>
<td align="center">0.0F</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">double</td>
<td align="center">64位双精度浮点型</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">decimal</td>
<td align="center">128位精确十进制值，28-29有效位数</td>
<td align="center">0.0M</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
</li>
</ul>
<h4 id="1-3-2-引用类型"><a href="#1-3-2-引用类型" class="headerlink" title="1.3.2 引用类型"></a>1.3.2 引用类型</h4><ul>
<li>引用类型指向一个内存位置</li>
</ul>
<h4 id="1-3-3-Object类型"><a href="#1-3-3-Object类型" class="headerlink" title="1.3.3 Object类型"></a>1.3.3 Object类型</h4><ul>
<li>Object类型是所有数据类型的终极基类</li>
<li>可被分配任何其他类型（值类型、引用类型、预定义类型、自定义类型）的值</li>
<li>当一个值类型转换位Object类时，称为<strong>装箱</strong>，反之为<strong>拆箱</strong></li>
</ul>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">object obj;
obj = 100;    // 装箱<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>



<h4 id="1-3-4-String类"><a href="#1-3-4-String类" class="headerlink" title="1.3.4 String类"></a>1.3.4 String类</h4><h5 id="1-3-4-1-拼接字符串"><a href="#1-3-4-1-拼接字符串" class="headerlink" title="1.3.4.1 拼接字符串"></a>1.3.4.1 拼接字符串</h5><ul>
<li><p>使用**<code>+</code>运算符**，对多个<code>string</code>进行拼接</p>
</li>
<li><p>会产生一个<strong>新的<code>String</code>对象</strong></p>
</li>
</ul>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">string s1 = "hello";
string s2 = "world";

// 拼接后产生新的 String 对象
string s = s1 + " " + s2;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h5 id="1-3-4-2-比较字符串"><a href="#1-3-4-2-比较字符串" class="headerlink" title="1.3.4.2 比较字符串"></a>1.3.4.2 比较字符串</h5><ul>
<li><p>使用**<code>==</code>比较运算符**</p>
</li>
<li><p>**<code>Equals()</code>**方法</p>
</li>
</ul>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">/*
	两种常用方法
*/

// 第一种
public bool Equals(string strB)
    
// 第二种
public static bool Equals(string strA, string strB)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<ul>
<li>**<code>Compare()</code>**方法</li>
</ul>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">/*
    两种重载方法
    Int 返回值，strA == strB 返回 0
               strA &gt; strB 返回 1
               strA &lt; strB 返回 -1
*/

// 第一种
public static int Compare(string strA, string strB)

// 第二种
// ignorCase 若设置为 True ，则在比较字符串时会  忽略大小写！！！
public static int Compare(string strA, string strB, bool ignorCase)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<ul>
<li>**<code>CompareTo()</code>**方法</li>
</ul>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">/*
	该方法返回值情况同 Compare()
*/
public int CompareTo(string strB)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>



<h5 id="1-3-4-3-格式化字符串"><a href="#1-3-4-3-格式化字符串" class="headerlink" title="1.3.4.3 格式化字符串"></a>1.3.4.3 格式化字符串</h5><ul>
<li><code>String</code>类提供了一个静态<code>Format()</code>方法，将字符串格式化为指定格式</li>
</ul>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">/*
	format 参数格式：{参数列表索引:格式字符串}，如{0:C}、{0:F2}
	
	数值类型格式说明符（大小写均可）：
		c - 货币 - ￥123
		d - Decimal	- 123
		e - 指数 - 1.025e+003
		f - 定点 - 124.76		f2: 取2位小数
		n - Number - 12,800
		p - 百分比 - 100.00%   p0: 0位小数
		x - 十六进制 - 00FF	   x4: 4位
		
    日期时间的格式化（区分大小写）：
    	d - 简短日期：YYYY-MM-dd
    	D - 完整日期：YYYY年MM月dd日
    	t - 简短时间：hh:mm
    	T - 完整时间：hh:mm:ss
    	f - 简短日期/时间：YYYY-MM-dd hh:mm
    	F - 完整日期/时间：YYYY年MM月dd日 hh:mm:ss
    	g - 简短的可排序的日期/时间：YYYY-MM-dd hh:mm
    	G - 完整的可排序的日期/时间：YYYY-MM-dd hh:mm:ss
    	M/m - 月/日：MM月dd日
    	Y/y - 年/月：YYYY年MM月
    	
*/

public static string Format(string format, object obj)
    
// 数值举例    运行结果：天才是1%的灵感，加上99%的汗水
Console.WriteLine(string.Format("天才是{0:P0}的灵感，加上{1:P0}的汗水",0.01,0.99));

// 日期时间举例    运行结果：2023年11月3日
DateTime dt = DateTime.Now;
string strB = String.Format("{0:D}",dt);
Console.WriteLine(strB);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<ul>
<li><code>ToString()</code>方法也可传入指定格式说明符，对数值/日期时间数据进行格式化</li>
</ul>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">int money = 1298;
Console.WriteLine(money.ToString("C")); // 转换为货币形式

DateTime dTime = DateTime.Now;
Console.WriteLine(dTime.ToString("Y")); // 转换为年月

// 运行结果：
// 		￥1298
// 		2023年11月<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h5 id="1-3-4-4-截取字符串"><a href="#1-3-4-4-截取字符串" class="headerlink" title="1.3.4.4 截取字符串"></a>1.3.4.4 截取字符串</h5><ul>
<li><code>Substring()</code>方法，截取指定位置和指定长度的子字符串</li>
</ul>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">/*
	参数：
		startIndex：字符串截取索引位置
		Length：截取长度，当Length大于字符串长度时，截取完为止
*/

public string Substring(int startIndex, int length)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h5 id="1-3-4-5-分割字符串"><a href="#1-3-4-5-分割字符串" class="headerlink" title="1.3.4.5 分割字符串"></a>1.3.4.5 分割字符串</h5><ul>
<li><code>Split()</code>方法，分割字符串，返回字符串数组对象</li>
</ul>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">/*
	params关键字：
		函数传参时用，意为函数参数不固定，此处跟char[]，表示其是一个可变数量数组
	
	参数：
		separator：分隔符数组
*/

public string[] Split(params char[] separator)
    

// 举例
string strA = "你干嘛，哎哟";
char[] separator = {'，'};
String[] splitstring = new String[100];
splitstring = strA.Split(separator);
for(int i = 0; i&lt;splitstring.Length; i++
{
    Console.WriteLine("item{0}:{1}", i, splitstring[i]);
}
    
// 运行结果：
//    	item0:你干嘛
//   	item1:哎哟<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h5 id="1-3-4-6-插入字符"><a href="#1-3-4-6-插入字符" class="headerlink" title="1.3.4.6 插入字符"></a>1.3.4.6 插入字符</h5><ul>
<li><code>Insert()</code>方法，向字符串任意位置插入新元素</li>
</ul>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">/*
	参数：
		startIndex：插入字符串索引
		value：要插入的字符串
*/

public string Insert(int startIndex, string value)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li><code>PadLeft()</code>和<code>PadRight()</code>，分别在字符串左侧和右侧填充字符</li>
</ul>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">/*
	参数：
		totalWidth：填充后的字符串长度
		paddingChar：要填充的字符，若省略，填充空格
*/

public string PadLeft(int totalWidth, char paddingChar)

public string PadRight(int totalWidth, char paddingChar)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h5 id="1-3-4-7-删除字符串"><a href="#1-3-4-7-删除字符串" class="headerlink" title="1.3.4.7 删除字符串"></a>1.3.4.7 删除字符串</h5><ul>
<li><code>Remove()</code>方法</li>
</ul>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 两种重载方法
/*
	参数：
		startIndex：开始删除索引
		count：删除字符数目
*/
public String Remove(int startIndex)  // 删到最后一个字符
public String Remove(int startIndex, int count)  // 删除指定个数字符<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h5 id="1-3-4-8-复制字符串"><a href="#1-3-4-8-复制字符串" class="headerlink" title="1.3.4.8 复制字符串"></a>1.3.4.8 复制字符串</h5><ul>
<li><code>Copy()</code>和<code>CopyTo()</code>，分别复制到另一个字符串或<code>Char[]</code></li>
</ul>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">public static string Copy(string str)

/*
	参数：
		sourceIndex：待复制字符的起始位置
		destination：目标字符数组
		destinationIndex：目标数组开始存放字符的位置
		count：要复制的个数
*/
public void CopyTo(int sourceIndex, cahr[] destination, int destinationIndex, int count)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h5 id="1-3-4-9-替换字符串"><a href="#1-3-4-9-替换字符串" class="headerlink" title="1.3.4.9 替换字符串"></a>1.3.4.9 替换字符串</h5><ul>
<li><code>Replace()</code>方法，替换字符或字符串</li>
</ul>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">public string Replace(char OChar, char NChar)

public string Replace(string OValue, string NValue)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>



<h4 id="1-3-5-数组"><a href="#1-3-5-数组" class="headerlink" title="1.3.5 数组"></a>1.3.5 数组</h4><ul>
<li>一组相同数据类型的数据序列</li>
<li><code>String</code>类型本身就是由<code>char</code>类型组成的数组</li>
</ul>
<h5 id="1-3-3-1-初始化数组"><a href="#1-3-3-1-初始化数组" class="headerlink" title="1.3.3.1 初始化数组"></a>1.3.3.1 初始化数组</h5><ul>
<li>声明一个长度为2的<code>String</code>数组，<code>string a = new string[2];</code></li>
<li>声明并初始化，<code>string a = new string[2]{"你干嘛","哎哟"}</code></li>
</ul>
<h4 id="1-3-6-正则表达式"><a href="#1-3-6-正则表达式" class="headerlink" title="1.3.6 正则表达式"></a>1.3.6 正则表达式</h4><ul>
<li>作用：查找符合某些复杂规则的字符串</li>
<li>实质：正则表达式是记录文本规则的代码</li>
</ul>
<h5 id="1-3-6-1-行定位符"><a href="#1-3-6-1-行定位符" class="headerlink" title="1.3.6.1 行定位符"></a>1.3.6.1 行定位符</h5><ul>
<li><p>用来描述字符串的边界</p>
</li>
<li><p><code>^</code>和<code>$</code>分别用于表示行的开始和结尾</p>
</li>
<li><p><code>^tm</code>可用于<code>tm</code>开头的字符串，如<code>tm123dhak</code></p>
<ul>
<li><code>tm$</code>用于匹配<code>tm</code>结尾的字符串，如<code>dkah123tm</code></li>
</ul>
</li>
<li><p>若<code>tm</code>可出现在字符串任意部位，正则表达式可直接写为<code>tm</code></p>
</li>
</ul>
<h5 id="1-3-6-2-元字符"><a href="#1-3-6-2-元字符" class="headerlink" title="1.3.6.2 元字符"></a>1.3.6.2 元字符</h5><ul>
<li><p>常用元字符</p>
<table>
<thead>
<tr>
<th align="center">元字符</th>
<th align="center">说明</th>
<th align="center">元字符</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">.</td>
<td align="center">匹配除换行符外的任意字符</td>
<td align="center">\b</td>
<td align="center">匹配单词的开或结束</td>
</tr>
<tr>
<td align="center">\w</td>
<td align="center">匹配字母、数字、下划线或汉字</td>
<td align="center">^</td>
<td align="center">匹配字符串的开始</td>
</tr>
<tr>
<td align="center">\s</td>
<td align="center">匹配任意的空白字符</td>
<td align="center">$</td>
<td align="center">匹配字符串的结束</td>
</tr>
<tr>
<td align="center">\d</td>
<td align="center">匹配数字</td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<ul>
<li>如<code>\bmr\w*\b</code>，该正则表达式表示，匹配以<code>mr</code>开头的单词，先匹配单词开始处<code>\b</code>，然后匹配字母<code>mr</code>，接着匹配任意数量的字母或数字<code>\w*</code>，最后匹配单词结束处<code>\b</code>。该表达式可匹配<code>mrsoft、mrbook、mr123456</code>等</li>
</ul>
</li>
</ul>
<h5 id="1-3-6-3-限位符"><a href="#1-3-6-3-限位符" class="headerlink" title="1.3.6.3 限位符"></a>1.3.6.3 限位符</h5><ul>
<li><p>匹配指定数量的字符</p>
</li>
<li><p>常用限位符</p>
<table>
<thead>
<tr>
<th align="center">限位符</th>
<th align="center">说明</th>
<th align="center">举例</th>
</tr>
</thead>
<tbody><tr>
<td align="center">?</td>
<td align="center">匹配前面的字符零次或一次</td>
<td align="center">go?gle，该表达式可匹配ggle和gogle</td>
</tr>
<tr>
<td align="center">+</td>
<td align="center">匹配前面的字符一次或多次</td>
<td align="center">go+gle，该表达式可匹配范围从gogle到goo…gle</td>
</tr>
<tr>
<td align="center">*</td>
<td align="center">匹配前面的字符零次或多次</td>
<td align="center">go*gle，该表达式可匹配范围从ggle到goo…gle</td>
</tr>
<tr>
<td align="center">{n}</td>
<td align="center">匹配前面的字符n次</td>
<td align="center">go{2}gle，只能匹配google</td>
</tr>
<tr>
<td align="center">{n,}</td>
<td align="center">匹配前面的字符至少n次</td>
<td align="center">go{2,}gle，该表达式可匹配范围从google到goo…gle</td>
</tr>
<tr>
<td align="center">{n,m}</td>
<td align="center">匹配前面的字符[n, m]次</td>
<td align="center">go{0,2}gle，该表达式可匹配范围从ggle、gogle、google</td>
</tr>
</tbody></table>
<ul>
<li>如<code>\d{8}$</code>，匹配8位数字</li>
</ul>
</li>
</ul>
<h5 id="1-3-6-4-自定义字符"><a href="#1-3-6-4-自定义字符" class="headerlink" title="1.3.6.4 自定义字符"></a>1.3.6.4 自定义字符</h5><ul>
<li>使用<code>[]</code>，匹配指定字符<ul>
<li>例，要匹配元音字母，<code>[aeiou]</code>，该表达式即可匹配任意一个元音字母</li>
</ul>
</li>
<li>若要排除指定字符，在<code>[]</code>内使用<code>^</code><ul>
<li>例，<code>[^a-zA-Z]</code>，匹配一个非字母字符</li>
</ul>
</li>
</ul>
<h5 id="1-3-6-5-选择字符"><a href="#1-3-6-5-选择字符" class="headerlink" title="1.3.6.5 选择字符"></a>1.3.6.5 选择字符</h5><ul>
<li>在面对身份证的匹配时，身份证号码长度为15或18，如果15位则全是数字；如果为18位，则前17位为数字最后一位是校验位，既可以是数字也可以是字符X或x</li>
<li>该匹配规则隐含选择逻辑，使用字符<code>|</code>来实现<ul>
<li><code>(^\d{15}$)|(^\d{18}$)|(^\d{17}(X|x)$)</code></li>
</ul>
</li>
</ul>
<h5 id="1-3-6-6-转义字符"><a href="#1-3-6-6-转义字符" class="headerlink" title="1.3.6.6 转义字符"></a>1.3.6.6 转义字符</h5><ul>
<li>当需要匹配<code>.</code>、<code>?</code>、<code>\</code>等字符时，由于正则表达式已有相应含有，可通过转义字符转换为普通字符<ul>
<li>例，需要匹配127.0.0.1这样的IP地址，可使用<code>\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}</code>进行匹配</li>
</ul>
</li>
</ul>
<h5 id="1-3-6-7-分组"><a href="#1-3-6-7-分组" class="headerlink" title="1.3.6.7 分组"></a>1.3.6.7 分组</h5><ul>
<li>使用小括号<code>()</code>，其除了可以改变限定符的作用范围，还可以进行分组<ul>
<li>例，<code>(\.[0-9]{1,3}){3}</code>，对分组<code>\.[0-9]{1,3}</code>进行3次重复操作</li>
</ul>
</li>
</ul>
<h5 id="1-3-6-8-使用正则表达式"><a href="#1-3-6-8-使用正则表达式" class="headerlink" title="1.3.6.8 使用正则表达式"></a>1.3.6.8 使用正则表达式</h5><ul>
<li>借助<code>System.Text.RegularExpression</code>命名空间下的<code>Regex</code>类</li>
<li>该类有许多静态方法<ul>
<li><code>IsMatch()</code>，指示正则表达式在输入字符串中是否找到匹配项</li>
<li><code>Match()</code>，在输入字符串中搜索正则表达式的匹配项，并将精确结果作为单个<code>Match</code>对象进行返回</li>
<li><code>Matches()</code>，返回正则表达式所有成功的匹配，相当于多次调用<code>Match()</code></li>
<li><code>Replace()</code>，用指定替换字符串去替换匹配正则表达式的所有匹配项</li>
<li><code>Split()</code>，在正则表达式定义的位置将输入字符串拆分为一个字符串数组</li>
</ul>
</li>
</ul>
<h4 id="1-3-7-哈希表"><a href="#1-3-7-哈希表" class="headerlink" title="1.3.7 哈希表"></a>1.3.7 哈希表</h4><ul>
<li>集合类型，类似于python字典，键值对</li>
<li>哈希表每一个元素都是存储在<code>DictionaryEntry</code>对象中的键值对，键不能为空，值可用</li>
</ul>
<h5 id="1-3-7-1-构造函数"><a href="#1-3-7-1-构造函数" class="headerlink" title="1.3.7.1 构造函数"></a>1.3.7.1 构造函数</h5><ul>
<li><code>Hashtable()</code>构造方法创建<code>Hashtable</code>对象</li>
</ul>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 使用默认的初始容量、加载因子、哈希代码来创建实例
public Hashtable()

// 使用指定初始容量、默认加载因子、默认哈希代码来创建实例
public Hashtable(int capacity)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h5 id="1-3-7-2-Hashtable属性"><a href="#1-3-7-2-Hashtable属性" class="headerlink" title="1.3.7.2 Hashtable属性"></a>1.3.7.2 Hashtable属性</h5><ul>
<li><code>Count</code>：获取键值对数目</li>
<li><code>Item</code>：获取或设置与指定键相关联的值</li>
<li><code>Keys</code>：获取<code>Hashtable</code>中键的<code>ICollection</code></li>
<li><code>Values</code>：获取值的<code>ICollection</code></li>
</ul>
<h5 id="1-3-7-3-添加元素"><a href="#1-3-7-3-添加元素" class="headerlink" title="1.3.7.3 添加元素"></a>1.3.7.3 添加元素</h5><ul>
<li><code>Add()</code>，添加键值对</li>
</ul>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 参数 value可为空
public virtual void Add(Object key, Object value)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 例
Hashtable hash = new Hashtable();
hash.Add("id", "Bh001");
hash.Add("name", "TM");
hash.Add("sex", "男");

Console.WriteLine(hash,Count);

// 运行结果为：3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h5 id="1-3-7-4-删除元素"><a href="#1-3-7-4-删除元素" class="headerlink" title="1.3.7.4 删除元素"></a>1.3.7.4 删除元素</h5><ul>
<li><code>Clear()</code>和<code>Remove()</code></li>
</ul>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// Clear()，清空Hashtable
public virtual void Clear()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// Remove()，删除指定键元素
// 参数：key 为待删除元素的键
public virtual void Remove(Object key)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>



<h5 id="1-3-7-5-遍历哈希表"><a href="#1-3-7-5-遍历哈希表" class="headerlink" title="1.3.7.5 遍历哈希表"></a>1.3.7.5 遍历哈希表</h5><ul>
<li>因为哈希表元素是键值对，所以要使用<code>DictionaryEntry</code>结构进行遍历，其表示一个键值对的集合</li>
</ul>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 遍历哈希表，假设哈希表中已有元素
foreach(DictionaryEntry dic in hash)
{
	Console.WriteLine("\t" + dic.Key + "\t" + dic.Value);    
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h5 id="1-3-7-6-查找元素"><a href="#1-3-7-6-查找元素" class="headerlink" title="1.3.7.6 查找元素"></a>1.3.7.6 查找元素</h5><ul>
<li><code>Contains()、ContainsKey()、ContainsValue()</code></li>
</ul>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 寻找指定 键
// Contains() 和 ContainsKey() 方法功能、语法相同
// 只介绍Contains()方法
public virtual bool Contains(Object key)
    

// 寻找指定 值
public virtual bool ContainsValue(Object Value)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h3 id="1-4-类与对象"><a href="#1-4-类与对象" class="headerlink" title="1.4 类与对象"></a>1.4 类与对象</h3><h4 id="1-4-1-类"><a href="#1-4-1-类" class="headerlink" title="1.4.1 类"></a>1.4.1 类</h4><ul>
<li>类是一种数据类型，包含<strong>数据成员</strong>（常量和变量）、<strong>函数成员</strong>（方法、属性、事件、索引器、运算符、构造函数和析构函数）和<strong>嵌套类型</strong></li>
<li>==类可在不同源文件之间进行拆分==</li>
</ul>
<h5 id="1-4-1-1-类的声明"><a href="#1-4-1-1-类的声明" class="headerlink" title="1.4.1.1 类的声明"></a>1.4.1.1 类的声明</h5><ul>
<li>类的声明</li>
</ul>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">访问修饰符 class 类名
{
    
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>



<h5 id="1-4-1-2-构造函数和析构函数"><a href="#1-4-1-2-构造函数和析构函数" class="headerlink" title="1.4.1.2 构造函数和析构函数"></a>1.4.1.2 构造函数和析构函数</h5><ul>
<li><p>对象的生命周期从构造函数开始，析构函数结束</p>
</li>
<li><p>构造函数：用于对对象进行初始化，实例化对象时自动调用</p>
<ul>
<li>定义类时，若未定义构造函数，编译器会自动创建一个不带参数的默认构造函数</li>
</ul>
</li>
<li><p>要使用有参构造函数，需显式实例化，传入参数</p>
</li>
</ul>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">public class Book
{
    public Book()  // 无参构造函数
    {
        
    }
    
    public Book(int args)  // 有参构造函数
    {
        args = 2 + 3;
	}
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li><p>析构函数：用于回收对象资源，销毁对象时自动调用</p>
<ul>
<li><p>当某个实例化对象被认为不再有效，并符合析构条件时，<code>.NET Framework</code>类库的垃圾回收功能会自动调用析构函数实现垃圾回收</p>
</li>
<li><p>一个类只有一个析构函数，且无法调用析构函数，它是自动调用的</p>
</li>
</ul>
</li>
</ul>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// Main()函数执行完后，创建的demo实例pro不再有效，调用~demo析构函数，并打印字符串

public class demo
{
    ~demo()
    {
        Console.WriteLine("析构函数自动调用");
    }
    static void Main(string[] args)
    {
        demo pro = new demo();
    }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h5 id="1-4-1-3-属性"><a href="#1-4-1-3-属性" class="headerlink" title="1.4.1.3 属性"></a>1.4.1.3 属性</h5><ul>
<li><p>对象拥有的所有特征，在类中表示时称为类的属性</p>
</li>
<li><p>属性可以像使用公共数据成员一样使用，但它实际上是一种称为“访问器”的特殊方法，其指定了属性值被读取或写入时要执行的语句。通过该机制，可以把读取、写入对象的某些特性于操作关联起来</p>
</li>
<li><p>调用<code>对象名.属性名</code></p>
</li>
<li><p>属性的声明</p>
</li>
</ul>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">访问修饰符 数据类型 属性名
{
    // get访问器必须返回属性类型的值
    get
    {
        return 变量名;
    }
    
    // 使用value隐式参数，此参数的类型是属性的类型
    set
    {
        // set访问器可以包含大量语句，可对能赋予的值进行检查，避免给属性值设置错误
        变量名 = value;
    }
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// c#支持自动实现的属性，即在访问器中没有任何逻辑
// 自动实现的属性，必须同时拥有get和set两个访问器
public int Age
{
    get;
    set;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h5 id="1-4-1-4-方法"><a href="#1-4-1-4-方法" class="headerlink" title="1.4.1.4 方法"></a>1.4.1.4 方法</h5><ul>
<li><p>声明方法时，除了可以使用访问修饰符外，还可以使用<code>new、static、virtual、override、sealed、abstract、extern</code>等修饰符</p>
</li>
<li><p>关于新修饰符</p>
<ul>
<li><code>static、virtual、override</code>最多包含一个</li>
<li><code>new、override</code>最多包含一个</li>
<li>若声明中使用了<code>abstract</code>，则不能使用<code>static、virtual、sealed、extern </code></li>
<li>若使用了<code>private</code>，不能使用<code>virtual、override、abstract</code></li>
<li>若使用了<code>sealed</code>，那么还得包含<code>override</code>修饰符</li>
</ul>
</li>
<li><p>方法声明</p>
</li>
</ul>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">修饰符 返回值类型 方法名(参数列表)
{
    // 方法的具体实现
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li><p>方法形参的声明，可使用<code>params、ref、out</code>修饰</p>
<ul>
<li><p>==属性不能作为<code>ref、out</code>参数进行传递==</p>
</li>
<li><p><code>params</code>用来指定在参数数目可变的方法参数，<strong>必须是一维数组</strong></p>
</li>
</ul>
</li>
</ul>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">static void demo(params string[] list)
{
    for(int i = 0; i &lt; list.Length; i++)
    {
        Consolde.WriteLine(list[i]);
    }
}

static void Main()
{
    string[] a = new string[]{"我","是","中","国","人"};
    demo(a);
    Console.Read();
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li><p><code>ref</code>表示按<strong>引用传递</strong>参数</p>
<ul>
<li><p>如果使用<code>ref</code>参数，那么在方法声明和调用方法时都必须显式使用<code>ref</code>关键字</p>
</li>
<li><p>实参在传递前必须初始化</p>
</li>
</ul>
</li>
</ul>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">public static void Method(ref int i)
{
    i = 44;
}

public static void Main()
{
    int val = 0;
    Method(ref val);
    Console.WriteLine(val);
    Console.Read();
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li><p><code>out</code>同样是<strong>引用传递</strong></p>
<ul>
<li><p>在方法声明和调用方法时都必须显式使用<code>out</code>关键字</p>
</li>
<li><p>实参不需要初始化</p>
</li>
</ul>
</li>
</ul>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">public static void Method(out int i)
{
    i = 44;
}

public static void Main()
{
    int val;
    Method(out val);
    Console.WriteLine(val);
    Console.Read();
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h4 id="1-4-2-对象"><a href="#1-4-2-对象" class="headerlink" title="1.4.2 对象"></a>1.4.2 对象</h4><h5 id="1-4-2-1-对象的创建"><a href="#1-4-2-1-对象的创建" class="headerlink" title="1.4.2.1 对象的创建"></a>1.4.2.1 对象的创建</h5><ul>
<li>使用<code>new</code>关键字，如有一个<code>demo</code>类，实例化，<code>demo a = new demo()</code></li>
</ul>
<h5 id="1-4-2-2-访问对象的属性和行为"><a href="#1-4-2-2-访问对象的属性和行为" class="headerlink" title="1.4.2.2 访问对象的属性和行为"></a>1.4.2.2 访问对象的属性和行为</h5><ul>
<li>使用<code>.</code>操作符调用类的成员变量和成员方法</li>
</ul>
<h5 id="1-4-2-3-对象销毁"><a href="#1-4-2-3-对象销毁" class="headerlink" title="1.4.2.3 对象销毁"></a>1.4.2.3 对象销毁</h5><ul>
<li>有以下两种情况时，会被<code>.NET</code>垃圾回收器视为垃圾并进行回收<ul>
<li>对象引用超过其作用范围，</li>
<li>将对象赋值为<code>null</code></li>
</ul>
</li>
</ul>
<h4 id="1-4-3-静态类及其成员"><a href="#1-4-3-静态类及其成员" class="headerlink" title="1.4.3 静态类及其成员"></a>1.4.3 静态类及其成员</h4><ul>
<li><p>当属性和方法被修饰为<code>static</code>时，它们不属任一实例对象，直接通过类名进行调用</p>
</li>
<li><p>c# 不支持静态局部变量，==不能在方法中声明静态变量==</p>
</li>
<li><p>静态成员的作用</p>
<ul>
<li>保留已实例化的对象数的计数</li>
<li>存储必须在所有实例间共享的值</li>
</ul>
</li>
<li><p>若在定义类时加上关键字<code>static</code></p>
<ul>
<li>那么该类中只能包含静态成员</li>
<li>其无法实例化，所以也不能定义实例构造函数</li>
</ul>
</li>
<li><p>静态类会进行密封，<strong>无法继承</strong>，它们不能继承自任何的类或接口（<strong>除了Object</strong>）</p>
</li>
</ul>
<h4 id="1-4-4-this关键字"><a href="#1-4-4-this关键字" class="headerlink" title="1.4.4 this关键字"></a>1.4.4 this关键字</h4><ul>
<li><p><code>this</code>引用的是本类的一个对象</p>
</li>
<li><p>当局部变量或方法参数覆盖了成员变量时，就需要添加关键字<code>this</code>，来明确引用的是类成员还是局部变量或方法参数</p>
</li>
</ul>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">private void setName(String name)
{
    // 如果写为 name = name ，则只会把参数name的值赋给参数变量，成员变量name不会改变
    this.name = name;  // 将参数值赋予类中的成员变量
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li><code>this</code>还可作为方法返回值</li>
</ul>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">public Book getBook()
{
    return this;  // 返回Book类的引用
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>



<h4 id="1-4-5-继承"><a href="#1-4-5-继承" class="headerlink" title="1.4.5 继承"></a>1.4.5 继承</h4><h5 id="1-4-5-1-继承的实现"><a href="#1-4-5-1-继承的实现" class="headerlink" title="1.4.5.1 继承的实现"></a>1.4.5.1 继承的实现</h5><ul>
<li><p>基本思想：基于某个父类的扩展，指定出一个新的子类（派生类）</p>
</li>
<li><p>子类可以继承父类原有的属性和方法，也可以增加父类不具备的属性和方法，或者重写父类的方法</p>
</li>
<li><p>使用<code>:</code>来标识两个类的继承关系，当对一个类使用<code>sealed</code>修饰后，该类将不能被继承</p>
</li>
</ul>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">public class Computer
{
    // 父类
}

public class Pad:Computer  // Pad继承于Computer
{
    // 子类
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h5 id="1-4-5-2-base关键字"><a href="#1-4-5-2-base关键字" class="headerlink" title="1.4.5.2 base关键字"></a>1.4.5.2 base关键字</h5><ul>
<li><p>当子类对父类成员方法进行重写后，若要访问父类原有的方法，需要使用关键字<code>base</code>，使用方法同<code>this</code></p>
<ul>
<li>==重写父类方法时，修饰权限只能变大或者不变，变小访问权限是错误的==</li>
</ul>
</li>
<li><p>若要使用<code>base</code>调用父类的属性或方法，父类相应的属性和方法必须定义为<code>public</code>或<code>protected</code></p>
</li>
<li><p>另外，使用<code>base</code>关键字还可以指定创建子类实例时应调用的父类构造函数</p>
<ul>
<li>访问父类成员只能在构造函数、实例方法或实例属性中进行，==在静态方法中使用<code>base</code>关键字是错误的==</li>
</ul>
</li>
</ul>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 父类构造函数
public Goods(string tradecode, string fullname)
{
    TradeCode = tradecode;
    FullName = fullname;
}

// 子类基于父类定义构造函数
public JHInfo(string jhid, string tradecode, string fullname):base(tradecode,fullname)
{
    JHID = jhid;
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h5 id="1-4-5-3-继承中的构造-析构函数"><a href="#1-4-5-3-继承中的构造-析构函数" class="headerlink" title="1.4.5.3 继承中的构造/析构函数"></a>1.4.5.3 继承中的构造/析构函数</h5><ul>
<li>调用顺序，构造函数从最顶层父类依次调用到子类，析构函数反之<img src="image-20231107213904383-1705156191266-1.png" alt="" style="zoom:50%;"></li>
</ul>
<h4 id="1-4-6-多态"><a href="#1-4-6-多态" class="headerlink" title="1.4.6 多态"></a>1.4.6 多态</h4><h5 id="1-4-6-1-重写虚方法"><a href="#1-4-6-1-重写虚方法" class="headerlink" title="1.4.6.1 重写虚方法"></a>1.4.6.1 重写虚方法</h5><ul>
<li><p>方法默认情况下不是虚拟的，除构造函数外，其他方法可以显式地声明为<code>virtual</code></p>
</li>
<li><p>在方法前面加上关键字<code>virtual</code>，则该方法称为虚方法</p>
<ul>
<li><p>==类中的成员字段和静态方法不能声明为<code>virtual</code>==</p>
</li>
<li><p><code>virtual</code>只对类中的实例函数和属性有意义</p>
</li>
</ul>
</li>
</ul>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 声明一个虚方法
public virtual void Move()
{
    Console.WriteLine("交通工具可以移动");
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>定义虚方法后，可以在派生类中重写虚方法，使用关键字<code>override</code></li>
</ul>
<pre class="line-numbers language-C#" data-language="C#"><code class="language-C#">// 在派生类中重写虚方法
public override void Move()
{
    Console。WriteLine("火车可以移动");
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h5 id="1-4-6-2-方法重载"><a href="#1-4-6-2-方法重载" class="headerlink" title="1.4.6.2 方法重载"></a>1.4.6.2 方法重载</h5><ul>
<li><p>指的是方法名相同，但参数的数据类型、个数和顺序不同的方法</p>
</li>
<li><p>当类中有两种以上同名方法（重载），需清楚要调用哪种方法</p>
</li>
</ul>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 定义静态方法Add()，参数为两个int，返回值为int
public static int Add(int x, int y)
{
    return x+y;
}

// 重载Add()，参数为一个int一个double，返回值为double
public double Add(int x, double y)
{
    return x+y;
}

// 再次重载Add()，其参数个数较第一个函数增加为3个
public int Add(int x, int y, int z)
{
    return x+y+z;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h4 id="1-4-7-结构"><a href="#1-4-7-结构" class="headerlink" title="1.4.7 结构"></a>1.4.7 结构</h4><ul>
<li>值类型，用来封装一组相关变量</li>
</ul>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">结构修饰符 struct 结构名
{
    
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>结构可包括构造函数、常量、字段、方法、属性、运算符、事件和嵌套类型等</li>
</ul>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 声明一个矩形结构，定义宽高，Area()方法
public struct Rect
{
    public double width;
    public double height;
    public double Area()
    {
        return width*height;
    }
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li><p>向方法传递结构时，结构是通过传值方式进行传递的，不是作为引用传递</p>
</li>
<li><p>结构可以声明构造函数，但必须带参数</p>
</li>
<li><p>结构实例化，可以不用<code>new</code></p>
</li>
<li><p>所有结构都直接继承自<code>System.ValueType</code>，所以一个结构不能继承于另一个结构或类</p>
</li>
<li><p>在结构中初始化实例字段是错误的</p>
</li>
</ul>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">public struct Rect
{
    public double width;
    public double height;
    
    // 构造函数
    public Rect(double x, double y)
    {
        width = x;
        height = y;
    }
    
    public double Area()
    {
        return width*height;
    }
}

static void Main(string[] args)
{
    Rect rect1;  // 实例化一个矩形结构
    rect1.width = 5;
    rect1.height = 3;
    Console.WriteLine("矩形面积为：" + rect1.Area());
    
    Rect rect2 = new Rect(6, 4);  // 使用构造函数实例化矩形结构
    Console.WriteLine("矩形面积为：" + rect2.Area());
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h3 id="1-5-控制台应用程序"><a href="#1-5-控制台应用程序" class="headerlink" title="1.5 控制台应用程序"></a>1.5 控制台应用程序</h3><h4 id="1-5-1-主要语句"><a href="#1-5-1-主要语句" class="headerlink" title="1.5.1 主要语句"></a>1.5.1 主要语句</h4><ul>
<li><strong>打印</strong></li>
</ul>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 打印且换行
// cw + 2下Tab  快捷生成该语句
System.Console.WriteLine();

// 打印不换行
System.Console.Write();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li><strong>读取</strong></li>
</ul>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 读取单个按键
System.Console.ReadKey();

// 读取字串
System.Console.ReadLine();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h4 id="1-5-2-示例"><a href="#1-5-2-示例" class="headerlink" title="1.5.2 示例"></a>1.5.2 示例</h4><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">using System;

namespace fund
{
    internal static class Program
    {
        static void Main()
        {
           	int temp = 0;
            // 使用int类方法Parse()，将接收的string强转为int
            temp = int.Parse(Console.ReadLine());
            // "结果为："+temp+30    temp和30会自动转为字符串，与"结果为："进行拼接
            Console.WriteLine("结果为："+temp+30);
            Console.ReadKey();
        }
    }
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h3 id="1-6-文件操作"><a href="#1-6-文件操作" class="headerlink" title="1.6 文件操作"></a>1.6 文件操作</h3><ul>
<li>使用命名空间<code>using System.IO;</code></li>
</ul>
<h4 id="1-6-1-获取文件"><a href="#1-6-1-获取文件" class="headerlink" title="1.6.1 获取文件"></a>1.6.1 获取文件</h4><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 获取对应路径下的文件
string path = @"C:\Users\echo\Desktop";
DirectoryInfo root = new DirectoryInfo(path);
FileInfo[] files = root.GetFiles();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>



<h4 id="1-6-2-删除指定文件"><a href="#1-6-2-删除指定文件" class="headerlink" title="1.6.2 删除指定文件"></a>1.6.2 删除指定文件</h4><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 遍历文件集合
for (int i = 0; i &lt; files.Length; i++)
{
	FileInfo fi = files[i];
    
    // 打印 文件绝对路径
    //Console.WriteLine(fi.FullName);
    // 打印 文件名
    //Console.WriteLine(fi.Name);

    // 删除 指定文件
    if (fi.Name == "123.txt")
    {
        // 传入绝对路径
        File.Delete(fi.FullName);
    }
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h4 id="1-6-3-更改文件名"><a href="#1-6-3-更改文件名" class="headerlink" title="1.6.3 更改文件名"></a>1.6.3 更改文件名</h4><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 文件改名
bool isHave = fi.Name.Contains("123");  // 也可参数补全文件后缀，删更改指定文件类型的文件名
if (isHave)
{
    // 获取原始绝对路径文件名
    string srcFileName = fi.FullName;
    // 定义新绝对路径文件名，不更改文件类型
    string dstFileName = fi.Directory.FullName+@"\ddd"+fi.Extension;
    // 对文件进行更名，并移动到指定位置
    File.Move(srcFileName, dstFileName);
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h3 id="1-7-随机数"><a href="#1-7-随机数" class="headerlink" title="1.7 随机数"></a>1.7 随机数</h3><h4 id="1-7-1-Random类"><a href="#1-7-1-Random类" class="headerlink" title="1.7.1 Random类"></a>1.7.1 Random类</h4><ul>
<li>通过<code>Random</code>类产生，该类并非静态类，所以必须通过实例化产生</li>
</ul>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 实例化一个random类，并产生1-33的随机整数
Random a = new random();
a.Next(1,34);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>



<h4 id="1-7-2-例程1-–-双色球"><a href="#1-7-2-例程1-–-双色球" class="headerlink" title="1.7.2 例程1 – 双色球"></a>1.7.2 例程1 – 双色球</h4><ul>
<li><p>具体代码文件见<code>D:\Program Files\Microsoft Visual Studio\projects\start\write</code></p>
</li>
<li><p>以双色球开奖为例，6个红色球取值为1-33，1个蓝色球取值为1-16</p>
</li>
<li><p>界面搭建如图</p>
<ul>
<li><img src="image-20231031162713259-1705156191295-2.png" alt="" style="zoom: 25%;"></li>
</ul>
</li>
<li><p>通过<code>开始抽奖</code>按钮（button1），启动时钟，并设置时间间隔；<code>停止抽奖</code>按钮（button2）关闭时钟；<code>timer1</code>时钟触发<code>tick</code>事件内，执行产生7位随机数</p>
</li>
</ul>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 开始抽奖按钮
private void button1_Click(object sender, EventArgs e)
{
    timer1.Enabled = true;
    timer1.Interval = 100;
    
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 停止抽奖按钮
private void button2_Click(object sender, EventArgs e)
{
    timer1.Enabled=false;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 时钟触发事件
 private void timer1_Tick(object sender, EventArgs e)
 {
 	Random a = new Random();
 	// 感觉生成7个随机数的代码有些冗余，不知道能不能通过循环实现，后续优化！！！
     
 	/*
 	// 简化代码
 	// 设置文本的 Label 集合
    Label[] labels = {label1, label2, label3, label4, label5, label6};

    // 循环设置每个 Label 的文本
    foreach (Label label in labels)
    {
        label.Text = Convert.ToString(random.Next(1, 34));
    }
    label7.Text = Convert.ToString(a.Next(1, 17));
 	*/
     
    label1.Text = Convert.ToString(a.Next(1,34));

    label2.Text = Convert.ToString(a.Next(1, 34));

    label3.Text = Convert.ToString(a.Next(1, 34));

    label4.Text = Convert.ToString(a.Next(1, 34));

    label5.Text = Convert.ToString(a.Next(1, 34));

    label6.Text = Convert.ToString(a.Next(1, 34));

    label7.Text = Convert.ToString(a.Next(1, 17));
 }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>效果如下<img src="双色球-1705156191295-3.gif" alt="" style="zoom: 33%;"></li>
</ul>
<h4 id="1-7-3-例程2-–-按键图片切换"><a href="#1-7-3-例程2-–-按键图片切换" class="headerlink" title="1.7.3 例程2 – 按键图片切换"></a>1.7.3 例程2 – 按键图片切换</h4><ul>
<li><p>具体代码文件见<code>D:\Program Files\Microsoft Visual Studio\projects\start\write2</code></p>
</li>
<li><p>每次按键，随机切换图片</p>
</li>
<li><p>在<code>debug</code>文件夹下新建一个<code>img</code>文件夹，并在其中存入<code>1-6.jpg</code></p>
</li>
<li><p>搭建界面如下</p>
<ul>
<li><img src="image-20231031180022076-1705156191295-5.png" alt="" style="zoom: 25%;"></li>
</ul>
</li>
<li><p>通过点击<code>button</code>按钮，触发<code>click</code>事件，产生随机数，导入图片到<code>pictureBox</code>展示</p>
</li>
</ul>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// button_click事件
private void button2_Click(object sender, EventArgs e)
{
    Random a = new Random();
    double num = a.NextDouble();
    // 产生1-6的数字
    int picnum = Convert.ToInt32(Math.Floor(num*6) + 1);

    // 图片载入
    pictureBox1.SizeMode = PictureBoxSizeMode.StretchImage;
    
    // 相对路径，默认路径为项目文件下的debug文件
    pictureBox1.Image = Image.FromFile(@"img\" + picnum + ".jpg");
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>效果如下<img src="/2024/01/13/shang-wei-ji/%E6%8C%89%E9%94%AE%E5%9B%BE%E7%89%87%E5%88%87%E6%8D%A2-1705156191295-4.gif" alt="按键图片切换"></li>
</ul>
<h3 id="1-8-访问修饰符"><a href="#1-8-访问修饰符" class="headerlink" title="1.8 访问修饰符"></a>1.8 访问修饰符</h3><ul>
<li><p>所有的<strong>类型及其成员</strong>都具有可访问性级别</p>
</li>
<li><p><strong>程序集</strong>通过编译单个或多个<code>.cs</code>文件产生的<code>.dll</code>或<code>.exe</code></p>
</li>
<li><p><code>public</code>：同一程序集中的<strong>任何其他代码</strong>或引用该程序集的其他程序集<strong>都可访问该类型或成员</strong></p>
</li>
<li><p><code>private</code>：只有<strong>同一<code>class</code>或<code>struct</code>中的代码</strong>可以访问类型或成员</p>
</li>
<li><p><code>protected</code>：只有**同一<code>class</code>或从其派生出的<code>class</code>**可以访问</p>
</li>
<li><p><code>internal</code>：<strong>同一程序集中的任何代码</strong>均可访问，但外部程序集不行</p>
</li>
<li><p><code>protected internal</code>：本程序集中及其他程序集的派生<code>class</code></p>
</li>
<li><p><code>private protected</code>：在类内及本程序集派生类中可访问</p>
</li>
<li><p>访问修饰符摘要表</p>
<ul>
<li><img src="image-20231031224437966-1705156191295-6.png" alt="" style="zoom: 50%;"></li>
</ul>
</li>
</ul>
<h3 id="1-9-字段"><a href="#1-9-字段" class="headerlink" title="1.9 字段"></a>1.9 字段</h3><ul>
<li>什么是字段<ul>
<li>字段(field)是一种表示与对象或类型（类与结构体）相关联的变量</li>
<li>字段是类型的成员，也被称为“成员变量”</li>
<li>类型方法体内定义的变量属于局部变量，不是字段</li>
<li>分类<ul>
<li>实例字段：与实例化对象相关联的成员变量</li>
<li>静态字段：与类型相关联的成员变量，由<code>static</code>修饰</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="1-10-属性"><a href="#1-10-属性" class="headerlink" title="1.10 属性"></a>1.10 属性</h3><h2 id="二、控件及事件-–-B站刘金玉视频总结"><a href="#二、控件及事件-–-B站刘金玉视频总结" class="headerlink" title="二、控件及事件 – B站刘金玉视频总结"></a>二、控件及事件 – B站刘金玉视频总结</h2><h3 id="2-1-控件简介"><a href="#2-1-控件简介" class="headerlink" title="2.1 控件简介"></a>2.1 控件简介</h3><ul>
<li>所有的控件都是对象，对象三要素<strong>属性、方法、事件</strong></li>
<li>当控件从工具箱被拖到form窗体后，变成实例对象</li>
<li>控件分类<ul>
<li>公共控件：以表单为主</li>
<li>容器控件：界面布局使用，使界面干净整洁</li>
<li>菜单和工具栏控件</li>
<li>组件</li>
<li>打印控件</li>
<li>对话框控件</li>
<li>数据控件</li>
<li>WPF互操作性</li>
</ul>
</li>
<li>控件基本操作：点选控件 =&gt; 更改其属性</li>
</ul>
<h3 id="2-2-Form窗体"><a href="#2-2-Form窗体" class="headerlink" title="2.2 Form窗体"></a>2.2 Form窗体</h3><h4 id="2-2-1-基本介绍"><a href="#2-2-1-基本介绍" class="headerlink" title="2.2.1 基本介绍"></a>2.2.1 基本介绍</h4><ul>
<li><p><code>Form1.cs[设计]</code> 文件：可视化窗体界面</p>
</li>
<li><p><code>Form1.cs</code> 文件：后台代码界面</p>
</li>
<li><p><code>Form1.Designer.cs</code> 文件：具体窗体设计代码，其中方法被调用</p>
</li>
<li><p>Form窗体加载过程：</p>
<ul>
<li>项目起点，<code>Program.cs</code>中的<code>Main()</code>，创建Form实例</li>
<li>到<code>Form1.cs</code>中调用<code>InitializeComponent()</code>，初始化窗体界面</li>
<li>再到<code>Form1.Designer.cs</code>中执行相应代码，实现窗体和控件布局</li>
</ul>
</li>
</ul>
<h4 id="2-2-2-例程-–-Form窗体控制"><a href="#2-2-2-例程-–-Form窗体控制" class="headerlink" title="2.2.2 例程 – Form窗体控制"></a>2.2.2 例程 – Form窗体控制</h4><ul>
<li><p>具体代码文件见<code>D:\Program Files\Microsoft Visual Studio\projects\start\控件</code></p>
</li>
<li><p>以两按钮分别控制Form窗体背景颜色及标题</p>
</li>
<li><p>拖两个<code>Button</code>控件到<code>Form</code>窗体内，分别修改<code>Text</code>为：背景变色、换标题</p>
</li>
<li><p>分别双击创建相应<code>ButtonClick</code>事件，并自动跳转到<code>Form.cs</code>中生成相应方法</p>
</li>
</ul>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 背景变色
private void button1_Click(object sender, EventArgs e)
{
    // 注意ActiveForm，窗体必须是被激活的当前窗体，才能修改其属性
    Form1.ActiveForm.BackColor = Color.AliceBlue;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 换标题
private void button2_Click(object sender, EventArgs e)
{
    Form1.ActiveForm.Text = "换标题";
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>效果如下<img src="form窗体控制-1705156191295-7.gif" alt="" style="zoom:33%;"></li>
</ul>
<h3 id="2-3-鼠标事件"><a href="#2-3-鼠标事件" class="headerlink" title="2.3 鼠标事件"></a>2.3 鼠标事件</h3><ul>
<li><p>具体代码文件见<code>D:\Program Files\Microsoft Visual Studio\projects\start\Mouse</code></p>
</li>
<li><p>以<code>PictureBox</code>显示本地图片，通过鼠标触发<code>Click、MouseClick、DoubleClick、MouseHover事件</code></p>
</li>
</ul>
<h4 id="2-3-1-PictureBox显示图片"><a href="#2-3-1-PictureBox显示图片" class="headerlink" title="2.3.1 PictureBox显示图片"></a>2.3.1 PictureBox显示图片</h4><ul>
<li>拖动该控件到<code>Form1</code>窗体内</li>
<li>找到<code>Image</code>属性，通过<code>...</code>导入本地图片即可</li>
</ul>
<h4 id="2-3-2-例程1-–-Click事件"><a href="#2-3-2-例程1-–-Click事件" class="headerlink" title="2.3.2 例程1 – Click事件"></a>2.3.2 例程1 – Click事件</h4><ul>
<li><p>任意<strong>单击</strong>事件，包括鼠标、键盘等</p>
</li>
<li><p>点击后通过<code>MessageBox</code>进行提示</p>
</li>
</ul>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 单击事件
private void pictureBox1_Click(object sender, EventArgs e)
{
    MessageBox.Show("Click事件");
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>效果如下<img src="Click事件-1705156191295-8.gif" alt="" style="zoom:33%;"></li>
</ul>
<h4 id="2-3-3-例程2-–-MouseClick事件"><a href="#2-3-3-例程2-–-MouseClick事件" class="headerlink" title="2.3.3 例程2 – MouseClick事件"></a>2.3.3 例程2 – MouseClick事件</h4><ul>
<li><strong>鼠标单击</strong>事件</li>
</ul>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">private void pictureBox1_MouseClick(object sender, MouseEventArgs e)
{
    // e.Button.ToString()的取值分别为Left、Middle、Right，为鼠标三个按键
    // 可用于条件判断
    MessageBox.Show(e.Button.ToString());
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>效果如下<img src="/2024/01/13/shang-wei-ji/MouseClick%E4%BA%8B%E4%BB%B6-1705156191295-9.gif" alt="MouseClick事件"></li>
</ul>
<h4 id="2-3-4-例程3-–-DoubleClick事件"><a href="#2-3-4-例程3-–-DoubleClick事件" class="headerlink" title="2.3.4 例程3 – DoubleClick事件"></a>2.3.4 例程3 – DoubleClick事件</h4><ul>
<li><p>任意<strong>双击</strong>事件（双击包含单击事件，当同时存在单击事件时，只触发单击事件）</p>
</li>
<li><p>同样通过<code>MessageBox</code>提示</p>
</li>
</ul>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">private void pictureBox1_DoubleClick(object sender, EventArgs e)
{
    MessageBox.Show("DoubleClick事件");
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>效果如下<img src="DoubleClick事件-1705156191295-10.gif" alt="DoubleClick事件" style="zoom:33%;"></li>
</ul>
<h4 id="2-3-5-例程4-–-MouseHover事件"><a href="#2-3-5-例程4-–-MouseHover事件" class="headerlink" title="2.3.5 例程4 – MouseHover事件"></a>2.3.5 例程4 – MouseHover事件</h4><ul>
<li>当鼠标移动到上方时触发</li>
</ul>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">private void pictureBox1_MouseHover(object sender, EventArgs e)
{
    MessageBox.Show("MouseHover事件");
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>效果如下<img src="MouseHover事件-1705156191295-11.gif" alt="" style="zoom:33%;"></li>
</ul>
<h3 id="2-4-多窗体"><a href="#2-4-多窗体" class="headerlink" title="2.4 多窗体"></a>2.4 多窗体</h3><h4 id="2-4-1-创建启动窗体"><a href="#2-4-1-创建启动窗体" class="headerlink" title="2.4.1 创建启动窗体"></a>2.4.1 创建启动窗体</h4><ul>
<li>创建一个登录界面，点击登陆后（此处不对账号密码进行判断），跳转界面</li>
<li>登录界面<code>Form1</code>如下图所示<ul>
<li><img src="image-20231029181612428-1705156191295-12.png" alt="" style="zoom: 50%;"></li>
</ul>
</li>
</ul>
<h4 id="2-4-2-创建跳转窗体"><a href="#2-4-2-创建跳转窗体" class="headerlink" title="2.4.2 创建跳转窗体"></a>2.4.2 创建跳转窗体</h4><ul>
<li>跳转窗体界面<code>Form2</code>如下图所示<ul>
<li><img src="image-20231029182144541-1705156191295-13.png" alt="" style="zoom: 50%;"></li>
</ul>
</li>
</ul>
<h4 id="2-4-3-跳转"><a href="#2-4-3-跳转" class="headerlink" title="2.4.3 跳转"></a>2.4.3 跳转</h4><ul>
<li><p>具体代码文件见<code>D:\Program Files\Microsoft Visual Studio\projects\start\MutipleForm</code></p>
</li>
<li><p>点击启动界面的<code>登录</code>按钮后，跳转到新窗体</p>
</li>
</ul>
<h5 id="2-4-3-1-例程1-–-跳转-不关闭原窗口"><a href="#2-4-3-1-例程1-–-跳转-不关闭原窗口" class="headerlink" title="2.4.3.1 例程1 – 跳转-不关闭原窗口"></a>2.4.3.1 例程1 – 跳转-不关闭原窗口</h5><ul>
<li>双击<code>Form1</code>登录按钮，生成<code>Click</code>事件</li>
</ul>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 登录弹窗
private void button2_Click(object sender, EventArgs e)
{
    Form2 f2 = new Form2();
    f2.Show();
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>实现效果如下图，此时，关闭<code>Form1</code>，<code>Form2</code>也自动关闭（因为<code>Form2</code>在<code>Form1</code>类内部生成，视作<code>Form1</code>窗体的一部分）；反之需逐一关闭<img src="/2024/01/13/shang-wei-ji/%E8%B7%B3%E8%BD%AC-%E4%B8%8D%E5%85%B3%E9%97%AD%E5%8E%9F%E7%AA%97%E5%8F%A3-1705156191295-14.gif" alt="跳转-不关闭原窗口"></li>
</ul>
<h5 id="2-4-3-2-例程2-–-跳转-隐藏原窗口"><a href="#2-4-3-2-例程2-–-跳转-隐藏原窗口" class="headerlink" title="2.4.3.2 例程2 – 跳转-隐藏原窗口"></a>2.4.3.2 例程2 – 跳转-隐藏原窗口</h5><ul>
<li><p>隐藏窗口后，该窗口仍然占据内存空间，正常运行，需通过任务管理器进行关闭！！！</p>
</li>
<li><p>修改<code>button2_Click</code>方法</p>
</li>
</ul>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">private void button2_Click(object sender, EventArgs e)
{
    Form2 f2 = new Form2();
    f2.Show();
    
    // 因为button2_Click()方法在类Form1内，所以以下两种方法皆可，都是对Form1窗口进行隐藏
    this.Hide();
    // Hide();
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>效果如下<img src="跳转-隐藏原窗口-1705156191295-15.gif" alt="" style="zoom:33%;"></li>
</ul>
<h5 id="2-4-3-3-例程3-–-跳转-关闭原窗口"><a href="#2-4-3-3-例程3-–-跳转-关闭原窗口" class="headerlink" title="2.4.3.3 例程3 – 跳转-关闭原窗口"></a>2.4.3.3 例程3 – 跳转-关闭原窗口</h5><ul>
<li><p>扩展</p>
<ul>
<li><p>窗体<code>ShowDialog()</code>方法，默认使用模态方式</p>
</li>
<li><p>模态：以当前窗体为焦点，不能点击该程序的其他窗体</p>
</li>
</ul>
</li>
</ul>
<p><strong>（1）委托线程</strong></p>
<ul>
<li><p>首先在<code>Form1.cs</code>导入命名空间<code>using System.Threading;</code></p>
</li>
<li><p>接着修改<code>button2_Click()</code></p>
</li>
</ul>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">private void button2_Click(object sender, EventArgs e)
{
    Form2 f2 = new Form2();
    //f2.Show();
    //this.Hide();

    // 委托一个线程去显示新窗体
    Thread t1 = new Thread(delegate () { f2.ShowDialog(); });
    // 开启线程
    t1.Start();

    Close();
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>效果如下<img src="跳转-关闭原窗口-委托线程-1705156191295-16.gif" alt="" style="zoom:33%;"></li>
</ul>
<p><strong>（2）Application.Run()方法</strong></p>
<ul>
<li>通过在<code>Program.cs</code>启动文件中建立标志变量监测第一个窗口关闭，之后打开<code>Form2</code></li>
</ul>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// Program.cs文件 Prigram类

internal static class Program
 {
     // 定义标志变量flag
     public static bool flag = false;
     /// &lt;summary&gt;
     /// 应用程序的主入口点。
     /// &lt;/summary&gt;
     [STAThread]
     static void Main()
     {
         Application.EnableVisualStyles();
         Application.SetCompatibleTextRenderingDefault(false);
         Application.Run(new Form1());
         
         // 当原窗口被关闭，flag==true时，打开新窗口
         if (flag)
         {
             Application.Run(new Form2());
         }
     }
 }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// Form1.cs文件中方法 button2_Click()

private void button2_Click(object sender, EventArgs e)
{
    // 因为flag定义在Program类中，所以重新赋值时，需要加上前缀Program.flag
    Program.flag = true;
	
    // 关闭Form1
    Close();
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>效果如下<img src="/2024/01/13/shang-wei-ji/%E8%B7%B3%E8%BD%AC-%E5%85%B3%E9%97%AD%E5%8E%9F%E7%AA%97%E5%8F%A3-Application.Run()%E6%96%B9%E6%B3%95.gif" alt="跳转-关闭原窗口-Application.Run(./../../../../Typora/Projects/上位机/assets/跳转-关闭原窗口-Application.Run()方法.gif)方法"></li>
</ul>
<h3 id="2-5-复选框及复选框列表"><a href="#2-5-复选框及复选框列表" class="headerlink" title="2.5 复选框及复选框列表"></a>2.5 复选框及复选框列表</h3><ul>
<li><code>CheckBox</code>复选框控件</li>
<li><code>CheckBoxList</code>复选框列表控件：内含多个复选框控件（需要自行配置）</li>
</ul>
<h4 id="2-5-1-CheckBox控件"><a href="#2-5-1-CheckBox控件" class="headerlink" title="2.5.1 CheckBox控件"></a>2.5.1 CheckBox控件</h4><ul>
<li><p>图例：<img src="image-20231030181830622-1705156191295-17.png" alt="" style="zoom:50%;"></p>
</li>
<li><p><code>CheckBox.Checked</code>属性：获取该复选框有没有被勾选</p>
</li>
<li><p><code>CheckBox.Text</code>属性：获取该复选框文本内容</p>
</li>
</ul>
<h4 id="2-5-2-CheckBoxList控件"><a href="#2-5-2-CheckBoxList控件" class="headerlink" title="2.5.2 CheckBoxList控件"></a>2.5.2 CheckBoxList控件</h4><ul>
<li>选择时，首先会定位，然后才能选中</li>
<li><code>CheckBoxList.SelectItem</code>属性：获取当前选中项</li>
<li><code>checkedListBox.Items.Add(string)</code>：<strong>动态添加</strong>选项</li>
<li><code>checkedListBox.Items.Remove</code>：<strong>动态删除</strong>选项</li>
<li><code>ItemCheck</code>事件：当复选框被勾选时触发</li>
<li><code>SelectedIndexChanged</code>事件：未勾选选项，选中选项标题时就会触发</li>
</ul>
<h3 id="2-6-时钟"><a href="#2-6-时钟" class="headerlink" title="2.6 时钟"></a>2.6 时钟</h3><ul>
<li><p>时间单位<code>ms</code></p>
</li>
<li><p>作用：对有规律的事物进行输出，每隔指定时间，对一程序进行输出</p>
</li>
<li><p><code>Timer</code>配置</p>
<ul>
<li><p>配置时间，<code>Interval</code>属性</p>
</li>
<li><p>是否启动，<code>Enabled</code>属性</p>
</li>
<li><p>配置事件，<code>Tick</code>事件，在其中执行相应事件</p>
</li>
</ul>
</li>
</ul>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// Enable后，每隔Interval时间，执行一次Tick事件
private void timer1_Tick(object sender, EventArgs e)
{
    // 通过label控件，将当前时间显示在窗口，并每隔Interval时间刷新一下
    label1.Text = DateTime.Now.ToString();
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h3 id="2-7-图片"><a href="#2-7-图片" class="headerlink" title="2.7 图片"></a>2.7 图片</h3><h4 id="2-7-1-PictureBox控件"><a href="#2-7-1-PictureBox控件" class="headerlink" title="2.7.1 PictureBox控件"></a>2.7.1 PictureBox控件</h4><ul>
<li><p><code>PictureBox</code>控件</p>
</li>
<li><p><code>Picture.SizeMode</code>属性，更改图片显示拉伸情况</p>
</li>
</ul>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 将图片设置为自动拉伸，大小随展示图片框变化
pictureBox1.SizeMode = PictureBoxSizeMode.StretchImage;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<ul>
<li><code>PictureBox.Image</code>属性，导入图片</li>
</ul>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 传入图片例子
PictureBox.Image = Image.FromFile("图片位置");

// Application.StartupPath，位置为xx\bin\debug
PictureBox.Image = Image.FromFile(Application.StartupPath + @"\自建图片位置");<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li><p><strong>图片位置坐标</strong></p>
<ul>
<li><p><code>PictureBox.Left</code>属性，int类型，为控件左边缘与form窗体左边缘的<strong>像素距离</strong>，即可代表**<code>x</code>坐标**的值</p>
</li>
<li><p><code>PictureBox.Top</code>属性，控件上边缘与Form窗体上边缘的像素距离，代表**<code>y</code>坐标**的值</p>
<ul>
<li>（x, y）坐标为图片左上角顶点坐标，<strong>xy轴方向同图像坐标</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 使用时钟控件，实现图片的自动水平移动
private void timer1_Tick(object sender, EventArgs e)
{
  // enable时钟后，随interval时间间隔改变图片x坐标
  pictureBox1.Left += 1;
  // 改变图片y坐标
  pictureBox1.Top += 1;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h4 id="2-7-2-例程1-–-猫咪避障"><a href="#2-7-2-例程1-–-猫咪避障" class="headerlink" title="2.7.2 例程1 – 猫咪避障"></a>2.7.2 例程1 – 猫咪避障</h4><ul>
<li><p>具体代码文件见<code>D:\Program Files\Microsoft Visual Studio\projects\start\plane</code></p>
</li>
<li><p>通过使用<code>MouseDown、MouseUp、MouseMove</code>三个事件，实现鼠标拖动猫咪避障</p>
</li>
<li><p>首先定外部变量</p>
</li>
</ul>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 标志变量记录鼠标左键是否按下
bool flag = false;

// 图片初始坐标
int oldX = 0;
int oldY = 0;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>当鼠标左键在图片中被按下时，获取当前鼠标坐标，并作为图片初始移动坐标</li>
</ul>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">private void pictureBox1_MouseDown(object sender, MouseEventArgs e)
{
    // 当被按下的键为鼠标左键时执行
    if(e.Button == MouseButtons.Left)
    {
        flag = true;
        oldX = e.X;
        oldY = e.Y;
    }
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>当鼠标左键抬起时，置<code>flag</code>变量为<code>false</code>，停止鼠标拖动图片移动</li>
</ul>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">private void pictureBox1_MouseUp(object sender, MouseEventArgs e)
{
    if (e.Button == MouseButtons.Left)
    {
        flag = false;
    }
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>当鼠标左键被按下并移动时，更新图片坐标</li>
</ul>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">private void pictureBox1_MouseMove(object sender, MouseEventArgs e)
{
    if (flag)
    {
        // 更新xy坐标
        // 拖动的效果是连续的，因为每当鼠标移动1个像素，图片立即就进行相应移动
        // 所以从视觉上来看是连续的，非卡顿的
        pictureBox1.Left += e.X - oldX;
        pictureBox1.Top += e.Y - oldY;
    }
    
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>效果如下<img src="/2024/01/13/shang-wei-ji/%E7%8C%AB%E5%92%AA%E9%81%BF%E9%9A%9C-1705156191295-18.gif" alt="猫咪避障"></li>
</ul>
<h4 id="2-7-3-例程2-–-画布软件"><a href="#2-7-3-例程2-–-画布软件" class="headerlink" title="2.7.3 例程2 – 画布软件"></a>2.7.3 例程2 – 画布软件</h4><ul>
<li><p>具体代码文件见<code>D:\Program Files\Microsoft Visual Studio\projects\start\draw</code></p>
</li>
<li><p>同样使用<code>MouseDown、MouseUp、MouseMove、ButtonClick</code>事件实现复制粘贴图片、画笔绘图操作</p>
</li>
<li><p>搭建界面如图</p>
<ul>
<li><img src="image-20231101163806614-1705156191295-19.png" alt="" style="zoom: 50%;"></li>
</ul>
</li>
<li><p>首先定义全局变量</p>
</li>
</ul>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 定义图片对象
Image curImg;

// 记录鼠标第一次点击
bool moving = false;

// 定义图片尺寸
int curImgWidth = 0;
int curImgHeight = 0;

// 记录画笔颜色
Color curColor;

// 是否使用画笔
bool usePen = false;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>当已有的两张图片被点击，获取该图片路径及尺寸，并把<code>usePen</code>置为<code>false</code></li>
</ul>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 第一张图的MouseDown事件
private void pictureBox1_MouseDown(object sender, MouseEventArgs e)
{
    curImg = Image.FromFile(@"img\1.jpg");
    curImgWidth = pictureBox1.Width;
    curImgHeight = pictureBox1.Height;
    
    // 为避免在图片粘贴时，同步产生画笔绘制效果，将usePen置为false
    usePen = false;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 第二张图MouseDown事件
private void pictureBox2_MouseDown(object sender, MouseEventArgs e)
{
    curImg = Image.FromFile(@"img\2.jpg");
    curImgWidth = pictureBox2.Width;
    curImgHeight = pictureBox2.Height;
    usePen = false;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>当<code>使用画笔</code>按钮被按下后，弹出颜色选框，并设定画笔颜色</li>
</ul>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// "使用画笔"按钮，click事件
private void button1_Click(object sender, EventArgs e)
{
    // colorDialog控件
    // colorDialog1.ShowDialog()，开启颜色选框，返回颜色选择状态
    // 如果选择完毕，返回ok
    if (colorDialog1.ShowDialog() == DialogResult.OK)
    {
        // 将当前选中的颜色赋值给curColor对象
        curColor = colorDialog1.Color;

        // 画笔绘制时，将要粘贴的图片对象置空，避免粘贴图片与画笔绘制冲突
        curImg = null;

        // 将画笔标志变量置为true
        usePen = true;
    }
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>对于画布，分别处理<code>MouseDown、MouseUp、MouseMOve</code>事件</li>
</ul>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// MouseDown事件
private void pictureBox3_MouseDown(object sender, MouseEventArgs e)
{
    moving = true;

    // 创建绘制功能
    Graphics g = pictureBox3.CreateGraphics();

    // 当图片没有装载的时候，默认值为null
    
    if(curImg == null &amp;&amp; usePen == false)
    {
        MessageBox.Show("没有点选图片或画笔");
        return;
    }
    if(curImg != null &amp;&amp; usePen == false)
    {
        // 在xy坐标位置绘制图片，贴图
        g.DrawImage(curImg, e.X - curImgWidth / 2, e.Y - curImgHeight / 2, curImgWidth, curImgHeight);
    }
    
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// MouseUp事件
private void pictureBox3_MouseUp(object sender, MouseEventArgs e)
{
    moving = false;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// MouseMove事件
private void pictureBox3_MouseMove(object sender, MouseEventArgs e)
{
    if (moving &amp;&amp; usePen)
    {
        // 创建画布功能
        Graphics g = pictureBox3.CreateGraphics();

        // 画图前必须要先创建画笔
        // 构造函数参数是要设置的 画笔颜色
        Pen pen = new Pen(curColor);
        g.DrawEllipse(pen,e.X,e.Y,2,2);
    }
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>对于<code>清空画布</code>按钮，将背景填充为白色即可</li>
</ul>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// "清空画布"按钮
private void button2_Click(object sender, EventArgs e)
{
    // 清空画布，填充白色
    pictureBox3.CreateGraphics().Clear(Color.White);
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>效果如下<img src="/2024/01/13/shang-wei-ji/%E7%94%BB%E5%9B%BE%E8%BD%AF%E4%BB%B6-1705156191296-20.gif" alt="画图软件"></li>
</ul>
<h3 id="2-8、Chart图表控件"><a href="#2-8、Chart图表控件" class="headerlink" title="2.8、Chart图表控件"></a>2.8、Chart图表控件</h3><h4 id="2-8-1-界面布局"><a href="#2-8-1-界面布局" class="headerlink" title="2.8.1 界面布局"></a>2.8.1 界面布局</h4><ul>
<li><code>Tablelayout</code>容器控件</li>
<li>每个单元格默认放置一个控件</li>
<li>更好地规划界面</li>
</ul>
<h4 id="2-8-2-图表界面简介"><a href="#2-8-2-图表界面简介" class="headerlink" title="2.8.2 图表界面简介"></a>2.8.2 图表界面简介</h4><ul>
<li><code>Chart</code>控件</li>
<li>关键属性的配置，如标题、坐标系、图例</li>
</ul>
<h4 id="2-8-3-例程-–-图像绘制"><a href="#2-8-3-例程-–-图像绘制" class="headerlink" title="2.8.3 例程 – 图像绘制"></a>2.8.3 例程 – 图像绘制</h4><ul>
<li>具体代码文件见<code>D:\Program Files\Microsoft Visual Studio\projects\start\chart</code></li>
</ul>
<h5 id="2-8-3-1-界面布局"><a href="#2-8-3-1-界面布局" class="headerlink" title="2.8.3.1 界面布局"></a>2.8.3.1 界面布局</h5><ul>
<li>在Form内，任意放置容器控件<code>TableLayoutPanel</code></li>
<li>修改属性<code>Dock</code>，填充方式，此处选用<code>Fill</code>，如下图所示<ul>
<li><img src="image-20231028175453329-1705156191296-21.png" alt="" style="zoom: 25%;"></li>
</ul>
</li>
</ul>
<h5 id="2-8-3-2-插入图形界面"><a href="#2-8-3-2-插入图形界面" class="headerlink" title="2.8.3.2 插入图形界面"></a>2.8.3.2 插入图形界面</h5><ul>
<li>在<code>TableLayoutPanel</code>任一单元格内放置<code>Chart</code>图形控件</li>
<li>同样修改填充属性<code>Dock</code>，全填充<code>Fill</code>，效果如图<ul>
<li><img src="image-20231028180056717-1705156191296-22.png" alt="" style="zoom: 25%;"></li>
</ul>
</li>
</ul>
<h6 id="2-8-3-2-1-图表类属性-Titels"><a href="#2-8-3-2-1-图表类属性-Titels" class="headerlink" title="2.8.3.2.1 图表类属性-Titels"></a>2.8.3.2.1 图表类属性-Titels</h6><ul>
<li><p>点击<code>...</code>打开<code>Titles</code>集合编辑器</p>
<ul>
<li><img src="image-20231028181107970-1705156191296-23.png" alt="" style="zoom:25%;"></li>
</ul>
</li>
<li><p>添加成员（可添加多个，即显示出来的图像会有相应个数的标题）</p>
<ul>
<li>成员属性<code>Text</code>：设置标题名称</li>
<li>成员属性<code>ToolTip</code>：设置提示消息，当用户鼠标放置在图形标题名称上时</li>
</ul>
</li>
</ul>
<h6 id="2-8-3-2-2-图标类属性-Series"><a href="#2-8-3-2-2-图标类属性-Series" class="headerlink" title="2.8.3.2.2 图标类属性-Series"></a>2.8.3.2.2 图标类属性-Series</h6><ul>
<li><p>可设置图像类型，如条形图、曲线图、扇形图</p>
</li>
<li><p>同样点击<code>...</code>打开<code>Series</code>集合编辑器</p>
<ul>
<li><img src="image-20231028182104785-1705156191296-24.png" alt="" style="zoom: 25%;"></li>
</ul>
</li>
<li><p>添加成员（每添加一个，显示图形上就会产生一个新的图例）</p>
<ul>
<li>成员属性<code>ChartType</code>：设置图像类型，如：<code>Column</code>、<code>Spline</code>、<code>Pie</code>等</li>
</ul>
</li>
</ul>
<h6 id="2-8-3-2-3-图标类属性-Legends"><a href="#2-8-3-2-3-图标类属性-Legends" class="headerlink" title="2.8.3.2.3 图标类属性-Legends"></a>2.8.3.2.3 图标类属性-Legends</h6><h5 id="2-8-3-3-数据传入"><a href="#2-8-3-3-数据传入" class="headerlink" title="2.8.3.3 数据传入"></a>2.8.3.3 数据传入</h5><ul>
<li>主要函数<code>chart1.Series[0].Points.Add(数据序列);</code></li>
</ul>
<h6 id="2-8-3-3-1-Form窗体Load事件"><a href="#2-8-3-3-1-Form窗体Load事件" class="headerlink" title="2.8.3.3.1 Form窗体Load事件"></a>2.8.3.3.1 Form窗体Load事件</h6><ul>
<li><p>使用<code>Form</code>窗体<code>Load</code>事件（窗体加载完成时，就绘制好图线）</p>
</li>
<li><p>双击<code>Load</code>事件，在<code>Form1_Load</code>方法中随机产生10个数据，窗体加载完成就绘制出完整图形</p>
</li>
</ul>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">private void Form1_Load(object sender, EventArgs e)
{
	Random rnd = new Random();
    for (int i = 0; i &lt; 10; i++)
    {
        //Random rnd = new Random();

        // 给图表传入数据
        chart1.Series[0].Points.Add(rnd.Next(0, 101));
    }
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h6 id="2-8-3-3-2-Timer组件"><a href="#2-8-3-3-2-Timer组件" class="headerlink" title="2.8.3.3.2 Timer组件"></a>2.8.3.3.2 Timer组件</h6><ul>
<li><p>行为属性<code>Enable</code>：启动<code>timer</code>计时，必须设置为<code>True</code>才会启动</p>
</li>
<li><p>行为属性<code>Interval</code>：时间间隔，单位ms，此例设置为500</p>
</li>
<li><p>双击<code>Timer</code>组件，<code>timer1_Tick</code>中每隔500ms产生一个随机数，并绘制到图形上</p>
</li>
</ul>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">private void timer1_Tick(object sender, EventArgs e)
{
    /*
    // 若只显示最新的10个点
    if (chart1.Series[0].Points.Count() == 10)
    {
        // 当存在10个数据时，移除第一个点
        chart1.Series[0].Points.RemoveAt(0);
    }
    */
    
    Random rnd = new Random();
    chart1.Series[0].Points.Add(rnd.Next(0, 101));
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h6 id="2-8-3-3-3-数据点取值可视化"><a href="#2-8-3-3-3-数据点取值可视化" class="headerlink" title="2.8.3.3.3 数据点取值可视化"></a>2.8.3.3.3 数据点取值可视化</h6><ul>
<li><p>在<code>Timer</code>组件基础上进行代码的修改</p>
</li>
<li><p>首先引入<code>using System.Windows.Forms.DataVisualization.Charting; </code></p>
</li>
<li><p>修改代码如下</p>
</li>
</ul>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">private void timer1_Tick(object sender, EventArgs e)
{
    // 若只显示最新的10个点
    if (chart1.Series[0].Points.Count() == 10)
    {
        // 当存在10个数据时，移除第一个点
        chart1.Series[0].Points.RemoveAt(0);
    }

    Random rnd = new Random();
    int curnum = rnd.Next(0, 101);
    
    // 创建数据点对象
    DataPoint dp1 = new DataPoint();
    // 通过double[] 为数据点传入y值
    dp1.YValues = new double[] { curnum };
    // 定义数据点标签
    dp1.Label = curnum.ToString();

    chart1.Series[0].Points.Add(dp1);
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h5 id="2-8-3-4-同数据-多图展示"><a href="#2-8-3-4-同数据-多图展示" class="headerlink" title="2.8.3.4 同数据-多图展示"></a>2.8.3.4 同数据-多图展示</h5><ul>
<li>在6.3.3.3代码基础上修改，通过for循环同时绘制4个图表</li>
</ul>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">private void timer1_Tick(object sender, EventArgs e)
{
    for (int i = 1;i &lt;= 4;i++)
    {
        // 在tableLayoutPanel1中找到图表控件，并取返回的同名子控件（find参数要设置为true）数组的第一个，转换为Chart类型
        Chart myChart = tableLayoutPanel1.Controls.Find("chart" + i.ToString(), true)[0] as Chart;
        
        // 若只显示最新的10个点
        if (myChart.Series[0].Points.Count() == 10)
        {
            // 当存在10个数据时，移除第一个点
            myChart.Series[0].Points.RemoveAt(0);
        }


        Random rnd = new Random();
        int curnum = rnd.Next(0, 11);
        DataPoint dp1 = new DataPoint();
        dp1.YValues = new double[] { curnum };
    
        dp1.Label = curnum.ToString();

        myChart.Series[0].Points.Add(dp1);
    }
    
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>效果如下<img src="/2024/01/13/shang-wei-ji/chart%E5%9B%BE%E8%A1%A8-1705156191296-25.gif" alt="chart图表"></li>
</ul>
<h3 id="2-9-右键菜单及打开文件对话框"><a href="#2-9-右键菜单及打开文件对话框" class="headerlink" title="2.9 右键菜单及打开文件对话框"></a>2.9 右键菜单及打开文件对话框</h3><h4 id="2-9-1-右键菜单"><a href="#2-9-1-右键菜单" class="headerlink" title="2.9.1 右键菜单"></a>2.9.1 右键菜单</h4><ul>
<li>使用控件<code>ContexMenuStrip</code>，设置好菜单选项</li>
<li><code>Form窗体、PictureBox等控件</code>，有个<code>ContextMenuStrip</code>行为属性，可在控件内启用相应的右键菜单功能</li>
<li>设置好的<strong>每一个菜单选项，都是一个子控件</strong>，拥有自己的属性方法及触发事件</li>
</ul>
<h4 id="2-9-2-打开文件对话框"><a href="#2-9-2-打开文件对话框" class="headerlink" title="2.9.2 打开文件对话框"></a>2.9.2 打开文件对话框</h4><ul>
<li>使用控件<code>openFileDialog</code><ul>
<li><code>openFileDialog.Title</code>属性，设置对话框<strong>标题</strong></li>
<li><code>openFileDialog.Filter</code>属性，设置文件<strong>类型过滤</strong></li>
<li><code>openFileDialog.InitialDirectory</code>属性，设置文件对话框<strong>打开初始路径</strong></li>
<li><code>openFileDialog.ShowDialog()</code>方法，<strong>打开文件对话框</strong></li>
<li><code>openFileDialog.FileName</code>属性，返回打开文件的<strong>绝对路径</strong></li>
</ul>
</li>
</ul>
<h4 id="2-9-3-例程-–-右键菜单更换图片"><a href="#2-9-3-例程-–-右键菜单更换图片" class="headerlink" title="2.9.3 例程 – 右键菜单更换图片"></a>2.9.3 例程 – 右键菜单更换图片</h4><ul>
<li><p><code>具体代码文件见D:\Program Files\Microsoft Visual Studio\projects\start\RightMenu</code></p>
</li>
<li><p>界面设计如下</p>
<ul>
<li><img src="image-20231101190346048-1705156191296-26.png" alt="" style="zoom: 50%;"></li>
</ul>
</li>
<li><p>首先设置右键菜单选项，并在<code>Form</code>窗体属性中设置<code>ContextMenuStrip</code>为定义好的<code>右键菜单控件名</code></p>
</li>
<li><p>对于右键菜单第一个选项<code>你干嘛</code>，单击该选项，并创建<code>click</code>事件</p>
</li>
</ul>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 当"你干嘛"选项被选中后，触发该click事件，通过messageBox打印相应语句
private void 你干嘛ToolStripMenuItem_Click(object sender, EventArgs e)
{
    MessageBox.Show("你干嘛小黑子");
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>对于第二个选项<code>换背景</code>，同样创建<code>click</code>事件</li>
</ul>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">private void 换背景ToolStripMenuItem_Click(object sender, EventArgs e)
{
    // 设置文件选框标题
    openFileDialog1.Title = "请选择一张图片";

    // 文件类型过滤
    // 配置格式：文件说明|文件扩展名
    // 同种类型文件，用分号隔开
    openFileDialog1.Filter = "图片文件(*.bmp;*.jpg;*.png;*.jepg;*.gif)|*.bmp;*.jpg;*.png;*.jepg;*.gif|任意类型(*.*)|*.*";

    // 选框默认打开路径为前一次文件位置
    // 可对选框打开文件位置进行默认设置

    // openFileDialog1.InitialDirectory = Application.StartupPath;

    // 当文件成功被选择
    if(openFileDialog1.ShowDialog() == DialogResult.OK)
    {
        pictureBox1.SizeMode = PictureBoxSizeMode.StretchImage;

        // 将选择的文件绝对路径传给pictureBox进行展示
        pictureBox1.Image = Image.FromFile(openFileDialog1.FileName);
    }
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>效果展示<img src="右键菜单更换图片-1705156191296-27.gif" alt="" style="zoom: 33%;"></li>
</ul>
<h3 id="2-10-（本节因没有本地用户和组，无法进行操作学习！！！！）"><a href="#2-10-（本节因没有本地用户和组，无法进行操作学习！！！！）" class="headerlink" title="2.10 （本节因没有本地用户和组，无法进行操作学习！！！！）"></a>2.10 （本节因没有本地用户和组，无法进行操作学习！！！！）</h3><h4 id="2-10-1-下拉列表"><a href="#2-10-1-下拉列表" class="headerlink" title="2.10.1 下拉列表"></a>2.10.1 下拉列表</h4><ul>
<li><code>ComboBox</code>控件，下拉列表<ul>
<li><code>ComboBox.DropDownStyle</code>属性，设置下拉列表样式，可用取值分别为</li>
<li><code>ComboBox.Items.Add()</code>方法，添加项</li>
<li><code>ComboBox.Items.Contains()</code>，判断当前下拉框是否包含指定项</li>
<li><code>ComboBox.Text</code>属性，获取当前选中项文本</li>
<li><code>ComboBox.Items.Remove()</code>方法，删除指定项</li>
</ul>
</li>
</ul>
<h4 id="2-10-2"><a href="#2-10-2" class="headerlink" title="2.10.2"></a>2.10.2</h4><ul>
<li><code>directoryEntry</code>控件</li>
</ul>
<h3 id="2-11-系统语音功能及日期时间"><a href="#2-11-系统语音功能及日期时间" class="headerlink" title="2.11 系统语音功能及日期时间"></a>2.11 系统语音功能及日期时间</h3><h4 id="2-11-1-语音功能"><a href="#2-11-1-语音功能" class="headerlink" title="2.11.1 语音功能"></a>2.11.1 语音功能</h4><ul>
<li>本质上是调用系统的<code>tts</code>功能（将<strong>文本转为语音</strong>的功能，<code>tts</code>在<code>com</code>组件中有）</li>
</ul>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 核心代码
Type type = Type.GetTypeFromProgID("SAPI.SpVoice");
dynamic spVoice = Activator.CreateInstance(type);
spVoice.Speak("Text To Speech 语音朗读文本技术");<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>



<h4 id="2-11-2-日期时间"><a href="#2-11-2-日期时间" class="headerlink" title="2.11.2 日期时间"></a>2.11.2 日期时间</h4><ul>
<li><p><code>dateTimePicker</code>控件</p>
<ul>
<li><p><code>Format</code>属性，设置日期格式</p>
</li>
<li><p><code>CustomFormat</code>属性，当<code>Format</code>设置为<code>Custom</code>自定义格式时，可自行设日期时间格式，如</p>
</li>
</ul>
</li>
</ul>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 设置为以下格式
yyyy年MM月dd日 HH:mm:ss<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>



<h4 id="2-11-3-例程-–-个性语音闹钟"><a href="#2-11-3-例程-–-个性语音闹钟" class="headerlink" title="2.11.3 例程 – 个性语音闹钟"></a>2.11.3 例程 – 个性语音闹钟</h4><ul>
<li><p><code>具体代码文件见D:\Program Files\Microsoft Visual Studio\projects\start\Voice</code></p>
</li>
<li><p>搭建界面如下</p>
<ul>
<li><img src="image-20231102112708004-1705156191296-28.png" alt="" style="zoom: 50%;"></li>
</ul>
</li>
<li><p>当按下<code>添加闹钟</code>按钮后，将<code>dateTimePicker</code>的日期时间及<code>textBox</code>中的自定义事件分别存储到<code>listBox</code>中</p>
</li>
</ul>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">private void button1_Click(object sender, EventArgs e)
{
    // 必须使用Value属性，不能使用Text，不然没有反应！！！
    listBox1.Items.Add(dateTimePicker1.Value);

    listBox2.Items.Add(textBox1.Text);
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li><p>接着，在界面内添加一个<code>timer</code>时钟控件，设置默认状态<code>enable</code>为启动</p>
</li>
<li><p>程序开始运行，<code>timerTick</code>事件，不断读取<code>listBox1</code>中的时间，当其与当前系统时间一致时，启动语音模块，并朗读事件，之后删除该闹钟事件</p>
</li>
</ul>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">private void timer1_Tick(object sender, EventArgs e)
{
    // 遍历listBox1中的时间
    for(int i = 0; i &lt; listBox1.Items.Count; i++)
    {
        // 找到预设闹钟时间
        if (listBox1.Items[i].ToString() == DateTime.Now.ToString())
        {
            // 执行语音
            // 找到语音模块
            Type t = Type.GetTypeFromProgID("SAPI.SpVoice");

            // 创建语音实例
            // dynamic 动态进行类型转换，可规避语法错误
            dynamic mySp = Activator.CreateInstance(t);

            // 语音外放
            mySp.Speak(listBox2.Items[i].ToString());

            // 删除闹钟事件
            listBox1.Items.RemoveAt(i);
            listBox2.Items.RemoveAt(i);

            return;

        }
    }
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li><p>效果如下</p>
<ul>
<li><video src="./video/个性语音闹钟.mp4"></video></li>
</ul>
</li>
</ul>
<h3 id="2-12-列表视图"><a href="#2-12-列表视图" class="headerlink" title="2.12 列表视图"></a>2.12 列表视图</h3><h4 id="2-12-1-comboBox、listBox、listView的区别"><a href="#2-12-1-comboBox、listBox、listView的区别" class="headerlink" title="2.12.1 comboBox、listBox、listView的区别"></a>2.12.1 comboBox、listBox、listView的区别</h4><ul>
<li><code>comboBox</code>控件：下拉列表，有下拉、滚动条、下拉+输入三种模式</li>
<li><code>listBox</code>控件：单行项目记录</li>
<li><code>listView</code>控件：简单的项目行，表格的感觉</li>
</ul>
<h4 id="2-12-2-配置listView"><a href="#2-12-2-配置listView" class="headerlink" title="2.12.2 配置listView"></a>2.12.2 配置listView</h4><ul>
<li><code>Columns</code>属性：设置列标题<ul>
<li>添加成员后通过<code>Text</code>设置<strong>列标题</strong>名</li>
<li>同时通过<code>TextAlign</code>设置居中状态</li>
</ul>
</li>
<li><code>view</code>属性：调整视图模式<ul>
<li><code>details</code>可在构建界面时展示出列表情况，如列标题</li>
</ul>
</li>
<li><code>Items</code>属性：<ul>
<li><code>Text</code>设置当前行第一个单元格名称（<strong>行标题</strong>）</li>
<li><code>SubItems</code>设置第二个及其之后单元格</li>
<li><code>ImageIndex</code>属性，配置图表，使用<code>SmallImageList</code>中的图片<ul>
<li>使用前先要将<code>imageList</code>控件拖到<code>Form</code>窗体中，并通过<code>Images</code>属性导入图片</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="2-12-3-例程1-–-表格记录软件"><a href="#2-12-3-例程1-–-表格记录软件" class="headerlink" title="2.12.3 例程1 – 表格记录软件"></a>2.12.3 例程1 – 表格记录软件</h4><ul>
<li><p><code>具体代码文件见D:\Program Files\Microsoft Visual Studio\projects\start\listView</code></p>
</li>
<li><p>界面搭建如下</p>
<ul>
<li><img src="image-20231102185842982-1705156191296-29.png" alt="" style="zoom: 50%;"></li>
</ul>
</li>
<li><p><code>imageList</code>要与<code>ListView</code>关联起来</p>
</li>
<li><p>首先是<code>添加</code>按键，在<code>textBox</code>中输入文本后，添加进表格</p>
</li>
</ul>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// "添加"按键事件
private void button1_Click(object sender, EventArgs e)
{
    // 添加一行Item
    // new ListViewItem()的参数分别为每一单元格的Text数组，和ImageList索引
    // listView1.Items.Add(new ListViewItem(new string[] {"1","2","3","4"}, 2));

    // 输入添加
    listView1.Items.Add(new ListViewItem(new string[] { textBox1.Text, textBox2.Text, textBox3.Text, textBox4.Text }, 2));

    // 鼠标单击选中后，修改已有单元格

}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>对于<code>修改</code>按键，鼠标选中某一行后，将改行文本显示在<code>textBox</code>中，修改文本过后，更新表格</li>
</ul>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 外部变量，选中对象索引
int ind = -1;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 鼠标选中任意行显示到textBox
private void listView1_SelectedIndexChanged(object sender, EventArgs e)
{
    // 当选中对象不为空
    if (listView1.SelectedItems.Count != 0)
    {
        // 获取最新选择对象在listview1中的索引
        ind = listView1.SelectedIndices[0];

        // 将当前listview中被点击的行名称显示到textBox
        textBox1.Text = listView1.Items[ind].SubItems[0].Text;
        textBox2.Text = listView1.Items[ind].SubItems[1].Text;
        textBox3.Text = listView1.Items[ind].SubItems[2].Text;
        textBox4.Text = listView1.Items[ind].SubItems[3].Text;
    }
    
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 修改按钮事件
private void button2_Click(object sender, EventArgs e)
{
    // 修改
    if (listView1.SelectedItems.Count != 0)
    {
        // 获取最新选择对象在listview1中的索引
        ind = listView1.SelectedIndices[0];

        // 修改选中行表格数据
        listView1.Items[ind].SubItems[0].Text = textBox1.Text;
        listView1.Items[ind].SubItems[1].Text = textBox2.Text;
        listView1.Items[ind].SubItems[2].Text = textBox3.Text;
        listView1.Items[ind].SubItems[3].Text = textBox4.Text;
    }
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>对于<code>删除</code>按钮，当某行被选中时，可被删除</li>
</ul>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">private void button3_Click(object sender, EventArgs e)
{
    // 删除
    if(ind != -1)
    {
        listView1.Items.RemoveAt(ind);
    }
    
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li><p>效果如下</p>
<ul>
<li><video src="./video/表格记录软件.mp4"></video></li>
</ul>
</li>
</ul>
<h4 id="2-12-4-例程2-–-图片上传软件"><a href="#2-12-4-例程2-–-图片上传软件" class="headerlink" title="2.12.4  例程2 – 图片上传软件"></a>2.12.4  例程2 – 图片上传软件</h4><ul>
<li><p><code>具体代码文件见D:\Program Files\Microsoft Visual Studio\projects\start\listView</code></p>
</li>
<li><p>界面搭建如下</p>
<ul>
<li><img src="image-20231102191339489-1705156191296-30.png" alt="" style="zoom: 50%;"></li>
</ul>
</li>
<li><p><code>listview</code>要与<code>imagelist</code>关联起来</p>
</li>
<li><p>首先是<code>浏览图片</code>按键，按下后打开文件对话框，配置文件格式，当用户选中之后将其绝对路径显示到<code>图片路径</code></p>
</li>
</ul>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 浏览图片按键事件
private void button1_Click(object sender, EventArgs e)
{
    // 过滤图片类型
    openFileDialog1.Filter = "图片文件(*.png;*.jpg;*.gif)|*.png;*.jpg;*.gif";
    if (openFileDialog1.ShowDialog() == DialogResult.OK)
    {
        // 将文件绝对路径赋给textBox1
        textBox1.Text = openFileDialog1.FileName;
    }
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>对于<code>立即上传</code>按键，按下后，首先根据<code>textBox1</code>中的图像路径，将图片按指定方式命名并存到相应文件夹下；同时，在<code>textBox2</code>中自定义名称，之后将该图片展示到<code>listView</code>中</li>
</ul>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 立即上传按钮事件
private void button2_Click(object sender, EventArgs e)
{
    // 从路径获取image对象
    Image demo = Image.FromFile(textBox1.Text);
    
    // 以时间格式命名
    demo.Save(Application.StartupPath + @"\img\" + DateTime.Now.ToString("yyyyMMddHHmmss") + ".jpg");

    // 首先的导入imagelist
    imageList1.Images.Add(demo);

    // 将imagelist与listview进行关联
    listView1.LargeImageList = imageList1;

    // 从imagelist获取最新的图片，并命名为textBox2，添加到listview
    listView1.Items.Add(textBox2.Text, imageList1.Images.Count - 1);
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>对于<code>修改名称</code>按键，首先当鼠标选中任意图片后，将其在<code>listview</code>中的名称显示到<code>textBox2</code>中；之后对该名称进行修改，按下<code>修改名称</code>按键后，更改<code>listview</code>中对应图片名称</li>
</ul>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 当前选中图片索引
int ind = -1;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 鼠标任意选中图片
private void listView1_SelectedIndexChanged(object sender, EventArgs e)
{
    if (listView1.SelectedItems.Count != 0)
    {
        // 获取最新选择对象在listview1中的索引
        ind = listView1.SelectedIndices[0];

        // 将当前listview中被点击的图片名称显示到textBox2
        textBox2.Text = listView1.Items[ind].Text;
    }
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 修改对应名称
private void button3_Click(object sender, EventArgs e)
{
    if (ind != -1)
    {
        listView1.Items[ind].Text = textBox2.Text;
    }
    else
    {
        MessageBox.Show("未选中图片");
    }
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>对于<code>删除图片</code>按钮事件</li>
</ul>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">private void button4_Click(object sender, EventArgs e)
{
    if(ind != -1)
    {
        // 从llistview中删除鼠标选中图片
        listView1.Items.RemoveAt(ind);
    }
    else
    {
        MessageBox.Show("未选中图片");
    }
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li><p>效果如下</p>
<ul>
<li><video src="./video/图片上传软件.mp4"></video></li>
</ul>
</li>
</ul>
<h3 id="2-13-状态栏及富文本框"><a href="#2-13-状态栏及富文本框" class="headerlink" title="2.13 状态栏及富文本框"></a>2.13 状态栏及富文本框</h3><ul>
<li><code>menuStrip</code>控件，搭建界面菜单</li>
<li><code>fontDialog</code>控件，字体对话框</li>
<li><code>colorDialog</code>控件，颜色对话框</li>
<li></li>
</ul>
<h4 id="2-13-1-状态栏"><a href="#2-13-1-状态栏" class="headerlink" title="2.13.1 状态栏"></a>2.13.1 状态栏</h4><ul>
<li><code>statusStrip</code>控件</li>
</ul>
<h4 id="2-13-2-富文本框"><a href="#2-13-2-富文本框" class="headerlink" title="2.13.2 富文本框"></a>2.13.2 富文本框</h4><ul>
<li><code>richTextBox</code>控件</li>
</ul>
<h4 id="2-13-3-例程-–-个性化记事本"><a href="#2-13-3-例程-–-个性化记事本" class="headerlink" title="2.13.3 例程 – 个性化记事本"></a>2.13.3 例程 – 个性化记事本</h4><ul>
<li>==有bug，不知道怎么解决！！！==</li>
</ul>
<h2 id="三、开发例子-–-B站刘金玉视频总结"><a href="#三、开发例子-–-B站刘金玉视频总结" class="headerlink" title="三、开发例子 – B站刘金玉视频总结"></a>三、开发例子 – B站刘金玉视频总结</h2><h3 id="3-1-简易谷歌浏览器开发"><a href="#3-1-简易谷歌浏览器开发" class="headerlink" title="3.1 简易谷歌浏览器开发"></a>3.1 简易谷歌浏览器开发</h3><h4 id="3-1-1-主要内容"><a href="#3-1-1-主要内容" class="headerlink" title="3.1.1 主要内容"></a>3.1.1 主要内容</h4><ul>
<li><p><code>WebBrowser</code>控件，默认调用IE浏览器作为内核，但该内核已经久远，会报错</p>
</li>
<li><p><code>cefsharp</code>，第三方控件，通过<code>管理NuGet程序包</code>下载，使用Chrome内核</p>
<ul>
<li>使用时，需要引入命名空间</li>
</ul>
</li>
</ul>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">using CefSharp;
using CefSharp.WinForms;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>




<h4 id="3-1-2-实现过程"><a href="#3-1-2-实现过程" class="headerlink" title="3.1.2 实现过程"></a>3.1.2 实现过程</h4><ul>
<li><p>具体代码见<code>D:\Program Files\Microsoft Visual Studio\projects\start\Brower</code></p>
</li>
<li><p>搭建界面布局如下</p>
<ul>
<li><img src="image-20231109162733234-1705156191296-31.png" alt="" style="zoom: 50%;"></li>
</ul>
</li>
<li><p>首先在外部声明全局变量</p>
</li>
</ul>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">ChromiumWebBrowser myChrome;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<ul>
<li>不拖动<code>CefSharp</code>控件，通过代码调用</li>
</ul>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 通过窗体加载事件配置浏览器
private void Form1_Load(object sender, EventArgs e)
{
    // 载入谷歌浏览器默认配置，并初始化内核
    Cef.Initialize(new CefSettings());
    
    // 设置浏览器默认打开地址
    myChrome = new ChromiumWebBrowser("https://www.bilibili.com");
    
    // 将网页显示到panel中
    panel1.Controls.Add(myChrome);
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>在<code>textBox1</code>中输入网址后，按回车进行调换</li>
</ul>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 通过textBox按键抬起事件
private void textBox1_KeyUp(object sender, KeyEventArgs e)
{
    // 当按下回车
    if(e.KeyCode == Keys.Enter)
    {
        // webBrowser1.Url = new Uri(textBox1.Text);
        
        // 将textBox1中文本转为字符串，传给Chrome进行网页跳转
        myChrome.LoadUrl(textBox1.Text.ToString());
    }
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>实现浏览器的前进、后退、刷新</li>
</ul>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 前进
private void button1_Click(object sender, EventArgs e)
{
    myChrome.Forward();
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 后退
private void button2_Click(object sender, EventArgs e)
{
    myChrome.Back();
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 刷新
private void button3_Click(object sender, EventArgs e)
{
    myChrome.Reload();
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 查看源代码    调用时一直转圈，没有显示出来，程序还卡了
private void button4_Click(object sender, EventArgs e)
{
    richTextBox1.Text = myChrome.GetSourceAsync().Result;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h3 id="3-2-超市商品分类树"><a href="#3-2-超市商品分类树" class="headerlink" title="3.2 超市商品分类树"></a>3.2 超市商品分类树</h3><h4 id="3-2-1-主要内容"><a href="#3-2-1-主要内容" class="headerlink" title="3.2.1 主要内容"></a>3.2.1 主要内容</h4><ul>
<li><code>treeView</code>树形控件，根节点，子节点</li>
</ul>
<h4 id="3-2-2-实现过程"><a href="#3-2-2-实现过程" class="headerlink" title="3.2.2 实现过程"></a>3.2.2 实现过程</h4><ul>
<li><p>具体代码见<code>D:\Program Files\Microsoft Visual Studio\projects\start\TreeView</code></p>
</li>
<li><p>搭建界面如下</p>
<ul>
<li><img src="image-20231109182148300-1705156191296-32.png" alt="" style="zoom: 50%;"></li>
</ul>
</li>
<li><p><code>全部展开</code>功能</p>
</li>
</ul>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">private void button1_Click(object sender, EventArgs e)
{
    // 全部展开，调用ExpandAll()方法
    treeView1.ExpandAll();
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li><code>全部闭合</code>功能</li>
</ul>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">private void button2_Click(object sender, EventArgs e)
{
    // 全部闭合，调用CollapseAll()方法
    treeView1.CollapseAll();
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li><code>添加根节点</code>功能</li>
</ul>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">private void button3_Click(object sender, EventArgs e)
{
    // 将textBox中的文本添加到根节点
    treeView1.Nodes.Add(textBox1.Text);
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li><code>添加至当前分类</code>功能</li>
</ul>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">private void button4_Click(object sender, EventArgs e)
{
    // 在被选中的根节点下添加子节点
    treeView1.SelectedNode.Nodes.Add(textBox1.Text);
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li><p><code>右键删除</code></p>
<ul>
<li>使用<code>contextMenuStrip</code>控件，添加删除选项，并绑定<code>treeview</code></li>
</ul>
</li>
</ul>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">private void 删除选中项ToolStripMenuItem_Click(object sender, EventArgs e)
{
    // 获取当前选中项（根节点或子节点）
    TreeNode select = treeView1.SelectedNode;
    
    // 删除该节点（根节点或子节点）
    treeView1.Nodes.Remove(select);
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li><code>网页链接</code></li>
</ul>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">private void linkLabel1_LinkClicked(object sender, LinkLabelLinkClickedEventArgs e)
{
    System.Diagnostics.Process.Start("http://bcczcs.com");
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>



<h3 id="3-3-红绿灯交通模拟-–-调用线程"><a href="#3-3-红绿灯交通模拟-–-调用线程" class="headerlink" title="3.3 红绿灯交通模拟 – 调用线程"></a>3.3 红绿灯交通模拟 – 调用线程</h3><h4 id="3-3-1-主要内容"><a href="#3-3-1-主要内容" class="headerlink" title="3.3.1 主要内容"></a>3.3.1 主要内容</h4><ul>
<li><code>backgroundWorker</code>后台线程</li>
</ul>
<h4 id="3-3-2-实现过程"><a href="#3-3-2-实现过程" class="headerlink" title="3.3.2 实现过程"></a>3.3.2 实现过程</h4><ul>
<li><p>具体代码见<code>D:\Program Files\Microsoft Visual Studio\projects\start\Traffic</code></p>
</li>
<li><p>搭建界面</p>
<ul>
<li><img src="image-20231109194202863-1705156191296-33.png" alt="" style="zoom: 50%;"></li>
</ul>
</li>
<li><p>引入全局变量</p>
</li>
</ul>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">int count = 10;
Graphics g;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<ul>
<li>在面板内绘制红绿灯</li>
</ul>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 窗体自带一个onpaint事件用来重绘winform界面
// 需要对该事件进行重写，以达到红绿灯显示的连续性，解决灯消失不显示的情况
protected override void OnPaint(PaintEventArgs e)
{
    base.OnPaint(e);
    // 在面板内绘制实心圆
    g = panel1.CreateGraphics();
    // g.DrawEllipse(new Pen(Color.Red), 0, 0, 40, 40);

    // 创建笔刷
    Brush brush = new SolidBrush(Color.Red);
    
    // 绘制红绿灯
    g.FillEllipse(brush, 0, 0, 40, 40);
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>按下<code>开始</code></li>
</ul>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">private void button1_Click(object sender, EventArgs e)
{
    // 先判断后台线程是否已经被开启，避免多次点击报错
    if (!backgroundWorker1.IsBusy)
    {
        // 开启后台线程
        backgroundWorker1.RunWorkerAsync();
    }
    
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 将耗时的复杂的计算或死循环放到后台进行，避免卡顿
private void backgroundWorker1_DoWork(object sender, DoWorkEventArgs e)
{
    // 判断count取值
    while (true)
    {
        if (count &lt; 0)
        {
            break;
        }
        else if (count &lt;= 7 &amp;&amp; count &gt; 4)
        {
            Brush brush = new SolidBrush(Color.Green);
            g.FillEllipse(brush, 0, 0, 40, 40);
        }
        else if (count &lt;= 4)
        {
            Brush brush = new SolidBrush(Color.Yellow);
            g.FillEllipse(brush, 0, 0, 40, 40);
        }

        // 本身后台线程是一个线程，而label2控件是在主线程里创建的，直接使用开线程了，使用Invoke解决
        // Invoke会一直网上进行查找，直到找到当前控件所在的线程，并对控件的值进行更新
        // new action()内启用一个委托，去解决跨线程
        Invoke(new Action(() =&gt; 
        {
            label2.Text = count.ToString();

            // 刷新界面，不刷新会卡死
            Update();

        }));

        // 另一种解决方法
        /*Invoke(new EventHandler(delegate
        {
            label2.Text = count.ToString();

            // 刷新界面，不刷新会卡死
            Update();
        }));*/
        
        // 暂停线程1秒
        System.Threading.Thread.Sleep(1000);

        count--;
    }
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>当窗体关闭时，关闭后台进程，避免报错</li>
</ul>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">private void Form1_FormClosing(object sender, FormClosingEventArgs e)
{
    // 当窗体关闭时，同时关闭后台线程，避免报错
    backgroundWorker1.CancelAsync();
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h3 id="3-4-屏幕滚动文字"><a href="#3-4-屏幕滚动文字" class="headerlink" title="3.4 屏幕滚动文字"></a>3.4 屏幕滚动文字</h3><h4 id="3-4-1主要内容"><a href="#3-4-1主要内容" class="headerlink" title="3.4.1主要内容"></a>3.4.1主要内容</h4><ul>
<li>通过使用<code>System.IO</code>命名空间下的<code>StreamWrite</code>类进行文件写入</li>
<li>使用<code>Fill.ReanAllText()</code>方法读取文件</li>
</ul>
<h4 id="3-4-2-实现过程"><a href="#3-4-2-实现过程" class="headerlink" title="3.4.2 实现过程"></a>3.4.2 实现过程</h4><ul>
<li><p>具体代码见<code>D:\Program Files\Microsoft Visual Studio\projects\start\Screen</code></p>
</li>
<li><p>界面搭建如下</p>
<ul>
<li><img src="image-20231109203744310-1705156191296-34.png" alt="" style="zoom: 50%;"></li>
</ul>
</li>
<li><p>首先设置从属关系</p>
</li>
</ul>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">private void Form1_Load(object sender, EventArgs e)
{
    // 将label1设置为label2的父窗体
    // 通过将label2的背景色设置为Transparent，跟随label1窗体背景颜色
    label2.Parent = label1;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>接着启用<code>timer</code>控件，让<code>label2</code>在<code>label1</code>中动起来</li>
</ul>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">private void timer1_Tick(object sender, EventArgs e)
{
    // 边界判断
    if (label2.Left &lt; -label2.Width)
    {
        label2.Left = label1.Width;
    }
    label2.Left -= 10;

}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>对于<code>预览</code>键，点击后，将<code>textBox</code>中输入的文本显示到<code>label2</code>上</li>
</ul>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">private void button1_Click(object sender, EventArgs e)
{
    label2.Text = textBox1.Text;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>对于<code>写入文件保存</code></li>
</ul>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">private void button2_Click(object sender, EventArgs e)
{
    // 通过System.IO中的streamwrite类来写入文件

    // 构造函数参数传入的是文件保存名称，默认路径在debug文件下
    // 该构造函数还有第二个参数，bool，是否追加
    StreamWriter sw = new StreamWriter("sw.txt");

    // 写入文件
    sw.Write(textBox1.Text);

    // 写入完成要进行关闭，关闭后才能看到保存的文本
    sw.Close();
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>对于<code>checkBox 从保存文件读入文本</code>，并将文本内容写入<code>label2</code></li>
</ul>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">private void checkBox1_CheckedChanged(object sender, EventArgs e)
{
    if(checkBox1.Checked)
    {
        label2.Text = File.ReadAllText("sw.txt");
    }
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h3 id="3-5-掩码规则验证及信息提示"><a href="#3-5-掩码规则验证及信息提示" class="headerlink" title="3.5 掩码规则验证及信息提示"></a>3.5 掩码规则验证及信息提示</h3><h4 id="3-5-1-主要内容"><a href="#3-5-1-主要内容" class="headerlink" title="3.5.1 主要内容"></a>3.5.1 主要内容</h4><ul>
<li><code>maskedTextBox</code>掩码控件<ul>
<li><code>mask</code>属性设置掩码格式</li>
<li><code>AsciOnly</code>属性设置是否开启格式验证，若不合格输入不了</li>
</ul>
</li>
<li><code>toolTip</code>提示控件</li>
</ul>
<h4 id="3-5-2-实现过程"><a href="#3-5-2-实现过程" class="headerlink" title="3.5.2 实现过程"></a>3.5.2 实现过程</h4><ul>
<li><p>具体代码见<code>D:\Program Files\Microsoft Visual Studio\projects\start\Mask</code></p>
</li>
<li><p>界面搭建如下</p>
<ul>
<li><img src="image-20231109221329348-1705156191297-35.png" alt="" style="zoom:50%;"></li>
</ul>
</li>
<li><p>按键切换掩码格式，采用同类型按钮事件</p>
</li>
</ul>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 同类型按钮事件
// 首先要有同类型控件
// 将同类型控件选择相同的事件
// 通过sender这个object，强制转为指定类型的控件
// 通过转化过来的控件，直接调用某一属性去进行区分
private void radioButton1_CheckedChanged(object sender, EventArgs e)
{
    RadioButton rdbt = (RadioButton)sender;
    if(rdbt.Text == "身份号码")
    {
        maskedTextBox1.Mask = "000000-00000000-000A";
    }
    else if(rdbt.Text == "电话号码")
    {
        maskedTextBox1.Mask = "000-0000-0000";
    }
    else if (rdbt.Text == "日期时间")
    {
        maskedTextBox1.Mask = "0000年90月90日 90时00分";
    }
    else if (rdbt.Text == "自动转为大写")
    {
        // 没有该类型掩码
        // 自定义掩码：0表示0-9的数字；A代表字母数字都可以；
        // &gt;&lt;表示转大小写；L只表示字母
 
        // 指定5位字母
        maskedTextBox1.Mask = "&gt;LLLLL";
    }
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>输入提示</li>
</ul>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">private void maskedTextBox1_MaskInputRejected(object sender, MaskInputRejectedEventArgs e)
{
    // 当输入不符合规则时提醒
 
    // 提醒输入将超设置长度
    if (maskedTextBox1.MaskFull)
    {
        // 设置提示标题
        toolTip1.ToolTipTitle = "啊giao提醒您：";
 
        // 设置提示内容，在相应控件位置显示
        // 鼠标必须在控件位置，否则可能失效
        toolTip1.Show("输入完成了", maskedTextBox1);
    }
 
    // 该条件与前一个情况一样，做例子
    else if(e.Position == maskedTextBox1.Mask.Length)
    {
        toolTip1.Show("已在最后一个位置", maskedTextBox1);
    }
 
    else
    {
        toolTip1.Show("输入不合法", maskedTextBox1);
    }
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>







<h2 id="四、一些有意思的操作"><a href="#四、一些有意思的操作" class="headerlink" title="四、一些有意思的操作"></a>四、一些有意思的操作</h2><h3 id="4-1-文件对话框"><a href="#4-1-文件对话框" class="headerlink" title="4.1 文件对话框"></a>4.1 文件对话框</h3><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">OpenFileDialog ofd = new OpenFileDialog();
ofd.Title = "请选择音乐文件";
ofd.InitialDirectory = @"C:\Users\echo\Desktop\Music";
ofd.Multiselect = true;
ofd.Filter = "音乐文件|*.wav|所有文件|*.*";
ofd.ShowDialog();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h3 id="4-2-音乐播放"><a href="#4-2-音乐播放" class="headerlink" title="4.2 音乐播放"></a>4.2 音乐播放</h3><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">SoundPlayer sp = new SoundPlayer();
sp.SoundLocation = "xxx";
sp.Play();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>









<h2 id="五、VS快捷键"><a href="#五、VS快捷键" class="headerlink" title="五、VS快捷键"></a>五、VS快捷键</h2><ul>
<li><code>Ctrl+鼠标左键点击函数名</code>：跳转该函数具体定义</li>
<li><code>Ctrl+}</code>：切换光标在代码块标识符<code>{}</code>的位置</li>
</ul>
<h2 id="六、TCP-IP通信"><a href="#六、TCP-IP通信" class="headerlink" title="六、TCP/IP通信"></a>六、TCP/IP通信</h2><ul>
<li><p>上位机是客户端，下位机是服务器，客户端发送命令，服务端做出响应</p>
</li>
<li><p>通过<code>TCP</code>传送接收数据时，必须先使用协议和网络地址信息初始化套接字，然后才能进行通信</p>
</li>
<li><p><code>TCP/IP</code>使用<strong>一个网络地址和一个服务端口号</strong>来标识唯一设备</p>
<ul>
<li>网络地址标识特定的网络目标</li>
<li>端口号标识该设备要连接的特定服务</li>
<li>网络地址和服务端口的组合称为<strong>终结点</strong><ul>
<li>终结点在<code>.NET</code>中由<code>EndPoint</code>类表示</li>
<li>对于<code>IP</code>地址类型，类为<code>IPEndPoint</code></li>
</ul>
</li>
</ul>
</li>
<li><p>使用<code>System.Net.Sockets</code>时，将网络终结点表示为<code>IPEndPoint</code>对象</p>
<ul>
<li><code>IPEndPoint</code>使用<code>IPAddress</code>及其端口号构造实例</li>
<li>在使用<code>Socket</code>发起对话前，在应用和远程目标之间创建数据通道</li>
</ul>
</li>
</ul>
<h3 id="6-1-进程"><a href="#6-1-进程" class="headerlink" title="6.1 进程"></a>6.1 进程</h3><ul>
<li><p>进程是操作系统中的一个<strong>执行实例</strong></p>
</li>
<li><p>进程是程序的一次执行过程，是一个<strong>程序</strong>与其<strong>关联数据</strong>以及<strong>系统资源</strong>的总称</p>
</li>
<li><p>它是计算机系统进行资源分配和调度的基本单位，可以看作是<strong>程序的运行实体</strong></p>
</li>
<li><p>打开软件</p>
</li>
</ul>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 打开edge浏览器，并跳转相应网页
Process.Start("msedge","https://www.baidu.com")

// 打开微信
Process.Start("weixin://")<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>打开文件</li>
</ul>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">ProcessStartInfo psi = new ProcessStartInfo("文件路径");
Pocess p = new Process();
p.StartInfo = psi;
p.Start();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>



<h3 id="6-2-线程"><a href="#6-2-线程" class="headerlink" title="6.2 线程"></a>6.2 线程</h3><ul>
<li>线程是进程内的一个独立执行流，是操作<strong>系统调度的基本单位</strong></li>
<li><strong>一个进程可以包含多个线程</strong>，它们共享进程的资源，但拥有各自的执行路径和局部变量</li>
<li>线程是轻量级的执行单元，相比于进程，线程的<strong>创建、销毁和切换成本更低</strong></li>
<li>程序<strong>任何动作的响应</strong>都是由线程完成的</li>
</ul>
<h4 id="6-2-1-主要函数"><a href="#6-2-1-主要函数" class="headerlink" title="6.2.1 主要函数"></a>6.2.1 主要函数</h4><ul>
<li>线程主要函数分别是<code>Start()</code>和<code>Abort()</code><ul>
<li><code>Start()</code>：告诉cpu线程已经准好了，可以随时被执行，但是具体执行时间由cpu决定</li>
<li><code>Abort()</code>：终止线程</li>
</ul>
</li>
<li>其余方法<ul>
<li><code>Thread.Sleep(1)</code>：静态方法，使线程停止一段时间</li>
</ul>
</li>
</ul>
<h4 id="6-2-2-关于线程的一些问题"><a href="#6-2-2-关于线程的一些问题" class="headerlink" title="6.2.2 关于线程的一些问题"></a>6.2.2 关于线程的一些问题</h4><ul>
<li><p>进程与线程的关系？</p>
<ul>
<li>一个进程包含多个线程</li>
</ul>
</li>
<li><p>线程分类</p>
<ul>
<li>前台线程和后台线程，我们使用<strong>后台线程</strong></li>
</ul>
</li>
<li><p>==为什么要用多线程？==</p>
<ul>
<li><p>因为单线程容易造成<strong>程序假死</strong></p>
</li>
<li><p>如，Form窗体中只有一个button1</p>
</li>
</ul>
</li>
</ul>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 按下button1后，调用test()
// 此时主线程去控制台执行Console.WriteLine()了
// 若test()没有执行完，Form窗体会卡死，无法拖动或执行其他操作

private void button1_Click(object sender, EventArgs e)
{
    test();
}

public void test()
{
    for(int i = 0; i&lt;1000000; i++)
    {
        Console.WriteLine(i);
    }
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li><p>通过==线程调用函数==的一些注意事项</p>
<ul>
<li>无参函数</li>
</ul>
</li>
</ul>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 通过线程调用无参函数

private void button1_Click(object sender, EventArgs e)
{
    Thread th = new Thread(Test);
    
    // 开启后台进程，其会在前台进程结束后 自动终止，不会等待后台进程执行完毕
    th.IsBackground = true;
    th.Start();
}

public void test()
{
    for(int i = 0; i&lt;1000000; i++)
    {
        Console.WriteLine(i);
    }
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>有参函数</li>
</ul>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 对于有参函数
// 形参的类型必须是 Object 
// 线程调用传参，通过对 Start() 写入实参进行传递

private void button1_Click(object sender, EventArgs e)
{
    Thread th = new Thread(Test);
    th.IsBackground = true;
    th.Start("123");
}

public void test(object s)
{
    string ss = string(s)
    for(int i = 0; i&lt;1000000; i++)
    {
        Console.WriteLine(i);
    }
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li><p>跨线程调用控件</p>
<ul>
<li>要想跨线程调用控件，可以通过<strong>取消程序的跨线程检查</strong>实现</li>
</ul>
</li>
</ul>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">Control.CheckForIllegalCrossThreadCalls = false;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<ul>
<li>3个label，1个button</li>
</ul>
<img src="image-20231211201441672-1705156191297-36.png" alt="" style="zoom:33%;">

<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">bool b = false;

private void Form1_Load(object sender, EventArgs e)
{
    // 取消跨线程检查，实现控件的跨线程调用
    Control.CheckForIllegalCrossThreadCalls = false;
}

private void button1_Click(object sender, EventArgs e)
{
    if(b == false)
    {
        b = true;
        button1.Text = "停止";
        Thread th = new Thread(PlayGame);
        th.IsBackground = true;
        th.Start();
    }
    else
    {
        b = false;
        button1.Text = "开始";
    }
}

private void PlayGame()
{
    Random r = new Random();
    while (b)
    {
        // 若没有取消跨线程检查，此处会报错
        label1.Text = r.Next(0, 9).ToString();
        label2.Text = r.Next(0, 9).ToString();
        label3.Text = r.Next(0, 9).ToString();
    }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h4 id="6-2-3-多线程"><a href="#6-2-3-多线程" class="headerlink" title="6.2.3 多线程"></a>6.2.3 多线程</h4><ul>
<li>多个执行流同时运行</li>
<li>实际还是单线程，但对CPU进行了时间切片，在每个时间片内执行一个线程</li>
<li>如何实现多线程？<ul>
<li>基于委托异步实现</li>
<li><code>Thread</code></li>
<li><code>ThreadPool</code></li>
<li><code>Task</code></li>
<li><code>TaskFactory</code></li>
<li><code>Parallel</code>并行编程</li>
</ul>
</li>
</ul>
<h5 id="6-2-3-1-基于委托的异步编程"><a href="#6-2-3-1-基于委托的异步编程" class="headerlink" title="6.2.3.1 基于委托的异步编程"></a>6.2.3.1 基于委托的异步编程</h5><ul>
<li><p>异步编程是建立在<strong>委托</strong>的基础上</p>
</li>
<li><p>异步调用的每个方法，都是在<strong>独立的进程</strong>中执行的</p>
</li>
<li><p>异步编程是<strong>多线程的一种</strong>，可以说是简化的多线程</p>
</li>
<li><p>什么时候使用异步？</p>
<ul>
<li>比较适合在后台<strong>耗费时间较长，但任务简单</strong>且各任务间相互独立的情况</li>
</ul>
</li>
<li><p>如果后台要求访问共享资源，并且要按照某种顺序执行，此时异步不适合，应该采用其他多线程去完成</p>
</li>
<li><p><code>D:\Program Files\Microsoft Visual Studio\projects\异步-多线程\多线程\Study1</code></p>
</li>
</ul>
<h6 id="6-2-3-1-1-示例"><a href="#6-2-3-1-1-示例" class="headerlink" title="6.2.3.1.1 示例"></a>6.2.3.1.1 示例</h6><ul>
<li>先声明一个<code>random</code>对象</li>
</ul>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 后续模拟线程耗时
// 多线程环境或需要长期保持随机数序列不变的情况下，通常建议将其声明为 static

private static Random random = new Random();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>基于<code>Func&lt;&gt;</code>定义匿名委托</li>
</ul>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 基于委托求一个数的平方
// 该委托输入参数为 num，输出结果为 num*num

private Func&lt;int, int&gt; Operation = (num) =&gt;
{
    // 模拟耗时，使当前进程暂停
    Thread.Sleep(random.Next(5) * 1000);
    return num * num;
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>定义回调方法<code>AutoCallBack()</code></li>
</ul>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 回调函数
// 通过 IAsyncResult.AsyncState 可获取传递给异步操作的标识参数
// 通过 Operation.EndInvoke() 获取异步操作的结果
private void AutoCallBack(IAsyncResult result)
{
    int res = Operation.EndInvoke(result);
    Console.WriteLine($"第{result.AsyncState}个计算结果是{res}");
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>启动多线程</li>
</ul>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">private void btnExec_Click(object sender, EventArgs e)
{
    for(int i =1; i &lt; 11; i++)
    {
        // 异步
        // 通过循环将 10 个任务同时发布出去
        // 各自执行，互不影响
        // 参数中的回调函数，是当该异步任务执行完成后，需要自动调用的方法

        // 启动异步任务，每个任务会执行 Operation 委托，并传入参数 i*10
        // Operation 委托执行完成后，调用 AutoCallBack 回调方法，并传入标识参数 i
        Operation.BeginInvoke(i * 10, AutoCallBack, i);
    }
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h6 id="6-2-3-1-2-一些问题"><a href="#6-2-3-1-2-一些问题" class="headerlink" title="6.2.3.1.2 一些问题"></a>6.2.3.1.2 一些问题</h6><ul>
<li><code>Operation.BeginInvoke(i*10,AutoCallBack,i);</code>中的标识参数<code>i</code>有什么用？<ul>
<li>将不同的 <code>i</code> 传递给异步操作，<strong>标识线程</strong>，以便<strong>在异步操作完成后</strong>能够在回调函数中<strong>识别是哪个线程完成了</strong></li>
</ul>
</li>
<li><code>int res = Operation.EndInvoke(result);</code>怎么理解？<ul>
<li><code>result</code>是传入的标识参数<code>i</code>，<code>EndInvoke()</code>通过使用该标识去获取对应线程的运行结果</li>
</ul>
</li>
</ul>
<h5 id="6-2-3-2-基于Thread多线程"><a href="#6-2-3-2-基于Thread多线程" class="headerlink" title="6.2.3.2 基于Thread多线程"></a>6.2.3.2 基于Thread多线程</h5><ul>
<li><code>D:\Program Files\Microsoft Visual Studio\projects\异步-多线程\多线程\Threads</code></li>
</ul>
<h6 id="6-2-3-2-1-跨线程调用控件"><a href="#6-2-3-2-1-跨线程调用控件" class="headerlink" title="6.2.3.2.1 跨线程调用控件"></a>6.2.3.2.1 跨线程调用控件</h6><ul>
<li><p>前面记<code>Thread</code>，此处新增==跨线程调用控件==的方法</p>
<ul>
<li><p><code>Control.CheckForIllegalCrossThreadCalls = false;</code>取消跨线程检测，尽量不用</p>
</li>
<li><p>主要代码</p>
</li>
</ul>
</li>
</ul>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// Control.Invoke() 实现跨线程调用
// Control.InvokeRequired 该属性在 Control 不是UI线程时为 true；反之，为 false
if (this.lalResult1.InvokeRequired)
    {
        this.lalResult1.Invoke(
            new Action&lt;string&gt;(s =&gt; { this.lalResult1.Text = s; }),
            num.ToString() );
    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>示例代码</li>
</ul>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">private void btnExecute1_Click(object sender, EventArgs e)
{
    // 任务一
    int num = 0;
    Thread thread = new Thread(() =&gt;
    {
        for(int i = 1; i &lt; 20; i++)
        {
            num += i;
            
            // 跨线程调用控件
            if (this.lalResult1.InvokeRequired)
            {
                this.lalResult1.Invoke(
                    new Action&lt;string&gt;(s =&gt; { this.lalResult1.Text = s; }),
                    num.ToString() );
            }
            Thread.Sleep(300);
        }
    });

    thread.IsBackground = true; // 设置为后台线程
    thread.Start();

    // 关于前台线程和后台线程：
    // 一个程序如果有前台线程，必须在所有的前台线程都结束后，才能退出
    // 一个程序如果开启的都是后台线程，则程序关闭后，后台线程就会自动全部退出
}

private void btnExecute2_Click(object sender, EventArgs e)
{
    
    Thread th = new Thread(() =&gt;
    {
        for(int i = 1;i &lt; 20; i++)
        {
            if (this.lalResult2.InvokeRequired)
            {
                this.lalResult2.Invoke(
                    new Action&lt;string&gt;(s =&gt; { this.lalResult2.Text = s; }),
                    i.ToString());
            }
            Thread.Sleep(i*100);
        }
    });

    th.IsBackground = true;
    th.Start();
}

private void btnRead_Click(object sender, EventArgs e)
{
    Thread th = new Thread(() =&gt;
    {
        if (this.txtV.InvokeRequired)
        {
            this.txtV.Invoke(new Action&lt;string&gt;(s =&gt; { this.lalV.Text = s; }),
            txtV.Text);

            //Thread.Sleep(100);
        }

    });

    th.IsBackground = true;
    th.Start();

}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h6 id="6-2-3-2-2-跨控件访问数据库"><a href="#6-2-3-2-2-跨控件访问数据库" class="headerlink" title="6.2.3.2.2 跨控件访问数据库"></a>6.2.3.2.2 跨控件访问数据库</h6><ul>
<li><code>D:\Program Files\Microsoft Visual Studio\projects\异步-多线程\多线程\ThreadDataBase</code></li>
</ul>
<p>先把数据库学了来！！！！！</p>
<h3 id="6-3-Socket"><a href="#6-3-Socket" class="headerlink" title="6.3 Socket"></a>6.3 Socket</h3><h4 id="6-3-1-关于Socket的一些问题"><a href="#6-3-1-关于Socket的一些问题" class="headerlink" title="6.3.1 关于Socket的一些问题"></a>6.3.1 关于Socket的一些问题</h4><ul>
<li><p>怎么理解Socket</p>
<ul>
<li>人通过 <strong>电话</strong> 进行通信，==程序通过 Socket 来通==，套接字就是程序间的电话机</li>
<li>Socket是进程通信机制，也称作“套接字”，用于<strong>描述IP地址和端口</strong>，是一个通信链的句柄，是两个程序间通信用的</li>
<li>Socket类型<ul>
<li><strong>流式Socket</strong>（STREAM）：一种面向连接的Socket，针对<strong>TCP</strong>服务应用，安全，但是效率低</li>
<li><strong>数据报式Socket</strong>（DATAGRAM）：一种无连接Socket，对应于<strong>UDP</strong>服务应用，不安全（丢失，顺序紊乱，在接收端要分析重排及要求重发），但效率高</li>
</ul>
</li>
<li>以电话网为例，电话的通话双方相当于通信的2个程序，<strong>电话号码就是IP地址</strong>。任何用户在通话前，首先要占有<strong>一部电话机，相当于申请一个Socket</strong>；同时要知道对方的号码，对方也得有一部电话，即一个Socket。然后向对方<strong>拨号呼叫，相当于发出连接请求</strong>。对方假如在场并空闲，拿起电话话筒，双方就可以进行正式<strong>通话，相当于连接成功</strong>。双方通话的过程，是一方向电话机发出信号，和对方从电话机接收信号的过程，相当于<strong>向Socket发送数据和从Socket接收数据</strong>。通话结束后，一方挂起电话机，相当于<strong>关闭Socket，撤销连接</strong>。</li>
<li>关于端口，客户端与服务器使用<strong>IP地址建立联系</strong>，而客户端只需要与服务器中的某一个程序进行连接，在服务器中使用<strong>端口号标记各程序</strong>。</li>
</ul>
</li>
<li><p>Socket一般==应用模式==（服务端和客户端）</p>
<ul>
<li>服务端 welcoming Socket 监听端口，检测客户端的连接请求</li>
<li>客户端 client Socket 连接服务端指定端口，并用于接收和发送 服务端消息</li>
<li>服务端 welcoming Socket 监听到客户端连接，创建 connection Socket，实现与客户端的通信</li>
<li>以男生去女生宿舍找女同学为例，男生要想找到女生宿舍得某一个的女生，首先要找到宿管大妈，告诉大妈找人的原因（如生病了来看望女同学），宿管大妈再去找到并通知对应的女生，进而建立男生与女生之间的联系。过程中，男生相当于客户端，宿管阿姨扮演负责监听的Socket，女生相当于服务端里的应用程序，当男生发出请求，宿管阿姨就创建一个负责通信的Socket，用于男生和女生通信</li>
</ul>
</li>
<li><p>Socket中的==端口==</p>
<ul>
<li>Internet上有很多主机，每台主机同时运行了多个服务软件，提供多种服务，每种服务都打开一个Socket，并绑定到一个端口上，不同的端口对应于不同的服务。例如，http使用80端口，ftp使用21端口，smtp使用25端口</li>
</ul>
</li>
<li><p>什么是==协议==</p>
<ul>
<li><p>我和ikun打电话，中文是规定好的语言，电脑与电脑进行<strong>联系就需要协议</strong></p>
</li>
<li><p><strong>TCP</strong>协议，有<strong>三次握手</strong>，要求必须要有服务器，请求必须由客户端发起，因为服务器不知道客户端在哪。三次握手的过程：首先客户端给服务器发送消息“你有空吗？”，服务器收到客户端的消息后，回复“我有空”，最后客户端再给服务器发送消息“我知道你有空了”。<strong>只有完成三次握手连接上后，客户端才跟服务器相收发数据，否则不会进行数据的沟通</strong>。所以TCP协议<strong>安全、稳定、但是效率低</strong>（需要花时间去握手）</p>
</li>
<li><p><img src="/2024/01/13/shang-wei-ji/image-20240206173133057.png"></p>
</li>
<li><p><strong>UDP</strong>协议，<strong>快速，效率高，但是不稳定，容易发生数据丢失</strong>，客户端不管服务器是否有空，直接把消息发送到服务器，当服务器繁忙的时候不能即使对接收到的数据进行处理，进而造成数据丢失</p>
</li>
<li><p>两种协议各有好坏，视频传输使用的就是UDP协议</p>
</li>
</ul>
</li>
</ul>
<h4 id="6-3-2-Socket通信流程"><a href="#6-3-2-Socket通信流程" class="headerlink" title="6.3.2 Socket通信流程"></a>6.3.2 Socket通信流程</h4><ul>
<li><p>Socket通信流程图</p>
<ul>
<li><p><img src="/2024/01/13/shang-wei-ji/image-20240206173230194.png"></p>
</li>
<li><p>服务端<code>Bind()</code>：负责绑定监听端口；<code>Listen()</code>：设置监听队列：<code>Accept()</code>：放循环中，等待客户连接</p>
</li>
</ul>
</li>
</ul>
<h5 id="6-3-2-1-服务端"><a href="#6-3-2-1-服务端" class="headerlink" title="6.3.2.1 服务端"></a>6.3.2.1 服务端</h5><ul>
<li><strong>创建</strong>一个负责<strong>监听的Socket</strong></li>
</ul>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 创建监Socket，初始化地址簇、套接字类型、协议类型
Socket socketWatch = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtoolType.Tcp);

// 让 socketWatch 监听所有网络接口的连接请求
IPAdress ip = IPAdress.Any;

// 创建终结点
IPEndPoint point = new IPEndPoint(ip, Convert.ToInt32(txtPort.Text));

// socketWatch 绑定指定的终结点
socketWatch.Bind(point);

// 设置并发连接数，监听队列长度
socketWatch.Listen(10);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>开启线程<strong>等待连接</strong>，连接成功后，<strong>创建通信socket</strong></li>
</ul>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 调用的自定义的 Listen 函数
Thread th = new Thread(Listen);
th.IsBackground = true;
th.start(scoketWatch);

// 将 socketSend 设置为全局变量
Socket socketSend;

private void Listen(object o)
{
    socket socketWatch = o as socket;
    // socketWatch 循环监听连接请求
    while(true)
    {
        // Accept()是一个 阻塞 方法
        // 有客户端请求连接时，返回一个新的 Socket，表示与客户端建立了连接
        // 创建一个用于通信的 Socket
        socketSend = socketWatch.Accept();
        
        
        // 连接成功后，可进行一些内部处理
        
        // 如开启线程，接收客户端数据
        Thread th = new Thread(Receive);
        th.IsBackground = true;
        th.Start(socketSend);
        
    }
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>当发生跨线程调用控件时，可在窗体加载时 <strong>关闭跨线程检查</strong></li>
</ul>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">Controls.CheckForIllegalCrossThreadCalls = false;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<ul>
<li>服务器<strong>接收数据</strong></li>
</ul>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">private void Receive(object o)
{
	socket socketSend = o as socket;
    try
    {
        // 循环接收数据，知道把数据接收完
        while(true)
        {
            byte buffer = new byte[1024 * 1024 * 3];
            
            // 当 buffer 长度小于待接收的数据时，截取满buffer长度，就进行阶段，等待继续下次接收
            int r = socketSend.Receive(buffer);
            
            // 当数据接收完
            if(r == 0)
            {
                break;
            }
            
            // 将 buffer 解码为字符串
            // string str = Encoding.UTF8.GetString(buffer);
        }
        catch
        {
            
        }
    }
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>服务器<strong>发送数据</strong></li>
</ul>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 以按键点击发送数据为例

private void btnSend_Click(object sender, EvenArgs e)
{
    string str = txtSend.Text;
    byte[] buffer = Encoding.UTF8.GetBytes(str);
    
    // 此处 socketSend 为前面创建的全局变量
    socketSend.Send(buffer);
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>




<h5 id="6-3-2-2-客户端"><a href="#6-3-2-2-客户端" class="headerlink" title="6.3.2.2 客户端"></a>6.3.2.2 客户端</h5><ul>
<li>创建<strong>客户端Socket</strong>，并连接指定终结点</li>
</ul>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 做全局变量
Socket socketSend;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">socketSend = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);

IPAdress ip = IPAdress.Parse(txtServer.Text);

IPEndPoint point = new IPEndPoint(ip, Convert.ToInt32(txtPort.Text));

socketSend.Connect(point);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>客户端<strong>接收消息</strong></li>
</ul>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">private void Receive()
{
    while(true)
    {
        byte[] buffer = new byte[1024 * 1024 * 3];
        int r = socketSend.Receive(buffer);
        if(r == 0)
        {
            break;
        }
        
        string str = Encoding.UTF8.GetString(buffer);
        
    }
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>客户端<strong>发送消息</strong></li>
</ul>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 同样以按键点击发送消息

private btnSend_Click(object sender, EventArgs e)
{
    string str = txtMsg.Text.Trim();
    byte[] buffer = Encoding.UTF8.GetBytes(str);
    socketSend.Send(buffer);
    
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h4 id="6-4-3-基于Socket的聊天程序"><a href="#6-4-3-基于Socket的聊天程序" class="headerlink" title="6.4.3 基于Socket的聊天程序"></a>6.4.3 基于Socket的聊天程序</h4><h5 id="6-4-3-1-实现功能"><a href="#6-4-3-1-实现功能" class="headerlink" title="6.4.3.1 实现功能"></a>6.4.3.1 实现功能</h5><ul>
<li>传送文件</li>
<li>判断接收数据是文件还是文字</li>
<li>设计协议<ul>
<li>在传递的字节数组前加上一个字节作为标识：0表示文字，1表示文件</li>
<li>文字：0 + 字节数组</li>
<li>文件：1 + 文件二进制信息</li>
</ul>
</li>
</ul>
<h5 id="6-4-3-2-服务器"><a href="#6-4-3-2-服务器" class="headerlink" title="6.4.3.2 服务器"></a>6.4.3.2 服务器</h5><ul>
<li>创建<code>socketWatch</code><strong>监听连接</strong></li>
</ul>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">private void btnStart_Click(object sender, EventArgs e)
{
    try
    {
        Socket socketWatch = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);
        IPAddress ip = IPAddress.Any;
        int port = Convert.ToInt32(txtPort.Text);
        IPEndPoint point = new IPEndPoint(ip, port);
        socketWatch.Bind(point);
        showMsg("开始监听");
        socketWatch.Listen(10);
        Thread th = new Thread(Accept);
        th.IsBackground = true;
        th.Start(socketWatch);
    }
    catch
    {

    }
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li><strong>接收客户端连接</strong>，并开启<code>Receive</code>线程</li>
</ul>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">Socket socketServer = null;

private void Accept(object socketWatchObj)
{
    Socket socketWatch = (Socket)socketWatchObj;
    while (true)
    {
        try
        {
            socketServer = socketWatch.Accept();
            showMsg(socketServer.RemoteEndPoint.ToString() + "  连接成功");
            Thread th = new Thread(Receive);
            th.IsBackground = true;
            th.Start();//(socketServer);
        }
        catch
        {

        }
        
    }
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li><strong>打印信息</strong></li>
</ul>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">private void showMsg(string str)
{
    txtLog.AppendText(str+"\r\n");
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li><strong>接收数据</strong></li>
</ul>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">private void Receive()//(object socketServerObj)
{
    //Socket socketServer = socketServerObj as Socket;
    while (true)
    {
        try
        {
            byte[] buffer = new byte[1024 * 1024 * 3];
            int num = socketServer.Receive(buffer);
            if (num == 0)
            {
                showMsg("与客户端连接中断");
                break;
            }
            string str = Encoding.UTF8.GetString(buffer, 0, num);
            showMsg(socketServer.RemoteEndPoint.ToString() + "  " + str);
        }
        catch
        {

        }
    }
    
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>发送<strong>文本数据</strong></li>
</ul>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">private void btnSend_Click(object sender, EventArgs e)
{
    string str = txtMsg.Text;
    byte[] buffer = Encoding.UTF8.GetBytes(str);

    // 数组长度不可变
    // 使用 List 来增加协议标识，并转为 数组
    List&lt;byte&gt; list = new List&lt;byte&gt;();
    list.Add(0);
    list.AddRange(buffer);
    byte[] newBuffer = list.ToArray();

    socketServer.Send(newBuffer);
    txtMsg.Clear();
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>选择并<strong>发送文件</strong></li>
</ul>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">private void btnSelect_Click(object sender, EventArgs e)
{
    OpenFileDialog ofd = new OpenFileDialog();
    ofd.InitialDirectory = @"";
    ofd.Title = "请选择要发送的文件";
    ofd.Filter = "所有文件|*.*";
    ofd.ShowDialog();
    txtPath.Text = ofd.FileName;
}

private void btnSendFile_Click(object sender, EventArgs e)
{
    //  获取发送文件的路径
    string path = txtPath.Text;
    using (FileStream fsRead = new FileStream(path, FileMode.Open, FileAccess.Read))
    {
        byte[] buffer = new byte[1024 * 1024 * 5];
        int r = fsRead.Read(buffer, 0, buffer.Length);

        List&lt;byte&gt; list = new List&lt;byte&gt;();
        list.Add(1);
        list.AddRange(buffer);
        byte[] newBuffer = list.ToArray();
        
        socketServer.Send(newBuffer,0,r+1,SocketFlags.None);
    }
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h5 id="6-4-3-3-客户端"><a href="#6-4-3-3-客户端" class="headerlink" title="6.4.3.3 客户端"></a>6.4.3.3 客户端</h5><ul>
<li><strong>连接服务器</strong></li>
</ul>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">private void btnConnect_Click(object sender, EventArgs e)
{
    try
    {
        socketClient = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);
        IPEndPoint point = new IPEndPoint(IPAddress.Parse(txtIP.Text), Convert.ToInt32(txtPort.Text));
        socketClient.Connect(point);
        showMsg(socketClient.RemoteEndPoint.ToString() + "  连接成功");

        Thread th = new Thread(Receive);
        th.IsBackground = true;
        th.Start();
    }
    catch
    {

    }
    
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li><strong>打印信息</strong></li>
</ul>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">private void showMsg(string str)
{
    txtLog.AppendText(str + "\r\n");
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li><strong>接收消息</strong></li>
</ul>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">private void Receive()//(object socketClientObj)
{
    // Socket socketClient = socketClientObj as Socket;
    while (true)
    {
        try
        {
            byte[] buffer = new byte[1024 * 1024 * 3];
            int num = socketClient.Receive(buffer);
            if (num == 0)
            {
                showMsg("断开连接");
                break;
            }

            // 根据标识执行对应动作

            // 文字消息
            if (buffer[0] == 0)
            {
                string str = Encoding.UTF8.GetString(buffer, 1, num-1);
                showMsg(socketClient.RemoteEndPoint.ToString() + "  " + str);
            }
            else if (buffer[0] == 1)
            {
                SaveFileDialog sfd = new SaveFileDialog();
                sfd.InitialDirectory = @"";
                sfd.Title = "请选择要保存的文件";
                sfd.Filter = "所有文件|*.*";
                sfd.ShowDialog(this);

                string path = sfd.FileName;
                using(FileStream fsWrite = new FileStream(path, FileMode.OpenOrCreate, FileAccess.Write))
                {
                    fsWrite.Write(buffer, 1, num-1);

                }
                MessageBox.Show("保存成功");
            }
        }
        catch
        {

        }
    }
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li><strong>发送消息</strong></li>
</ul>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">private void btnSend_Click(object sender, EventArgs e)
{
    string str = txtMsg.Text;
    byte[] buffer = Encoding.UTF8.GetBytes(str);
    socketClient.Send(buffer);
    txtMsg.Clear();
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h3 id="6-4-委托"><a href="#6-4-委托" class="headerlink" title="6.4 委托"></a>6.4 委托</h3><h4 id="6-4-1-关于委托的一些问题"><a href="#6-4-1-关于委托的一些问题" class="headerlink" title="6.4.1 关于委托的一些问题"></a>6.4.1 关于委托的一些问题</h4><ul>
<li>为什么要使用委托<ul>
<li>为了将一个方法作为参数传递给另一个方法，此时传递的的方法应是委托类型</li>
</ul>
</li>
<li>==注意==<ul>
<li>委托所指向的函数必须与委托具有相同的签名</li>
<li>委托声明放在<code>class</code>外，<code>namespace</code>内</li>
</ul>
</li>
</ul>
<h4 id="6-4-2-委托的使用"><a href="#6-4-2-委托的使用" class="headerlink" title="6.4.2 委托的使用"></a>6.4.2 委托的使用</h4><h5 id="6-4-2-1-基本使用"><a href="#6-4-2-1-基本使用" class="headerlink" title="6.4.2.1 基本使用"></a>6.4.2.1 基本使用</h5><ul>
<li>有两个<strong>签名一致</strong>的函数</li>
</ul>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">public static void SayHiChinese(string name)
{
    Console.WriteLine("早上好" + name);
}

public static void SayHiEnglish(string name)
{
    Console.WriteLine("Nice to meet you " + name);
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li><strong>声明委托</strong>，委托需要与函数签名一致</li>
</ul>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">public delegate void DelSayHi(string name);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<ul>
<li><p><strong>使用委托</strong></p>
<ul>
<li><strong>new</strong> 声明</li>
</ul>
</li>
</ul>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">DelSayHi del = new DelSayHi(SayHichinese);
del("张山");<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<ul>
<li><strong>赋值</strong></li>
</ul>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 直接赋值
DelSayHi del = SayHiChinese;
del("张山");<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 传参赋值
Test("张山", SayHiChinese);

public static void Test(string name, DelSayHi del)
{
    del(name);
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h5 id="6-4-2-2-匿名函数"><a href="#6-4-2-2-匿名函数" class="headerlink" title="6.4.2.2 匿名函数"></a>6.4.2.2 匿名函数</h5><ul>
<li><p>当某个方法只需要执行一次的时候，可用将方法写成匿名函数</p>
</li>
<li><p>以前文代码为例</p>
</li>
</ul>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 当只需要中文的问好时
// 可删掉 SayHiChines()，减少代码量
DelSayHi del = delegate(string name)
{
    Console.WriteLine("早上好"+name);
};


// 前几行代码也可以写为 lambda表达式
// 参数指向方法体
DelSayHi del = (string name) =&gt; {Console.WriteLine("早上好"+name);};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h5 id="6-4-2-3-泛型委托"><a href="#6-4-2-3-泛型委托" class="headerlink" title="6.4.2.3 泛型委托"></a>6.4.2.3 泛型委托</h5><ul>
<li><p>求任意数组的最大值（int[] 为数值最大，string[] 为长度最长）</p>
</li>
<li><p><strong>初始代码</strong></p>
</li>
</ul>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 返回 int 最大值
public static int GetMax(int[] nums)
{
    int max = nums[0];
    for(int i = 0; i &lt; nums.Length; i++)
    {
        if(max &lt; nums[i])
        {
            max = nums[i];
        }
    }
    return max;
}


// 返回 string 最长字符串
// 函数重载
public static string GetMax(string[] names)
{
    string max = names[0];
    for(int i = 0; i &lt; names.Length; i++)
    {
        if(max.Length &lt; names[i].Length)
        {
            max = names[i];
        }
    }
    return max;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<ul>
<li>为减少代码量，将两个方法使用**<code>object</code>替换**一个方法，并使用委托作为<code>if</code>的判断条件</li>
</ul>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 声明一个委托去处理判断条件的真假
// 委托的返回值为 int
// 参数与 GetMax 一致，使用 object
public delegate int DelCompare(object o1, object o2);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">public static object GetMax(object[] nums, DelCompare del)
{
    object max = nums[0];
    for(int i = 0; i &lt; nums.Length; i++)
    {
        // 传一个比较方法
        if(del(max, nums[i]) &lt; 0)
        {
            max = nums[i];
        }
    }
    return max;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 根据委托签名书写调用的比较函数

// int类
public static int Compare1(object o1, object o2)
{
    int n1 = (int)o1;
    int n2 = (int)o2;
    return n1 - n2;
}

// string类
public static string Compare2(object o1, object o2)
{
	string s1 = (string)o1;
    string s2 = (string)o2;
    return s1.Length - s2.Length;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// Main方法
public static void Main(string[] args)
{
    // 比较 int
    object o1 = {1, 2, 3, 4, 5};
    object result1 = GetMax(o1, Compare1);
    Console.WriteLine(result1);
    
    // 比较 string
    object o2 = {"qwhdaj", "gakddnajdhowiud"};
    object result2 = GetMax(o2, Compare2);
    Console.WriteLine(result2);
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<ul>
<li>使用<code>object</code>类型涉及 装箱拆箱 ，继续使用 <strong>泛型</strong> 减少代码量</li>
</ul>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 使用泛型委托
public static int DelCompare&lt;T&gt;(T o1, T o2);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 修改前文 public static object GetMax(object[] nums, DelCompare del)

public static T GetMax&lt;T&gt;(T[] nums, DelCompare&lt;T&gt; del)
{
    T max = nums[0];
    for(int i = 0; i &lt; nums.Length; i++)
    {
        if(del(max, nums[i]) &lt; 0)
        {
            max = nums[i];
        }
    }
    return max;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">public static int Compare1(int o1, int o2)
{
    return o1 - o2;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// Main函数
public static void Main(string[] args)
{
    // int 类
    int[] nums = {1, 2, 3, 4, 5};
    int max = GetMax&lt;int&gt;(nums, Compare1);
    Console.WriteLine(max);
    
    // string 类
    string[] names = {"hdakd", "hsadopjadlja"};
    string result = GetMax&lt;string&gt;(names, (string s1, string s2) =&gt; {
        return s1.Length - s2.Length;});
    COnsole.WriteLine(result);
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h5 id="6-4-2-4-Lambda表达式"><a href="#6-4-2-4-Lambda表达式" class="headerlink" title="6.4.2.4 Lambda表达式"></a>6.4.2.4 Lambda表达式</h5><ul>
<li><code>Lambda表达式</code>本质上还是<code>匿名函数</code></li>
</ul>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">DelCompare del = (string name) =&gt; {Console.WriteLine(name)};<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">List&lt;int&gt; list = new List&lt;int&gt;(){1, 2, 3, 4, 5, 6, 7};

// 将 大于4 的全部删除
list.RemoveAll(n =&gt; n&gt;4);

foreach(var item in list)
{
    Console.WriteLine(item);
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h3 id="6-5-事件"><a href="#6-5-事件" class="headerlink" title="6.5 事件"></a>6.5 事件</h3><h4 id="6-5-1-关于事件的一些问题"><a href="#6-5-1-关于事件的一些问题" class="headerlink" title="6.5.1 关于事件的一些问题"></a>6.5.1 关于事件的一些问题</h4><ul>
<li>==委托与事件的区别==<ul>
<li>委托是对方法的引用，而事件是一种特殊的委托，用于实现观察者模式，方便对象在状态变化时通知其他对象</li>
<li>委托不安全，事件的本质是一个安全的委托</li>
<li>委托在哪都可以调用，而事件只能在类内进行调用</li>
<li>委托是一种类型，事件是基于委托的一种机制，通过”Event”关键字进行声明</li>
<li>委托允许直接调用委托实例所引用的方法，而事件只能通过”+=“和”-=“来添加移除事件处理程序</li>
<li>实际应用时，事件能够提供更灵活的机制来处理对象间的通信</li>
</ul>
</li>
</ul>
<h4 id="6-5-2-事件的使用"><a href="#6-5-2-事件的使用" class="headerlink" title="6.5.2 事件的使用"></a>6.5.2 事件的使用</h4><h5 id="6-5-2-1-基本使用"><a href="#6-5-2-1-基本使用" class="headerlink" title="6.5.2.1 基本使用"></a>6.5.2.1 基本使用</h5><ul>
<li><p>以按键播放音乐为例</p>
</li>
<li><p>创建<code>PlayMusic</code>类，并在其中<strong>定义委托事件</strong></p>
</li>
</ul>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 声明事件之前要先创建委托
public delegate void DelPlayOver();

internal class PlayMusic
{
	// 声明事件
    // 若没有event，那么public DelPlayOver Del;就是委托
    public event DelPlayOver Del;
    
    // 音乐名
    public string Name{get;set;}
    public PlayMusic(string name)
    {
        this.Name = name;
    }
    
    // 播放音乐
    public void PlaySongs()
    {
        Console.WriteLine("正在播放" + this.Name);
        
        // 模拟播放耗时
        Thread.Sleep(3000);
        
        if(Del != null)
        {
            // 执行对应事件
            Del();
        }
    }
    
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li><strong>绑定事件</strong>，并执行相应方法</li>
</ul>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">private void button1_Click(object sender, EventArgs e)
{
    PlayMusic p = new PlayMusic("哈哈哈哈哈");
    
    // 注册事件
    // 委托在调用方法时，p.Del = Test;
    p.Del += Test;
    
    p.PlaySongs();
}

// 事件绑定方法
public void Test()
{
    Console.WriteLine("播放完成了！！！");
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h3 id="6-6-关于文件"><a href="#6-6-关于文件" class="headerlink" title="6.6 关于文件"></a>6.6 关于文件</h3><h4 id="6-6-1-File-类"><a href="#6-6-1-File-类" class="headerlink" title="6.6.1 File 类"></a>6.6.1 File 类</h4><ul>
<li>用于==读小文件==，因为<code>File</code>类是一下读完问文本，所以在读大文件会对内存造成较大的负荷</li>
</ul>
<h5 id="6-6-1-1-基本操作"><a href="#6-6-1-1-基本操作" class="headerlink" title="6.6.1.1 基本操作"></a>6.6.1.1 基本操作</h5><ul>
<li><strong>创建</strong>文件</li>
</ul>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">File.Create(@"C:\Users\echo\Desktop\new.txt");<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<ul>
<li><strong>删除</strong>文件</li>
</ul>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">File.Delete(@"C:\Users\echo\Desktop\new.txt");<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<ul>
<li><strong>复制</strong>文件</li>
</ul>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">File.Copy(@"C:\Users\echo\Desktop\old.txt",@"C:\Users\echo\Desktop\new.txt");<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<ul>
<li><strong>剪切</strong>文件</li>
</ul>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">File.Move(@"C:\Users\echo\Desktop\old.txt",@"C:\Users\echo\Desktop\new.txt")<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>



<h5 id="6-6-1-2-读取文本"><a href="#6-6-1-2-读取文本" class="headerlink" title="6.6.1.2 读取文本"></a>6.6.1.2 读取文本</h5><ul>
<li><p><code>ReadAllBytes()</code>可读取任何文件（文本、图片、音乐等），需要转为字节；后两个方法<code>ReadAllLines()</code>和<code>ReanAllText()</code>，只能读文本文件</p>
</li>
<li><p>将文本<strong>读取为字节</strong></p>
</li>
</ul>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">byte[] buffer = File.ReadAllBytes(@"C:\Users\echo\Desktop\old.txt");

// 字节看不懂，转为字符串
// GetEncoding()，指定编码格式
string s = Encoding.GetEncoding("GB2312").GetString(buffer);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li><strong>按行读取</strong></li>
</ul>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 按行读取，返回字符串数组
string[] contents = File.ReadAllLines(@"C:\Users\echo\Desktop\old.txt",Encoding.Deffault);
foreach(string item in contents)
{
    Console.WriteLine(item);
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li><strong>全部读完</strong></li>
</ul>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 一下读完，返回一个string
string str = File.ReanAllText(@"C:\Users\echo\Desktop\old.txt",Encoding.Deffault);
Console.WriteLine(str);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>



<h5 id="6-6-1-3-写入文本"><a href="#6-6-1-3-写入文本" class="headerlink" title="6.6.1.3 写入文本"></a>6.6.1.3 写入文本</h5><ul>
<li><strong>覆盖写入字节</strong></li>
</ul>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 读取时，如果没有对应文件，会自行创建；有的话，进行覆盖

// 将字符串转为字节存储到文件中
string str = "你干嘛哎哟";

// Default 默认编码
byte[] buffer = Encoding.Default.GetBytes(str);
File.WriteAllBytes(@"C:\Users\echo\Desktop\new.txt",buffer);
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li><strong>覆盖按行写入</strong></li>
</ul>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">string[] str = new string[] {"sdf","jklj"};
File.WriteAllLines(@"C:\Users\echo\Desktop\new.txt",str);
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<ul>
<li><strong>覆盖全部写入</strong></li>
</ul>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">string str = "gakjfhlahfl";
File.WriteAllText(@"C:\Users\echo\Desktop\new.txt",str);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<ul>
<li><strong>追加写入</strong></li>
</ul>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">File.AppendAllText();
File.AppendAllLines();
File.AppendText();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>



<h4 id="6-6-2-编码简介"><a href="#6-6-2-编码简介" class="headerlink" title="6.6.2 编码简介"></a>6.6.2 编码简介</h4><ul>
<li>文本文件编码，文本文件有不同的存储方式，将字符串以特定的形式保存为二进制就是编码<ul>
<li>编码有<code>UTF8（web）、ASCII（字母、数字、音标）、Unicode（包含各种字体，但是解析慢）、GB2312（简体字）、Big5（简体 + 繁体字）</code></li>
<li><code>Unicode = UTF7 + UTF8 + UTF32</code></li>
</ul>
</li>
<li>文本<strong>乱码</strong>原因<ul>
<li>产生乱码的原因是  保存文件  时所采用的编码格式与  打开文件  时的编码格式不一样</li>
</ul>
</li>
</ul>
<h4 id="6-6-3-FileStream-类"><a href="#6-6-3-FileStream-类" class="headerlink" title="6.6.3 FileStream 类"></a>6.6.3 FileStream 类</h4><ul>
<li>读取文件时，是一点一点去读，不会对内存造成压力</li>
<li><code>FileStream</code>用于==操作字节==</li>
<li><code>FileStream</code>不会被垃圾回收机制处理，需要手动释放流所占用的内存</li>
</ul>
<h5 id="6-6-3-1-读取"><a href="#6-6-3-1-读取" class="headerlink" title="6.6.3.1 读取"></a>6.6.3.1 读取</h5><ul>
<li>读小文件</li>
</ul>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 创建FileStream对象
// FileMode：对文件要进行的操作
// FileAccess；对文本内容要进行的操作
FileStream fsRead = new FileStream(@"C:\Users\echo\Desktop\new.txt",FileMode.OpenOrCreate,FileAccess.Read);

// 创建 byte[] 去接收读取到的字节信息
byte[] buffer = new byte[1024 * 1024 * 5];

// 返回实际 读取到的有效字节数
int r =fsRead.Read(buffer,0,buffer.Length);

// 将字节数组中每一个元素按照指定编码格式解码为字符串
string s = Encoding.Default.GetString(buffer,0,r);

// 关闭流，释放流所占用的资源
fsRead.Close();
fsRead.Dispose();
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h5 id="6-6-3-2-写入"><a href="#6-6-3-2-写入" class="headerlink" title="6.6.3.2 写入"></a>6.6.3.2 写入</h5><ul>
<li><strong>自动释放流</strong>的写法</li>
</ul>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 自动释放流
using(FileStream name = new FileStream())
{
    
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">using(FileStream fsWrite = new FileStream(@"C:\Users\echo\Desktop\new.txt",FileMode.OpenOrCreate,FileAccess.Write))
{
    string str = "oaflalfjklaj";
    byte[] buffer = Encoding.Default.GetBytes(str);
    fsWrite.Write(buffer,0,buffer.Length);
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h5 id="6-6-3-3-基于FileStream的多媒体文件复制"><a href="#6-6-3-3-基于FileStream的多媒体文件复制" class="headerlink" title="6.6.3.3 基于FileStream的多媒体文件复制"></a>6.6.3.3 基于FileStream的多媒体文件复制</h5><ul>
<li><code>CopyFile</code>方法</li>
</ul>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 传入源文件路径、复制文件路径
public static void CopyFile(string source,string target)
{
    // 首次创建一个负责读取的流
    using (FileStream fsRead = new FileStream(source,FileMode.Open,FileAccess.Read))
    {
        // 创建写入流
        using (FileStream fsWrite = new FileStream(target,FileMode.OpenOrCreate,FileAccess.Write))
        {
            byte[] buffer = new byte[1024 * 1024 * 5];

            // 因为文件可能会比较大，所以循环读取
            while (true)
            {
                // Read：读取相应字节长度，然后将文件流的位置移动到已读取位置之后
                int r = fsRead.Read(buffer, 0, buffer.Length);

                // 读取完成
                if(r == 0)
                {
                    break;
                }
				
                // 追加写入
                fsWrite.Write(buffer, 0, r);

            }
        }
    }
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li><code>Main()</code>方法</li>
</ul>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">static void Main(string[] args)
{
    string source = @"C:\Users\echo\Desktop\Music\解解的神仙现场 - 海阔天空 - 邓紫棋 (2023时光音乐会老友记现场).wav";
    string target = @"C:\Users\echo\Desktop\解解的神仙现场.wav";
    CopyFile(source, target);
    Console.WriteLine("复制成功");
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h4 id="6-6-4-StreamReader和StreamWriter"><a href="#6-6-4-StreamReader和StreamWriter" class="headerlink" title="6.6.4 StreamReader和StreamWriter"></a>6.6.4 StreamReader和StreamWriter</h4><ul>
<li>操作字符、文本</li>
</ul>
<h5 id="6-6-4-1-StreamReader"><a href="#6-6-4-1-StreamReader" class="headerlink" title="6.6.4.1 StreamReader"></a>6.6.4.1 StreamReader</h5><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">using (StreamReader sr = new StreamReader(@"C:\Users\echo\Desktop\解解的神仙现场.txt", Encoding.Default))
{
    // 当没有读到文本末尾，循环打印读取到的行
    while (!sr.EndOfStream)
    {
        Console.WriteLine(sr.ReadLine());
    }

}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h5 id="6-6-4-2-StreamWriter"><a href="#6-6-4-2-StreamWriter" class="headerlink" title="6.6.4.2 StreamWriter"></a>6.6.4.2 StreamWriter</h5><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 不存在的文件，会自行创建
using (StreamWriter sw = new StreamWriter(@"C:\Users\echo\Desktop\new.txt",true))
{
    // 会覆盖源文本
    // 添加一个 true 后，不会进行覆盖
    sw.WriteLine("你赶紧的卡");
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>





<h2 id="七、SQL数据库"><a href="#七、SQL数据库" class="headerlink" title="七、SQL数据库"></a>七、SQL数据库</h2><ul>
<li>存储数据的仓库</li>
<li><strong>增删改查</strong></li>
</ul>
<h3 id="7-1-SQLServer使用"><a href="#7-1-SQLServer使用" class="headerlink" title="7.1 SQLServer使用"></a>7.1 SQLServer使用</h3><h4 id="7-1-1-创建登录名"><a href="#7-1-1-创建登录名" class="headerlink" title="7.1.1 创建登录名"></a>7.1.1 创建登录名</h4><ul>
<li><p>创建<code>SQL Server</code>身份，设置用户名和密码<img src="image-20240108190413092-1705156191297-37.png" alt="" style="zoom: 50%;"></p>
</li>
<li><p><code>服务器角色</code>，服务器名最大权限为<code>sysadmin</code>，要作为管理员身份对数据库进行使用，可以将其勾选上<img src="image-20240108190723983-1705156191297-38.png" alt="" style="zoom: 50%;"></p>
</li>
<li><p>带  ×  的账户，可通过<code>双击</code>，并将<code>强制实施密码策略</code>取消勾选，并将<code>状态/登录名</code>勾选为<code>启动</code></p>
</li>
</ul>
<h4 id="7-1-2-登录SQL账户"><a href="#7-1-2-登录SQL账户" class="headerlink" title="7.1.2 登录SQL账户"></a>7.1.2 登录SQL账户</h4><ul>
<li><p>创建好登录名后，首先修改<code>服务器身份验证</code>，选中<code>服务器</code>，右键<code>属性</code>，点击<code>安全性</code>，勾选<code>SQL Server 和 Windows 身份验证模式</code></p>
</li>
<li><p>然后电脑底部搜索框搜索<code>SQL</code>，进入<code>SQL Server 网络配置</code>，进入<code>MSSQLSERVER 的协议</code>，启用<code>Named Pipes</code>和<code>TCP/IP</code></p>
</li>
<li><p>再选中<code>服务器名称</code>，右键选择<code>重新启动</code>，进行<code>SQL 账户</code>登录</p>
</li>
<li><p>若二次登录，出现==无法连接==的情况</p>
<ul>
<li><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/l5615461/article/details/123120106">安装完SQL Server后,解决本地服务器连接失败的方法(仅供参考)_sql server连不上本地服务器-CSDN博客</a></p>
</li>
<li><blockquote>
<p>此电脑 –&gt; 右键-管理 –&gt; 服务与应用程序-服务 –&gt; SQL Server(MSSQLSERVER) –&gt; 右键-启动</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h4 id="7-1-3-创建数据库"><a href="#7-1-3-创建数据库" class="headerlink" title="7.1.3 创建数据库"></a>7.1.3 创建数据库</h4><ul>
<li>选中<code>数据库</code>文件夹，右键<code>新建数据库</code></li>
<li>设置<code>数据库名称</code>，自动生成<code>数据库文件（数据文件 和 日志文件）</code></li>
<li>对于两个数据库文件，可以自定义<code>初始大小（初始内存）</code>，并设置<code>增长大小（当文件内容长度超过初始大小后，自动增加内存）</code>，另外可更改 数据库文件 <code>存放路径</code></li>
<li>如，建立一个名为 <u>SQL学习测试</u> 的数据库，初始内存大小及增长 使用默认参数，文件路径改为 <u>D:\Program Files\Microsoft SQL Server\学习测试\数据库</u><img src="image-20240108200949234-1705156191297-39.png" alt="" style="zoom: 33%;"></li>
</ul>
<h4 id="7-1-4-删除数据库"><a href="#7-1-4-删除数据库" class="headerlink" title="7.1.4 删除数据库"></a>7.1.4 删除数据库</h4><ul>
<li><p>==删除数据库文件==，直接删除是删除不了的，因为数据库有一个监听端口，创建一个数据库就会自动建立一个监听连接，数据库被管理起来<img src="image-20240108201202870-1705156191297-40.png" alt="" style="zoom:50%;"></p>
</li>
<li><p>若要删除，首先选中 数据库 文件夹，右键<code>任务 -&gt; 分离</code>，并勾选<code>删除连接</code>，点击<code>确认</code>，移除该数据库<img src="/2024/01/13/shang-wei-ji/image-20240108201621911-1705156191297-41.png" alt="image-20240108201621911"></p>
</li>
<li><p>移除之后，便可对两个<code>数据库文件</code>进行删除</p>
</li>
</ul>
<h4 id="7-1-5-还原数据库"><a href="#7-1-5-还原数据库" class="headerlink" title="7.1.5 还原数据库"></a>7.1.5 还原数据库</h4><ul>
<li>若<code>数据文件</code>还存在，通过选中<code>数据库</code>，右键<code>附加</code>，然后<code>添加</code>，选择<code>.mdf</code>文件，<code>确认</code>即可还原<img src="/2024/01/13/shang-wei-ji/image-20240108202327547-1705156191297-42.png" alt="image-20240108202327547"></li>
</ul>
<h4 id="7-1-6-新建表"><a href="#7-1-6-新建表" class="headerlink" title="7.1.6 新建表"></a>7.1.6 新建表</h4><ul>
<li><p>选中<code>数据库</code>下的<code>表</code>文件夹，右键<code>新建 -&gt; 表</code>，设置<code>列名</code>等<img src="image-20240108205049779-1705156191297-43.png" alt="" style="zoom:50%;"></p>
</li>
<li><p>录入数据<img src="image-20240108205259257.png" alt="" style="zoom: 33%;"><img src="image-20240108205432705-1705156191297-45.png" alt="" style="zoom: 33%;"></p>
</li>
</ul>
<h4 id="7-1-7-使用SQL脚本"><a href="#7-1-7-使用SQL脚本" class="headerlink" title="7.1.7 使用SQL脚本"></a>7.1.7 使用SQL脚本</h4><ul>
<li><p>首先进入脚本界面，选中数据库，并<code>新建查询</code><img src="image-20240108205832210-1705156191297-46.png" alt="" style="zoom: 50%;"></p>
</li>
<li><p>一些脚本代码</p>
<ul>
<li>启动数据库</li>
</ul>
</li>
</ul>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">/*
-- 启动指定数据库
	-- use 数据库名
	-- go
*/

// 下面代码为 SQL 语言，之后的代码也一样
use SQL学习测试
go<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>添加数据</li>
</ul>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// -- 添加  insert into ，into这个关键词可以省略

// SQL 语言
insert Product([ProductNo], [ProductName], [ProductImage], [Price])
values(1002,'华为','image/xxx.jpg',9000)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>删除数据</li>
</ul>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// -- 删除 delete from，from这个关键词也可以省略

// SQL 语言
delete Product
where productName='华为'   -- where 关键词是条件
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<ul>
<li>修改数据</li>
</ul>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// -- 修改 update

// SQL 语言
update Product
set productname='华为mate40',productimage='image/huawei.jpg',price=10000
where productNo=1003<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<ul>
<li>查询数据</li>
</ul>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// -- 查询 select ... from ...

// SQL 语言
select * from Product  -- * 代表所有列

select [ProductNo], [ProductName] from Product  -- 查询指定列
where not productno=1001  -- 逻辑关键词 not and or 举例：where prductno=1003 or price&gt;5000<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h4 id="7-1-8-数据关联"><a href="#7-1-8-数据关联" class="headerlink" title="7.1.8 数据关联"></a>7.1.8 数据关联</h4><h5 id="7-1-8-1-创建数据关联关系"><a href="#7-1-8-1-创建数据关联关系" class="headerlink" title="7.1.8.1 创建数据关联关系"></a>7.1.8.1 创建数据关联关系</h5><ul>
<li>选中表格，右键<code>关系</code>，<code>添加</code>一个关系</li>
<li>在<code>常规</code>里，选中<code>表和列规范</code>的<code>...</code>，设置主键表和外键表</li>
<li>并将<code>在创建或重新启用时检查现有数据</code>设置为<code>否</code></li>
</ul>
<img src="image-20240109165325630-1705156191297-47.png" alt="" style="zoom:33%;">



<h5 id="7-1-8-2-关联表查询"><a href="#7-1-8-2-关联表查询" class="headerlink" title="7.1.8.2 关联表查询"></a>7.1.8.2 关联表查询</h5><ul>
<li><p>一些查询代码示例</p>
<ul>
<li>外联接</li>
</ul>
</li>
</ul>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// -- 外联接 inner join

// -- as 关键字可以进行重命名
// -- 表格也可以取别名 如：Product a

// SQL 语言
select [ProductNo] as 编号, [ProductName], [ProductImage], [Price], a.[typeId], b.typeName

// -- 对表格取别名
from Product a 
inner join ProductType b
on(a.typeId = b.typeId)

// -- 如果还有表需要关联检索，继续写 inner join... on...
// -- inner join otherTable
// -- on(a.ProductName=otherTable.Name)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>内联接</li>
</ul>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// -- 左外联接 left join    以左表为基准进行匹配，匹配到了就显示，没匹配到就不显示

// SQL 语言
select [ProductNo], [ProductName], [ProductImage], [Price], Product.[typeId], ProductType.typeName
from ProductType left join Product
on(Product.typeId = ProductType.typeId)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// -- 右外联接 right join

// SQL 语言
select [ProductNo], [ProductName], [ProductImage], [Price], Product.[typeId], ProductType.typeName
from ProductType right join Product
on(Product.typeId = ProductType.typeId)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h4 id="7-1-9-聚合函数"><a href="#7-1-9-聚合函数" class="headerlink" title="7.1.9 聚合函数"></a>7.1.9 聚合函数</h4><ul>
<li><p>除了<code>count()</code>，其余的<code>avg() / sum() / max() / min()</code>均针对<strong>数字类型和日期</strong></p>
</li>
<li><p>计数<code>count()</code></p>
</li>
</ul>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// -- count 统计记录条数，当有一列中的某个单元格值为 NULL 时，不对其进行计数

// SQL 语言
select COUNT(ProductName) from Product

// -- 统计全部，count()参数可写 */1
select count(*) from Product
select count(1) from Product<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>求均值<code>avg()</code></li>
</ul>
<pre class="line-numbers language-C#" data-language="C#"><code class="language-C#">// SQL
select avg(Price) from Product<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<ul>
<li>求和<code>sum()</code></li>
</ul>
<pre class="line-numbers language-C#" data-language="C#"><code class="language-C#">// SQL
select sum(Price) from Product<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<ul>
<li>求最值<code>max() / min()</code></li>
</ul>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// SQL
select max(Price) from Product

select min(Price) from Product<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>



<h4 id="7-1-10-排序与分组查询"><a href="#7-1-10-排序与分组查询" class="headerlink" title="7.1.10 排序与分组查询"></a>7.1.10 排序与分组查询</h4><ul>
<li>排序<code>order by ... asc/desc</code></li>
</ul>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// -- 排序 order by asc/desc  升序/降序

// SQL
select * from Product

// -- 先用 Price 降序排列，若 Price 有相同值，再用 typeId 进行二次降序排列
order by Price desc,typeId asc  
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>分组<code>group by</code></li>
</ul>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// -- 分组 group by 

// SQL
select ProductType.typeName as 类型, count(Product.ProductNo) as 数量
from Product left join ProductType
on(Product.typeId=ProductType.typeId)

// -- where
group by ProductType.typeName
order by 数量 desc<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li><p>一些==注意事项==</p>
<ul>
<li><blockquote>
<p>– 语法有一定顺序<br>– order 一定在最后<br>– group 在 order 前面<br>– where 在 group 前面，select…from …on..后面</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h3 id="7-2-C-中使用SQL"><a href="#7-2-C-中使用SQL" class="headerlink" title="7.2 C#中使用SQL"></a>7.2 C#中使用SQL</h3><h4 id="7-2-1-基本步骤"><a href="#7-2-1-基本步骤" class="headerlink" title="7.2.1 基本步骤"></a>7.2.1 基本步骤</h4><blockquote>
<p>案例见<code>D:\Program Files\Microsoft Visual Studio\projects\毕设\数据库学习\用户登录\UserLogIn</code></p>
</blockquote>
<ul>
<li>第一步：创建数据库对象</li>
</ul>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">/*
字符串参数分别为：
	Server   : 服务器名称
	uid	     : 登录名
	pwd      : 密码
	database : 数据库名称
*/

SqlConnection conn = new SqlConnection("Server = LAPTOP-H5KQEA5B;uid = demo; pwd = 123456;database = SQL学习测试");<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>第二步：打开数据库</li>
</ul>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">conn.Open();<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<ul>
<li>第三步：创建执行脚本对象</li>
</ul>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">string qq = this.txtQQ.Text;
string pwd = this.txtPwd.Text;

// SQL脚本代码
string sql = $"select count(1) from UserInfos where qq = '{qq}' and pwd = '{pwd}'";

// 脚本对象构造函数参数：(脚本代码字符串, 数据库对象)
SqlCommand cmd = new SqlCommand(sql, conn);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>第四步：执行脚本</li>
</ul>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 执行脚本，并调用相应方法获取指定返回值

// 如：返回脚本执行后结果的第一行第一列
int result = (int)cmd.ExecuteScalar();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>第五步：关闭数据库连接对象</li>
</ul>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">conn.Close();<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>



<h4 id="7-2-2-防SQL注入"><a href="#7-2-2-防SQL注入" class="headerlink" title="7.2.2 防SQL注入"></a>7.2.2 防SQL注入</h4><blockquote>
<p>按 《用户登录》项目输入账号<code>10001</code> ，密码不输入<code>123456</code>，而输入<code>' or 1=1 --</code>，也会成功登录，为了避免此情况发生，在c#程序中，对代码进行处理，避免SQL注入</p>
</blockquote>
<ul>
<li>首先，通过<code>SqlParameter</code>对象进行参数化</li>
</ul>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 构造函数参数为：("@数据库元素名称", 用户输入Text)

SqlParameter para1 = new SqlParameter("@qq", qq);
SqlParameter para2 = new SqlParameter("@Pwd", pwd);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>然后，在脚本对象<code>SqlCommand</code>后，对<code>SqlParameter</code>对象进行添加</li>
</ul>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">cmd.Parameters.Add(para1);
cmd.Parameters.Add(para2);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>



<h2 id="八、曲线绘制"><a href="#八、曲线绘制" class="headerlink" title="八、曲线绘制"></a>八、曲线绘制</h2><ul>
<li>使用<strong>chart</strong>控件进行曲线绘制</li>
</ul>
<h3 id="8-1-关于-chart-的一些属性"><a href="#8-1-关于-chart-的一些属性" class="headerlink" title="8.1 关于 chart 的一些属性"></a>8.1 关于 chart 的一些属性</h3><ul>
<li>假设只有一个 <code>ChartAreas</code>，即<code>ChartAreas[0]</code></li>
</ul>
<h4 id="8-1-1-坐标轴-显示范围-及-刻度间隔"><a href="#8-1-1-坐标轴-显示范围-及-刻度间隔" class="headerlink" title="8.1.1 坐标轴 显示范围 及 刻度间隔"></a>8.1.1 坐标轴 显示范围 及 刻度间隔</h4><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">chart1.ChartAreas[0].AxisY.Maximum = 45;  // 设置y轴 最大取值
chart1.ChartAreas[0].AxisY.Minimum = -5;  // 设置y轴 最小取值
chart1.ChartAreas[0].AxisY.Interval = 5;  // 设置y轴 刻度间隔

chart1.ChartAreas[0].AxisX.Maximum = 45;  // 设置x轴 最大取值
chart1.ChartAreas[0].AxisX.Minimum = -5;  // 设置x轴 最小取值
chart1.ChartAreas[0].AxisX.Interval = 5;  // 设置x轴 刻度间隔<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="8-1-2-次网格"><a href="#8-1-2-次网格" class="headerlink" title="8.1.2 次网格"></a>8.1.2 次网格</h4><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 开启y轴次网格
chart1.ChartAreas[0].AxisY.MinorGrid.Enabled = true;
// 设置次网格线条样式，dash为破折号即虚线
chart1.ChartAreas[0].AxisY.MinorGrid.LineDashStyle = ChartDashStyle.Dash;
// 设置次网格线条颜色
chart1.ChartAreas[0].AxisY.MinorGrid.LineColor = Color.DarkGray;
// 设置次网格刻度间隔
chart1.ChartAreas[0].AxisY.MinorGrid.Interval = chart1.ChartAreas[0].AxisY.Interval/2;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="8-1-3-图例"><a href="#8-1-3-图例" class="headerlink" title="8.1.3 图例"></a>8.1.3 图例</h4><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 清除图例
chart1.Legends.Clear();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<h4 id="8-1-4-条状带"><a href="#8-1-4-条状带" class="headerlink" title="8.1.4 条状带"></a>8.1.4 条状带</h4><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 实例化条状带
StripLine stripLine1 = new StripLine();
// 条状带宽
stripLine1.StripWidth = 5;
// 设置各条状带间隔，值为0，表示所有条状带重合
stripLine1.Interval = 0;
// 条状带底部起始刻度
stripLine1.IntervalOffset = 3.5;
// 条状带颜色
stripLine1.BackColor = Color.FromArgb(120, Color.Red); //alpha 120，为透明度，取值0-255 

// 将条状带添加到 ChartAreas[0] 处
chart1.ChartAreas[0].AxisY.StripLines.Add(stripLine1);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="8-1-5-数据序列-Series"><a href="#8-1-5-数据序列-Series" class="headerlink" title="8.1.5 数据序列 Series"></a>8.1.5 数据序列 Series</h4><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 设置线宽
chart1.Series[0].BorderWidth = 3;
// 设置曲线类型
chart1.Series[0].ChartType = SeriesChartType.Line;

// 添加序列
chart1.Series[0].Points.AddXY(0, 10);
chart1.Series[0].Points.AddXY(1, 20);

// 数据绑定，当 xVals,yVals 的值变化，曲线对应变化
chart1.Series[0].Points.DataBindXY(xVals,yVals);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="8-2-一些应用"><a href="#8-2-一些应用" class="headerlink" title="8.2 一些应用"></a>8.2 一些应用</h3><h4 id="8-2-1-设置-时间轴"><a href="#8-2-1-设置-时间轴" class="headerlink" title="8.2.1 设置 时间轴"></a>8.2.1 设置 时间轴</h4><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 设置轴标签样式
chart1.ChartAreas[0].AxisX.LabelStyle.Format = "HH:mm:ss";
// 设置x轴值类型为 DateTime
chart1.Series[0].XValueType = ChartValueType.DateTime;

// 使用 ToOADate() 将时间对象转换为可显示的 数值
chart1.ChartAreas[0].AxisX.Minimum = DateTime.Now.ToOADate();
// 将 x轴 显示的最大时间设置为 3分钟 后的时刻
chart1.ChartAreas[0].AxisX.Maximum = DateTime.Now.AddMinutes(3).ToOADate();

// 设置 x轴 每一刻度间隔类型
chart1.ChartAreas[0].AxisX.IntervalType = DateTimeIntervalType.Seconds;
// 设置刻度间隔为 5s
chart1.ChartAreas[0].AxisX.Interval = 5;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h2 id="九、Async-Await"><a href="#九、Async-Await" class="headerlink" title="九、Async / Await"></a>九、Async / Await</h2>
                
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="/about" rel="external nofollow noreferrer">阿淞啊</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://yijingsong.github.io/2024/01/13/shang-wei-ji/">https://yijingsong.github.io/2024/01/13/shang-wei-ji/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    许可协议。转载请注明来源
                    <a href="/about" target="_blank">阿淞啊</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            <span class="chip bg-color">无标签</span>
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
        </div>
    </div>

    

    

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2024/02/06/tensorflow-2-0/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/21.jpg" class="responsive-img" alt="Tensorflow 2.0">
                        
                        <span class="card-title">Tensorflow 2.0</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2024-02-06
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-user fa-fw"></i>
                            阿淞啊
                            
                        </span>
                    </div>
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2023/01/14/jupter-ji-anaconda-chang-yong-ming-ling/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/8.jpg" class="responsive-img" alt="Jupter及Anaconda常用命令">
                        
                        <span class="card-title">Jupter及Anaconda常用命令</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2023-01-14
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-user fa-fw"></i>
                            阿淞啊
                            
                        </span>
                    </div>
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>


  <!-- 是否加载使用自带的 prismjs. -->
  <script type="text/javascript" src="/libs/prism/prism.min.js"></script>


<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>



    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>



<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4'
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>




    <footer class="page-footer bg-color">
    

    <div class="container row center-align"
         style="margin-bottom: 15px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            
                <span id="year">2023-2024</span>
            
            <a href="/about" target="_blank">阿淞啊</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            
            <br>
            
                &nbsp;<i class="fas fa-chart-area"></i>&nbsp;站点总字数:&nbsp;<span
                        class="white-color">43.3k</span>
            
            
            
                
            
            
                <span id="busuanzi_container_site_pv">
                &nbsp;|&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;
                    <span id="busuanzi_value_site_pv" class="white-color"></span>
            </span>
            
            
            <br>

            <!-- 运行天数提醒. -->
            
                <span id="sitetime"> Loading ...</span>
                <script>
                    var calcSiteTime = function () {
                        var seconds = 1000;
                        var minutes = seconds * 60;
                        var hours = minutes * 60;
                        var days = hours * 24;
                        var years = days * 365;
                        var today = new Date();
                        var startYear = "2023";
                        var startMonth = "1";
                        var startDate = "14";
                        var startHour = "22";
                        var startMinute = "20";
                        var startSecond = "0";
                        var todayYear = today.getFullYear();
                        var todayMonth = today.getMonth() + 1;
                        var todayDate = today.getDate();
                        var todayHour = today.getHours();
                        var todayMinute = today.getMinutes();
                        var todaySecond = today.getSeconds();
                        var t1 = Date.UTC(startYear, startMonth, startDate, startHour, startMinute, startSecond);
                        var t2 = Date.UTC(todayYear, todayMonth, todayDate, todayHour, todayMinute, todaySecond);
                        var diff = t2 - t1;
                        var diffYears = Math.floor(diff / years);
                        var diffDays = Math.floor((diff / days) - diffYears * 365);

                        // 区分是否有年份.
                        var language = 'zh-CN';
                        if (startYear === String(todayYear)) {
                            document.getElementById("year").innerHTML = todayYear;
                            var daysTip = 'This site has been running for ' + diffDays + ' days';
                            if (language === 'zh-CN') {
                                daysTip = '本站已运行 ' + diffDays + ' 天';
                            } else if (language === 'zh-HK') {
                                daysTip = '本站已運行 ' + diffDays + ' 天';
                            }
                            document.getElementById("sitetime").innerHTML = daysTip;
                        } else {
                            document.getElementById("year").innerHTML = startYear + " - " + todayYear;
                            var yearsAndDaysTip = 'This site has been running for ' + diffYears + ' years and '
                                + diffDays + ' days';
                            if (language === 'zh-CN') {
                                yearsAndDaysTip = '本站已运行 ' + diffYears + ' 年 ' + diffDays + ' 天';
                            } else if (language === 'zh-HK') {
                                yearsAndDaysTip = '本站已運行 ' + diffYears + ' 年 ' + diffDays + ' 天';
                            }
                            document.getElementById("sitetime").innerHTML = yearsAndDaysTip;
                        }
                    }

                    calcSiteTime();
                </script>
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/yijingsong" class="tooltipped" target="_blank" data-tooltip="我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=1633684763" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 1633684763" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>



    <a href="mailto:1633684763@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我: 1633684763@qq.com" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>



    <a href="https://blog.csdn.net/qq_46372372" class="tooltipped" target="_blank" data-tooltip="CSDN博客: https://blog.csdn.net/qq_46372372" data-position="top" data-delay="50">
        <i class="fab fa-csdn">C</i>
    </a>



</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>

    <!-- 白天和黑夜主题 -->
<div class="stars-con">
    <div id="stars"></div>
    <div id="stars2"></div>
    <div id="stars3"></div>  
</div>

<script>
    function switchNightMode() {
        $('<div class="Cuteen_DarkSky"><div class="Cuteen_DarkPlanet"></div></div>').appendTo($('body')),
        setTimeout(function () {
            $('body').hasClass('DarkMode') 
            ? ($('body').removeClass('DarkMode'), localStorage.setItem('isDark', '0'), $('#sum-moon-icon').removeClass("fa-sun").addClass('fa-moon')) 
            : ($('body').addClass('DarkMode'), localStorage.setItem('isDark', '1'), $('#sum-moon-icon').addClass("fa-sun").removeClass('fa-moon')),
            
            setTimeout(function () {
            $('.Cuteen_DarkSky').fadeOut(1e3, function () {
                $(this).remove()
            })
            }, 2e3)
        })
    }
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    

    
    
    

    <!-- 雪花特效 -->
    

    <!-- 鼠标星星特效 -->
    

     
        <script src="https://ssl.captcha.qq.com/TCaptcha.js"></script>
        <script src="/libs/others/TencentCaptcha.js"></script>
        <button id="TencentCaptcha" data-appid="xxxxxxxxxx" data-cbfn="callback" type="button" hidden></button>
    

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

    <!--腾讯兔小巢-->
    
    

    

    

    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    
    
    <script type="text/javascript">
        //只在桌面版网页启用特效
        var windowWidth = $(window).width();
        if (windowWidth > 768) {
            document.write('<script type="text/javascript" src="/js/sakura.js"><\/script>');
        }
        </script>
                

</body>

</html>
