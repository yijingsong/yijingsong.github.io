<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>ESP32</title>
      <link href="/2024/04/02/esp32/"/>
      <url>/2024/04/02/esp32/</url>
      
        <content type="html"><![CDATA[<h2 id="一、MicroPython"><a href="#一、MicroPython" class="headerlink" title="一、MicroPython"></a>一、MicroPython</h2><h3 id="1-1-优缺点"><a href="#1-1-优缺点" class="headerlink" title="1.1 优缺点"></a>1.1 优缺点</h3><ul><li>优点<ul><li>语法跟 <strong>Python3</strong> 基本一致</li><li>解释性语言，逐条执行，可随时查看变量信息，在单片机上<strong>调试方便</strong></li><li>单片机逻辑控制越来越复杂，变化越来越多，高级脚本语言<strong>开发成本更低、迭代效率更高</strong></li><li>单片机性能越来越高，在逻辑控制时，不再斤斤计较于一点性能</li></ul></li><li>缺点<ul><li>不能对底层进行操作</li></ul></li></ul><h3 id="1-2-常用语法"><a href="#1-2-常用语法" class="headerlink" title="1.2 常用语法"></a>1.2 常用语法</h3><h4 id="1-2-1-Pin-对象"><a href="#1-2-1-Pin-对象" class="headerlink" title="1.2.1 Pin 对象"></a>1.2.1 Pin 对象</h4><h5 id="1-2-1-1-创建-Pin-​​-对象"><a href="#1-2-1-1-创建-Pin-​​-对象" class="headerlink" title="1.2.1.1 创建 $Pin$​​ 对象"></a>1.2.1.1 创建 $Pin$​​ 对象</h5><pre class="line-numbers language-python" data-language="python"><code class="language-python">'''构造函数参数取值    id : 引脚编号    mode : 输入输出方式，可选值为 Pin.IN Pin.OUT    pull : 上下拉电阻配置，可选值为 Pin.PULL_UP Pin.PULL_DOWN'''from machine import Pinp0 = Pin(id, mode, pull)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="1-2-1-2-读取电平状态"><a href="#1-2-1-2-读取电平状态" class="headerlink" title="1.2.1.2 读取电平状态"></a>1.2.1.2 读取电平状态</h5><ul><li>当 $Pin$ 对象 $mode$ 被设置为 $Pin.IN$ ，<strong>输入</strong>状态，使用<strong>获取引脚电平状态</strong></li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">p0.value() # 获取 p0 引脚电平状态，1为高电平，0为低电平<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h5 id="1-2-1-3-设置电平状态"><a href="#1-2-1-3-设置电平状态" class="headerlink" title="1.2.1.3 设置电平状态"></a>1.2.1.3 设置电平状态</h5><ul><li>当 $Pin$ 对象 $mode$ 为 $Pin.OUT$ ，<strong>输出</strong>状态，可<strong>设置引脚电平状态</strong></li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 方法一p0.value(x) # x=0低电平，x=1高电平# 方法二p0.on() # 高电平p0.off() # 低电平<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="1-2-1-4-中断"><a href="#1-2-1-4-中断" class="headerlink" title="1.2.1.4 中断"></a>1.2.1.4 中断</h5><pre class="line-numbers language-python" data-language="python"><code class="language-python"># handler : 中断执行的回调函数# trigger : 触发中断的方式 Pin.IRQ_FALLING、Pin.IRQ_RISING# Pin.IRQ_LOW_LEVEL、Pin.IRQ_HIGH_LEVEL# 注意：对于handler函数，要将对应的Pin对象传入参数表，即 def handler(p0)p0.irq(handler, trigger)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="1-2-2-time-对象"><a href="#1-2-2-time-对象" class="headerlink" title="1.2.2 time 对象"></a>1.2.2 time 对象</h4><h5 id="1-2-2-1-延时"><a href="#1-2-2-1-延时" class="headerlink" title="1.2.2.1 延时"></a>1.2.2.1 延时</h5><pre class="line-numbers language-python" data-language="python"><code class="language-python">import timetime.sleep(1) # 延时1stime.sleep_ms(500) # 延时500mstime.sleep_us(500) # 延时500us<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="1-2-2-2-时间差"><a href="#1-2-2-2-时间差" class="headerlink" title="1.2.2.2 时间差"></a>1.2.2.2 时间差</h5><pre class="line-numbers language-python" data-language="python"><code class="language-python">start = time.ticks_ms() # 获取ms计时器开始时间# 计算并获取时间差delta = time.tick_diff(time.ticks_ms(), start)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="二、ESP32开发板"><a href="#二、ESP32开发板" class="headerlink" title="二、ESP32开发板"></a>二、ESP32开发板</h2><h3 id="2-1-资源模块"><a href="#2-1-资源模块" class="headerlink" title="2.1 资源模块"></a>2.1 资源模块</h3><img src="image-20240402114631474.png" style="zoom: 50%;"><table><thead><tr><th align="center">编号</th><th align="center">模块资源</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">CH340模块：用于USB转串口与ESP32对接</td></tr><tr><td align="center">2</td><td align="center">MicroUSB接口：用于程序下载、固件升级、电源输入等</td></tr><tr><td align="center">3</td><td align="center">ESP32-WROOM-32模组</td></tr><tr><td align="center">4</td><td align="center">复位按键</td></tr><tr><td align="center">5</td><td align="center">BOOT按键</td></tr><tr><td align="center">6</td><td align="center">ESP32模组引出GPIO引脚</td></tr><tr><td align="center">7</td><td align="center">稳压芯片：将MicroUSB输入的 5V 电压转换到ESP32模组适用的 3.3V</td></tr></tbody></table><h3 id="2-2-GPIO引脚"><a href="#2-2-GPIO引脚" class="headerlink" title="2.2 GPIO引脚"></a>2.2 GPIO引脚</h3><img src="image-20240402115539271.png" style="zoom: 40%;"><ul><li>具体哪些引脚不能使用，可参考<a href="https://www.cnblogs.com/lnsane/p/13756430.html">ESP32引脚参考 - lnsane-G - 博客园 (cnblogs.com)</a>或者<a href="https://lingshunlab.com/book/esp32/esp32-pinout-reference#ESP32_%E5%BC%80%E5%8F%91%E6%9D%BF%E5%BC%95%E8%84%9A%E5%9B%BE">ESP32 – GPIO 引脚参考大全 – 凌顺实验室 (lingshunlab.com)</a></li></ul><h2 id="三、例程"><a href="#三、例程" class="headerlink" title="三、例程"></a>三、例程</h2><h3 id="3-1-LED"><a href="#3-1-LED" class="headerlink" title="3.1 LED"></a>3.1 LED</h3><h4 id="3-1-1-例程目的"><a href="#3-1-1-例程目的" class="headerlink" title="3.1.1 例程目的"></a>3.1.1 例程目的</h4><ul><li>$LED$ 流水灯</li></ul><h4 id="3-1-2-硬件电路"><a href="#3-1-2-硬件电路" class="headerlink" title="3.1.2 硬件电路"></a>3.1.2 硬件电路</h4><ul><li>硬件电路由 $LED$ 模块、$ESP32$ 、若干导线连接组成<ul><li>该 $LED$ 模块中， $RP1$ 和 $RP2$ 为限流电阻，防止电流超过二极管最大工作电流</li></ul></li></ul><img src="image-20240402163835760.png" style="zoom:33%;"><h4 id="3-1-3-实现思路"><a href="#3-1-3-实现思路" class="headerlink" title="3.1.3 实现思路"></a>3.1.3 实现思路</h4><ul><li>实现思路：使用 $ESP32 \quad GPIO$ 接入 $J1$ 端子，使引脚输出高低电平，以实现对 $LED$ 亮灭的控制</li></ul><h4 id="3-1-4-实现代码"><a href="#3-1-4-实现代码" class="headerlink" title="3.1.4 实现代码"></a>3.1.4 实现代码</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python">from machine import Pinimport timeids = [15, 2, 0, 4, 16, 17, 5, 18] # 使用的GPIO引脚编号leds = [] # 存储控制LED的Pin引脚对象for id in ids:    leds.append(Pin(id, Pin.OUT))# leds 依次亮/灭def ledOnOrOff(ledValue, sleepTime):    for led in leds:        led.value(ledValue)        time.sleep_ms(sleepTime)if __name__ == "__main__":    time.sleep(2)    # 流水灯    while True:        ledOnOrOff(ledValue = 1, sleepTime = 50)        ledOnOrOff(ledValue = 0, sleepTime = 50)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-2-蜂鸣器"><a href="#3-2-蜂鸣器" class="headerlink" title="3.2 蜂鸣器"></a>3.2 蜂鸣器</h3><ul><li><strong>有源</strong>蜂鸣器：与 $LED$ 类似，<strong>通电</strong>就会发出声音</li><li><strong>无源</strong>蜂鸣器：需要<strong>一定频率的脉冲</strong>才能发出声音，即需要 $GPIO$ 引脚周期性输出高低电平<ul><li>最佳发声频率在 $1.5KHz - 5KHz$</li><li>改变脉冲信号的<strong>频率和占空比</strong>可改变声音的音调和音量</li></ul></li></ul><h4 id="3-2-1-例程目的"><a href="#3-2-1-例程目的" class="headerlink" title="3.2.1 例程目的"></a>3.2.1 例程目的</h4><ul><li>控制板载无源蜂鸣器音调由低到高</li></ul><h4 id="3-2-2-硬件电路"><a href="#3-2-2-硬件电路" class="headerlink" title="3.2.2 硬件电路"></a>3.2.2 硬件电路</h4><ul><li>硬件电路由蜂鸣器模块、$ESP32$​ 、若干导线连接组成<ul><li>对于蜂鸣器，如果直接使用 $GPIO$ 进行控制，对电流的消耗较大，可能就会导致其他的外设资源得到的电流较小不能正常工作，所以<strong>一般对于功率较大的外设，都会增加一个驱动电路</strong>。这里蜂鸣器使用的驱动电路是 $ULN2003D$ 电机模块</li><li>对于 $ULN2003D$ ，输入引脚输入高电平，对应输出引脚输出低电平；输入低电平，输出高阻态，当输出端接了上拉电阻，输出端为高电平</li></ul></li></ul><img src="image-20240402201445978.png" style="zoom: 45%;"><h4 id="3-2-3-实现思路"><a href="#3-2-3-实现思路" class="headerlink" title="3.2.3 实现思路"></a>3.2.3 实现思路</h4><ul><li>将 $GPIO$ 接入 $J2$ 端子 $BEEP$ 引脚，通过控制该 $GPIO$ 输出高低电平实现蜂鸣器发声</li></ul><h4 id="3-2-4-实现代码"><a href="#3-2-4-实现代码" class="headerlink" title="3.2.4 实现代码"></a>3.2.4 实现代码</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python">from machine import Pinimport timebeep = Pin(15, Pin.OUT) # 控制蜂鸣器引脚# 蜂鸣器发声，参数表(高电平所占时间ms，一个周期电平时长ms，发声时长ms)def beepVoice(highTime = 250, periodTime = 500, beepTime = 1000):    start = time.ticks_ms()    while True:        delta = time.ticks_ms() - start # 获取时间差        if (delta &lt;= beepTime):            # 脉冲频率：1s / (periodTime us)，默认周期电平时长500us，即频率2KHz            # 占空比：highTime / periodTime ,默认为50%             beep.value(1)            time.sleep_us(highTime)            beep.value(0)            time.sleep_us(periodTime - highTime)        else:        returnif __name__ == "__main__":    highTimes = range(50, 500, 50) # 高电平时长    beepTimes = [1000 for _ in range(len(highTimes))] # 发声时长        for highTime, beepTime in zip(highTimes, beepTimes):        beepVoice(highTime = highTime, beepTime = beepTime)    <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-3-直流电机"><a href="#3-3-直流电机" class="headerlink" title="3.3 直流电机"></a>3.3 直流电机</h3><ul><li>两引脚没有正负之分（由于扇叶本身结构，扇叶煽动的气流走向会随电机正反转发生同步反转），通电就开始工作，工作原理图如下</li></ul><img src="image-20240402210907142.png" style="zoom: 60%;"><ul><li>在允许范围内，电压越大转速越快，可用 $PWM$ 进行调速</li></ul><h4 id="3-3-1-例程目的"><a href="#3-3-1-例程目的" class="headerlink" title="3.3.1 例程目的"></a>3.3.1 例程目的</h4><ul><li>控制直流电机逐渐加速旋转</li></ul><h4 id="3-3-2-硬件电路"><a href="#3-3-2-硬件电路" class="headerlink" title="3.3.2 硬件电路"></a>3.3.2 硬件电路</h4><ul><li>硬件电路由 $5V$ 直流电机、$ULN2003D$ 电机驱动模块、$ESP32$​ 、若干导线连接组成<ul><li>与蜂鸣器一样，$5V$ 直流电机电流消耗较大，所以使用驱动模块进行驱动</li></ul></li></ul><img src="image-20240402211436758.png" style="zoom:40%;"><h4 id="3-3-3-实现思路"><a href="#3-3-3-实现思路" class="headerlink" title="3.3.3 实现思路"></a>3.3.3 实现思路</h4><ul><li>直流电机一端接 $J5$ 端子 $VCC$ 引脚，另一端接一个 $J5$ 端子的 $OUT$ 引脚，对应该引脚，将 $GPIO$ 引脚接到 $J3$ 端子的引脚。由于电机有一端接入了 $5V$ 电压，所以 $J5$ 的 $OUT$ 引脚应该输入低电平，也即 $ULN2003D$ 驱动对应引脚要输入高电平，即可实现对电机的控制</li><li>为避免线路连接好电机就转动，根据 $ULN2003D$ 输入输出特性、电机一端已经接入了 $5V$ 电压、电机未接上拉电阻，所以得让 $J5$ 端子 $OUT$ 引脚置为高阻态，即线路的入口 $GPIO$ 配置为下拉状态 $Pin.PULL_DOWN$ 保证输入为低电平</li><li>对于转速，控制 $GPIO$ 输出的电压占空比即可实现转速的调节</li></ul><h4 id="3-3-4-实现代码"><a href="#3-3-4-实现代码" class="headerlink" title="3.3.4 实现代码"></a>3.3.4 实现代码</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python">from machine import Pinimport timemotor = Pin(15, Pin.OUT, Pin.PULL_DOWN)# 套用蜂鸣器函数 beepVoice()def motorSpeed(highTime = 250, periodTime = 500, motorTime = 2000):    start = time.ticks_ms()    while True:        delta = time.ticks_ms() - start        if (delta &lt;= motorTime):            motor.value(1)            time.sleep_us(highTime)            motor.value(0)            time.sleep_us(periodTime - highTime)        else:        returnif __name__ == "__main__":    highTimes = range(300, 550, 50) # 测试发现5V直流电机，以50为步长，占空比至少得为60%才能启动      for highTime in highTimes:        motorSpeed(highTime)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-4-按键开关"><a href="#3-4-按键开关" class="headerlink" title="3.4 按键开关"></a>3.4 按键开关</h3><ul><li>按下后松开手指，按键会自动抬起，机械开关在按下抬起过程中均有一个<strong>抖动</strong>的情况</li></ul><img src="image-20240406101941839.png" style="zoom:40%;"><ul><li><strong>消抖</strong>，过滤震荡波<ul><li>硬件消抖，接入一个 $RC$ 电路</li><li>软件滤波，通过在程序中<strong>延时，跳过震荡波</strong></li></ul></li></ul><h4 id="3-4-1-例程目的"><a href="#3-4-1-例程目的" class="headerlink" title="3.4.1 例程目的"></a>3.4.1 例程目的</h4><ul><li>按键控制直流电机加速、减速、开启、停止，理解 $Pin.IN$</li></ul><h4 id="3-4-2-硬件电路"><a href="#3-4-2-硬件电路" class="headerlink" title="3.4.2 硬件电路"></a>3.4.2 硬件电路</h4><ul><li>硬件电路由按键模块、 $5V$ 直流电机、$ULN2003D$ 电机驱动模块、$ESP32$​​、若干导线组成<ul><li>其中按键模块电路及电机驱动模块分别如下</li></ul></li></ul><p><img src="image-20240406103335320.png" style="zoom:40%;"><img src="image-20240402211436758.png" style="zoom:40%;"></p><h4 id="3-4-3-实现思路"><a href="#3-4-3-实现思路" class="headerlink" title="3.4.3 实现思路"></a>3.4.3 实现思路</h4><ul><li>配置 $4$ 个 $GPIO \quad mode$ 为 $Pin.IN$ ，以监听开关按键是否被按下</li><li>配置 $1$ 个 $GPIO \quad mode$ 为 $Pin.OUT$ ，对直流电机进行启停加减速控制</li></ul><h4 id="3-4-4-实现代码"><a href="#3-4-4-实现代码" class="headerlink" title="3.4.4 实现代码"></a>3.4.4 实现代码</h4><ul><li><strong>button.py</strong></li><li>监测按键状态</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">from machine import Pinimport timeclass ButtonScan:    keys_ID = [] # 存放按键引脚编号    keys = [] # 存放按键对象    flag = 1 # 标记按键开关状态    # 获取按键引脚    def __init__(self, keys_ID):        self.keys_ID = keys_ID                for key_ID in self.keys_ID:            self.keys.append(Pin(key_ID, Pin.IN, Pin.PULL_UP)) # 因为按键接地，所有Pin.IN引脚设置默认状态为上拉高电平                    self.flag = 1;        # 获取按键按下信息    def getKey(self):        # 当flag为1，有任一开关被按下，获取该开关引脚对象        if self.flag == 1 and any(key.value() == 0 for key in self.keys):            time.sleep_ms(10)            self.flag = 0            for index, key in enumerate(self.keys):                if key.value() == 0:                    return index                # 当所有开关都弹起的时候，置flag为1，等待下次开关按下        elif all(key.value() == 1 for key in self.keys):            self.flag = 1                return Noneif __name__ == "__main__":    keys_ID = [14, 27, 26]    demo = ButtonScan(keys_ID)    print(demo.keys_ID)    motor = Pin(15, Pin.OUT)    while True:        k = demo.getKey()        if k != None:            if keys_ID[k] == 14:                motor.value(1)                            elif keys_ID[k] == 27:                motor.value(0)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><strong>main.py</strong></li><li>导入 $button.py$ 中的 $ButtonScan$ 类，进行按键监测并控制电机的启停加减速</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">from machine import Pinimport timefrom buttons import ButtonScanmotor = Pin(15, Pin.OUT, Pin.PULL_DOWN) # 直流电机引脚keys_ID = [14, 27, 26, 25] # 按键引脚编号highTime = 300 # 加减速默认开始脉冲时长300ms，周期为500ms，占空比60%# 设定占空比以调节转速def motorSpeed(highTime = 250, periodTime = 500, motorTime = 3000):    start = time.ticks_ms()    while True:        delta = time.ticks_ms() - start        if (delta &lt;= motorTime):            motor.value(1)            time.sleep_us(highTime)            motor.value(0)            time.sleep_us(periodTime - highTime)        else:        return    def keyFunc(k):    global highTime    if keys_ID[k] == 14:        print(highTime)        motorSpeed(highTime)        highTime += 50        if highTime &gt; 500:            highTime =  500                    elif keys_ID[k] == 27:        print(highTime)        motorSpeed(highTime)        highTime -= 50        if highTime &lt; 300:            highTime =  300                elif keys_ID[k] == 26:        motor.value(1)            elif keys_ID[k] == 25:        motor.value(0)if __name__ == "__main__":    demo = ButtonScan(keys_ID)    while True:        k = demo.getKey()        if k != None:            keyFunc(k)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-5-步进电机"><a href="#3-5-步进电机" class="headerlink" title="3.5 步进电机"></a>3.5 步进电机</h3><ul><li>将电脉冲信号转换为角位移/线位移，是一种开环控制元件</li><li>工作原理</li></ul><img src="image-20240406161306236.png" style="zoom:40%;"><ul><li>$28BYJ48$​ 五相四线步进电机工作参数<ul><li>重点关注电压、步进角度、减速比</li></ul></li></ul><img src="image-20240406161507226.png" style="zoom: 40%;"><h4 id="3-5-1-例程目的"><a href="#3-5-1-例程目的" class="headerlink" title="3.5.1 例程目的"></a>3.5.1 例程目的</h4><ul><li>按键控制 $28BYJ48$ 步进电机加速减速正反转停止</li></ul><h4 id="3-5-2-硬件电路"><a href="#3-5-2-硬件电路" class="headerlink" title="3.5.2 硬件电路"></a>3.5.2 硬件电路</h4><ul><li>五相四线步进电机 $28BYJ48$ 、$ULN2003$ 驱动模块、按键模块、$ESP32$​ 、杜邦线若干</li></ul><p><img src="image-20240402211436758.png" style="zoom:40%;"><img src="image-20240406103335320.png" style="zoom:40%;"></p><h4 id="3-5-3-实现思路"><a href="#3-5-3-实现思路" class="headerlink" title="3.5.3 实现思路"></a>3.5.3 实现思路</h4><ul><li><p>将 $28BYJ48$ 接到 $J5$  端子上</p></li><li><p>使用 $buttons.py$ 中的 $ButtonScan$ 获取按键信息，进而实现启停正反转加减速的控制</p></li></ul><h4 id="3-5-4-实现代码"><a href="#3-5-4-实现代码" class="headerlink" title="3.5.4 实现代码"></a>3.5.4 实现代码</h4><ul><li>调用 $ButtonScan$ 对象</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">from machine import Pinimport timefrom buttons import ButtonScanmotorIDs = [15, 2, 0, 4] # 步进电机引脚编号motor = [] # 存储步进电机引脚对象for motorID in motorIDs:    motor.append(Pin(motorID, Pin.OUT, Pin.PULL_DOWN))    keys_ID = [14, 27, 26, 25] # 按键编号speed = 1 # 延时ms，延时越短速度越快，反之越慢，speed取值设置为1-5speed_min = 1speed_max = 5# 步进电机旋转步序 turns = [[1,0,0,0],         [1,1,0,0],         [0,1,0,0],         [0,1,1,0],         [0,0,1,0],         [0,0,1,1],         [0,0,0,1],         [1,0,0,1]]# 设定步进电机正反转加减速def keyFunc(direc, speed):    for turn in turns[::direc]:        for i in range(4):            motor[i].value(turn[i])        time.sleep_ms(speed)if __name__ == "__main__":    demo = ButtonScan(keys_ID)    k = None    direc = 1    speed = 1    on = False    while True:        k = demo.getKey() # 返回按键索引值        if k != None:            # 正反转            if keys_ID[k] == 14:                direc = 1                on = not on            elif keys_ID[k] == 27:                direc = -1                on = not on                        # 加减速            elif keys_ID[k] == 26:                speed += 1                if speed &gt; speed_max:                    speed = speed_max                            elif keys_ID[k] == 25:                speed -= 1                if speed &lt; speed_min:                    speed = speed_min        if on: # 开启步进电机，执行旋转步序            keyFunc(direc, speed)         <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-6-中断"><a href="#3-6-中断" class="headerlink" title="3.6 中断"></a>3.6 中断</h3><ul><li>外部中断：上升沿、下降沿、低电平、高电平触发模式</li></ul><img src="./ESP32/image-20240407214859477.png" alt="image-20240407214859477" style="zoom:40%;"><ul><li>定时器中断</li></ul><h4 id="3-6-1-例程目的"><a href="#3-6-1-例程目的" class="headerlink" title="3.6.1 例程目的"></a>3.6.1 例程目的</h4><h4 id="3-6-2-硬件电路"><a href="#3-6-2-硬件电路" class="headerlink" title="3.6.2 硬件电路"></a>3.6.2 硬件电路</h4><h4 id="3-6-3-实现思路"><a href="#3-6-3-实现思路" class="headerlink" title="3.6.3 实现思路"></a>3.6.3 实现思路</h4><h4 id="3-6-4-实现代码"><a href="#3-6-4-实现代码" class="headerlink" title="3.6.4 实现代码"></a>3.6.4 实现代码</h4>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>机器学习</title>
      <link href="/2024/04/01/ji-qi-xue-xi/"/>
      <url>/2024/04/01/ji-qi-xue-xi/</url>
      
        <content type="html"><![CDATA[<h2 id="一、数据简介"><a href="#一、数据简介" class="headerlink" title="一、数据简介"></a>一、数据简介</h2><ul><li><p>在数据集中：</p><ul><li><p>一行数据称为一个样本</p></li><li><p>一列数据称为一个特征</p></li><li><p>有些数据有目标值（标签值）</p></li></ul></li><li><p>数据类型构成：</p><ul><li><p>数据类型一：特征值+目标值（目标值是连续或离散的）</p></li><li><p>数据类型二：只有特征值，没有目标值</p></li></ul></li><li><p>数据分割：</p><ul><li>一般将数据集划分为两类：<ul><li>训练数据：用于训练，构建模型</li><li>测试数据：在检验模型时使用，用于评估模型是否有效</li></ul></li><li>划分比例<ul><li>训练集：70%  80%  75%</li><li>测试集：30%  20%  25%</li></ul></li></ul></li></ul><hr><h2 id="二、数据基本处理："><a href="#二、数据基本处理：" class="headerlink" title="二、数据基本处理："></a>二、数据基本处理：</h2><ul><li>对缺失值、去除异常值等处理</li></ul><hr><h2 id="三、特征工程"><a href="#三、特征工程" class="headerlink" title="三、特征工程"></a>三、特征工程</h2><h3 id="3-1-什么是特征工程？"><a href="#3-1-什么是特征工程？" class="headerlink" title="3.1 什么是特征工程？"></a>3.1 什么是特征工程？</h3><p>使用专业背景知识和技巧处理数据，使得特征能在机器学习算法上发挥更好作用的过程</p><ul><li>意义：会直接影响机器学习的效果</li></ul><h3 id="3-2-为什么需要特征工程？"><a href="#3-2-为什么需要特征工程？" class="headerlink" title="3.2 为什么需要特征工程？"></a>3.2 为什么需要特征工程？</h3><p>数据和特征决定了机器学习的上限，而模型和算法只是逼近这个上限</p><h3 id="3-3-特征工程包含内容"><a href="#3-3-特征工程包含内容" class="headerlink" title="3.3 特征工程包含内容"></a>3.3 特征工程包含内容</h3><ul><li>特征提取</li><li>特征预处理</li><li>特征降维</li></ul><h4 id="3-3-1-特征提取"><a href="#3-3-1-特征提取" class="headerlink" title="3.3.1 特征提取"></a>3.3.1 特征提取</h4><p>将<strong>任意数据</strong>（如文本图像）转换为可用于机器学习的<strong>数字特征</strong></p><h4 id="3-3-2-特征预处理"><a href="#3-3-2-特征预处理" class="headerlink" title="3.3. 2 特征预处理"></a>3.3. 2 特征预处理</h4><p>通过一些<strong>转换函数</strong>将特征数据转换成更加符合算法模型的特征数据过程</p><h4 id="3-3-3-特征降维"><a href="#3-3-3-特征降维" class="headerlink" title="3.3.3 特征降维"></a>3.3.3 特征降维</h4><p>在某些限定条件下，<strong>降低随机变量（特征）个数</strong>，得到一组“不相关”主变量的过程</p><hr><h2 id="四、机器学习"><a href="#四、机器学习" class="headerlink" title="四、机器学习"></a>四、机器学习</h2><h3 id="4-1-监督学习"><a href="#4-1-监督学习" class="headerlink" title="4.1 监督学习"></a>4.1 监督学习</h3><ul><li>定义：<ul><li>输入数据是由特征值和目标值组成的<ul><li>输出是一个连续的值（<strong>回归</strong>）</li><li>输出是有限个离散值（<strong>分类</strong>）</li></ul></li><li>分类：k-近邻算法、贝叶斯分类、决策树与随机森林、逻辑回归、神经网络</li><li>回归：线性回归、岭回归</li></ul></li></ul><h3 id="4-2-无监督学习"><a href="#4-2-无监督学习" class="headerlink" title="4.2 无监督学习"></a>4.2 无监督学习</h3><ul><li>定义：<ul><li><p>输入数据是由特征值组成</p></li><li><p>输入数据没有被标记，也没有确定结果。样本数据类别未知，需要根据样本间的相似性对样本集进行分类（<strong>聚类</strong>，clustering），试图使类内间距最小化，类间差距最大化。</p></li><li><p>聚类：k-means、降维</p></li></ul></li></ul><p></p><h3 id="4-3-半监督学习"><a href="#4-3-半监督学习" class="headerlink" title="4.3 半监督学习"></a>4.3 半监督学习</h3><ul><li>定义：<ul><li>输入数据有特征值，一部分有目标值，一部分没有目标值</li></ul></li></ul><h3 id="4-4-强化学习"><a href="#4-4-强化学习" class="headerlink" title="4.4 强化学习"></a>4.4 强化学习</h3><ul><li>定义：<ul><li><p>自动进行决策，并可以做连续决策</p></li><li><p>动态过程，上一步数据的输出是下一步数据的输入</p></li><li><p>四要素：agent、环境状态、行动、奖励</p></li><li><p>算法：马尔科夫决策、动态规划</p></li></ul></li></ul><hr><h2 id="五、模型评估"><a href="#五、模型评估" class="headerlink" title="五、模型评估"></a>五、模型评估</h2><p>模型评估有助于表达数据的最佳模型和所选模型将来工作的性能如何，按照数据集的目标值不同，可以把模型评估分为分类模型评估和回归模型评估</p><h3 id="5-1分类模型评估"><a href="#5-1分类模型评估" class="headerlink" title="5.1分类模型评估"></a>5.1分类模型评估</h3><ul><li>准确率<ul><li>预测正确的数占样本总数的比例</li></ul></li><li>精确率<ul><li>正确预测为正占<strong>全部预测为正</strong>的比例</li></ul></li><li>召回率<ul><li>正确预测为正占<strong>全部正样本</strong>的比例</li></ul></li><li>F1-score<ul><li>主要用于评估模型的稳健性</li></ul></li><li>AUC指标<ul><li>主要用于评估样本不均衡的情况</li></ul></li></ul><h3 id="5-2-回归模型评估"><a href="#5-2-回归模型评估" class="headerlink" title="5.2 回归模型评估"></a>5.2 回归模型评估</h3><ul><li><p>均方根误差（Root Mean Squared Error, RMSE）</p><ul><li>衡量回归模型误差率的常用公式，但它仅能比较误差是相同单位的模型</li><li>$$RMSE=\sqrt{\frac{\sum\limits_{i=0}^n(p_i-a_i)^2}{n}}$$, $a_i$为实际值，$p_i$为预测值</li></ul></li><li><p>相对平方误差（Relative Squared Error，RSE）</p><ul><li>与RMSE不同，RSE可以比较误差是不同单位的模型</li><li>$$RSE=\frac{\sum\limits_{i=1}^{n}(p_i-a_i)^2}{\sum\limits_{i=1}^{n}(\bar{a}-a_i)^2}$$</li></ul></li><li><p>平均绝对误差（Mean Absolute Error，MAE）</p><ul><li><p>与RMSE类似，仅能比较误差是相同单位的模型，但是误差值相对小一点</p></li><li><p>$$MAE=\frac{\sum\limits_{i=1}^{n}\lvert p_i-a_i \rvert}{n}$$</p></li></ul></li><li><p>相对绝对误差（Relative Absolute Error，RAE）</p><ul><li>可比较误差是不同单位的模型</li><li>$$MAE=\frac{\sum\limits_{i=1}^{n}\lvert p_i-a_i \rvert}{\sum\limits_{i=1}^{n}\lvert \bar{a}-a_i \rvert}$$</li></ul></li><li><p>决定系数（Coefficient of Determination）</p><ul><li>$R^2$汇总了回归模型的解释度，由平方和计算而得，描述回归模型所解释的因变量方差在总方差中的比例。$R^2$越大，自变量与因变量之间存在线性关系</li><li>$R^2=1-\frac{\sum\limits_{i=1}^{n}(p_i-a_i)^2}{\sum\limits_{i=1}^{n}(\bar{a}-a_i)^2}$</li></ul></li></ul><h3 id="5-3-拟合"><a href="#5-3-拟合" class="headerlink" title="5.3 拟合"></a>5.3 拟合</h3><p>用于评价训练好的模型的表现效果</p><h4 id="5-3-1-欠拟合"><a href="#5-3-1-欠拟合" class="headerlink" title="5.3.1 欠拟合"></a>5.3.1 欠拟合</h4><p>学到的特征太少了，导致区分标准太粗糙，不能进行较为准确的识别</p><img src="image-20230420173200827.png" style="zoom:50%;"><h4 id="5-3-2-过拟合"><a href="#5-3-2-过拟合" class="headerlink" title="5.3.2 过拟合"></a>5.3.2 过拟合</h4><p>模型在训练集表现优越，而在验证集和测试集表现不佳。学的特征太多了</p><img src="image-20230420173103779.png" style="zoom:50%;"><hr><h2 id="六、分类算法"><a href="#六、分类算法" class="headerlink" title="六、分类算法"></a>六、分类算法</h2><h3 id="6-1-k近邻（KNN）算法"><a href="#6-1-k近邻（KNN）算法" class="headerlink" title="6.1 k近邻（KNN）算法"></a>6.1 k近邻（KNN）算法</h3><p>通过你的“邻居”，来判断你的类别</p><h4 id="6-1-1-k-近邻算法概念"><a href="#6-1-1-k-近邻算法概念" class="headerlink" title="6.1.1 k-近邻算法概念"></a>6.1.1 k-近邻算法概念</h4><p>K Nearest Neighbor算法又称KNN算法</p><ul><li><p>定义</p><ul><li>如果一个样本在特征空间中的k个最相似（特征空间中的最近邻）的样本中的大多数属于一个类别，则该样本也属于这个类别</li></ul></li><li><p>应用场景</p><ul><li>字符识别</li><li>文本分类</li><li>图像识别</li></ul></li><li><p>距离公式</p><ul><li>一般使用欧氏距离<ul><li>n维空间点$a(x_{11},x_{12},\dots,x_{1n})$到$b(x_{21},x_{21},\dots,x_{2n})$的欧式距离为$$d_{12}=\sqrt{\sum\limits_{k=1}^{n}(x_{1k}-x_{2k})^2}$$</li></ul></li></ul></li></ul><h4 id="6-1-2-k-近邻算法流程"><a href="#6-1-2-k-近邻算法流程" class="headerlink" title="6.1.2 k-近邻算法流程"></a>6.1.2 k-近邻算法流程</h4><p>假设有几部电影数据，要推测《唐人街探案》的电影类型</p><img src="image-20230420182035231.png" style="zoom:50%;"><ul><li>首先计算《唐人街探案》与每部电影的距离<ul><li>如《唐人街探案》与《二次曝光》，$d=\sqrt{(23-2)^2+(3-3)^2+(17-55)^2}=43.42$</li></ul></li></ul><img src="image-20230420182613887.png" style="zoom:50%;"><ul><li>指定k的取值，此处取k=5。对计算结果进行排序，取出找出距离最近的5部电影</li></ul><img src="image-20230420182715728.png" style="zoom:50%;"><ul><li>根据k近邻，统计各类别出现频率，取频率最高的类别作为《唐人街探案》电影类型<ul><li>当k=5时，《唐人街探案》的近邻分别为《功夫熊猫》、《代理情人》、《新步步惊心》、《美人鱼》、《宝贝当家》。其中喜剧片有3部，爱情片2部</li><li>所以，推测《唐人街探案》为喜剧片</li></ul></li></ul><h4 id="6-1-3-k-近邻API"><a href="#6-1-3-k-近邻API" class="headerlink" title="6.1.3 k-近邻API"></a>6.1.3 k-近邻API</h4><ul><li>sklearn.neighbors.KNeighborsClassifier(n_neighbors=5)<ul><li>n_neighbors：int，可选（默认5），k_neighbors查询默认使用的邻居数</li></ul></li></ul><h4 id="6-1-4-代码过程"><a href="#6-1-4-代码过程" class="headerlink" title="6.1.4 代码过程"></a>6.1.4 代码过程</h4><p>以前文电影类型预测为例</p><ul><li>导入模块</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">from sklearn.neighbors import KNeighborsClassifier<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>构造数据集</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">x=[[39,0,31],[3,2,65],[2,3,55],[9,38,2],[8,34,17],[5,2,57],[21,17,5],[45,2,9]]y=['喜剧片','动作片','爱情片','爱情片','爱情片','动作片','喜剧片','喜剧片']<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>模型训练</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 实例化APIestimator=KNeighborsClassifier(n_neighbors=5)# 使用fit方法进行训练estimator.fit(x,y)# 进行预测estimator.predict([[23,3,17]])<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="6-1-5-距离度量"><a href="#6-1-5-距离度量" class="headerlink" title="6.1.5 距离度量"></a>6.1.5 距离度量</h4><ul><li><p><strong>欧式距离</strong></p><ul><li><strong>直线距离</strong></li><li>n维空间点$a(x_{11},x_{12},\dots,x_{1n})$到$b(x_{21},x_{21},\dots,x_{2n})$的欧式距离为$$d_{12}=\sqrt{\sum\limits_{k=1}^{n}(x_{1k}-x_{2k})^2}$$</li></ul></li><li><p><strong>曼哈顿距离</strong></p><ul><li>也称  城市街区距离（City Block Distance）</li><li>是从一个地点驾车到另一个地点所行驶过的距离</li><li><strong>水平+竖直距离</strong></li><li>n维空间点$a(x_{11},x_{12},\dots,x_{1n})$到$b(x_{21},x_{21},\dots,x_{2n})$的曼哈顿距离为$d_{12}=\sum\limits_{k=1}^{n}\lvert x_{1k}-x_{2k} \rvert$</li></ul></li><li><p><strong>切比雪夫距离</strong>（Chebyshev Distance）</p><ul><li><strong>八邻域</strong>方向，行走到目标点的最短距离</li><li>n维空间点$a(x_{11},x_{12},\dots,x_{1n})$到$b(x_{21},x_{21},\dots,x_{2n})$的切比雪夫距离为$d_{12}=max(\lvert x_{1k}-x_{2k} \rvert)$</li></ul></li><li><p><strong>闵可夫斯基距离</strong>（Minkowski Distance）</p><ul><li>闵氏距离不是一种距离，而是一组距离的定义，是对多个距离度量公式的概括性的表述</li><li>n维空间点$a(x_{11},x_{12},\dots,x_{1n})$到$b(x_{21},x_{21},\dots,x_{2n})$的闵可夫斯基距离为$$d_{12}=\sqrt[p]{\sum\limits_{k=1}^{n}\lvert x_{1k}-x_{2k} \rvert^p}$$</li><li>公式中，p是一个参数<ul><li>当p=1时，就是曼哈顿距离</li><li>当p=2时，就是欧式距离</li><li>当$p\rightarrow\infty$时，就是切比雪夫距离</li></ul></li></ul></li><li><p>闵氏距离，包括欧氏距离、曼哈顿距离、切比雪夫距离都有着共同的<strong>缺点</strong>：</p><ul><li>将各个分量的量纲，即<strong>单位都相同看待</strong>了</li><li>未考虑各个分量的<strong>分布（期望、方差等）可能是不同</strong>的</li></ul></li><li><p><strong>标准化欧氏距离</strong>（Standardized Euclidean Distance）</p><ul><li>针对欧式距离的缺点进行的一种改进</li><li>思路：既然各个分量的分布单位不一样，那先将各个分量都<strong>标准化</strong>到均值、方差相等。</li><li>假设样本集X的均值为m，标准差为s，那么X的标准化变量变量可表示为：$X^*=\frac{X-m}{s}$</li><li>那么标准化欧氏距离：$d_{12}=\sqrt{\sum\limits_{k=1}^{n}(\frac{x_{1k}-x_{2k}}{s_k})^2}$</li><li>若将方差的倒数看成一个权重，也称之为加权欧氏距离</li></ul></li><li><p><strong>余弦距离</strong>（Cosine Distance）</p><ul><li><p>几何中，夹角余弦可用来衡量两个向量方向的差异</p></li><li><p>机器学习中，用来衡量样本向量间的差异</p></li><li><p>二维空间中向量$A(x_1,y_1)$和$B(x_2,y_2)$的夹角余弦公式：$cos\theta=\frac{x_1x_2+y_1y_2}{\sqrt{x_1^2+y_1^2} \sqrt{x_2^2+y_2^2}}$</p></li><li><p>两个n维样本点$a(x_{11},x_{12},\dots,x_{1n})$到$b(x_{21},x_{21},\dots,x_{2n})$的夹角余弦为：$cos\theta=\frac{a \cdot b}{\lvert a \rvert \vert b \rvert}$，即$cos\theta=\frac{\sum\limits_{k=1}^{n}x_{1k}x_{2k}}{\sqrt{\sum\limits_{k=1}^{n}x_{1k}^2}\sqrt{\sum\limits_{k=1}^{n}x_{2k}^2}}$</p></li><li><p>夹角余弦的取值范围为$[-1,1]$。余弦越大两个向量夹角越小，反之亦然。当两个向量的方向重合时，余弦取最大值1，完全相反时取最小值-1</p></li></ul></li><li><p><strong>汉明距离</strong></p><ul><li>一个字符串，变到另一个字符串，需要做的最小替换次数</li><li>编码解码可能会用到</li></ul></li><li><p><strong>杰卡德距离</strong></p><ul><li>通过交并集进行计算</li></ul></li><li><p><strong>马氏距离</strong></p><ul><li>通过样本分布进行计算</li><li>与量纲无关</li><li>计算建立在总体样本上</li><li>要求总体样本数大于样本的维数</li></ul></li></ul><h4 id="6-1-6-k值的选取"><a href="#6-1-6-k值的选取" class="headerlink" title="6.1.6 k值的选取"></a>6.1.6 k值的选取</h4><ul><li>k太小，容易受到异常点的影响，易发生过拟合</li><li>k太大，受样本均衡的影响，易发生欠拟合</li></ul><p><strong>近似误差</strong>：关注训练集，在训练集的训练误差，对未知测试样本会出现较大的偏差，类似于过拟合</p><p><strong>估计误差</strong>：关注测试集，对测试集的测试误差，估计误差越小，对未知数据的预测能力越好</p><ul><li>选择较小的k值，会让近似误差减小，估计误差会增大</li><li>选择较大的k值，会让近似误差增大，估计误差减小，k的增大意味着模型变得简单</li></ul><h3 id="6-2-kd树"><a href="#6-2-kd树" class="headerlink" title="6.2 kd树"></a>6.2 kd树</h3><h4 id="6-2-1-kd树简介"><a href="#6-2-1-kd树简介" class="headerlink" title="6.2.1 kd树简介"></a>6.2.1 kd树简介</h4><ul><li><p>由于k近邻算法每次预测一个点时，都会计算该点到训练集所有点的距离<strong>（穷举搜索）</strong>，然后选出距离最近的k个点进行投票。当数据集很大时，假设有N个样本，D个特征，那么其算法复杂度为$O(DN^2)$。</p></li><li><p>为了避免每次预测都重新计算一次距离，kd树将<strong>距离信息保存在一棵树</strong>里，在计算之前查询距离信息，尽量避免重新计算。这样优化后的算法复杂度可降到$O(DN log(N))$。</p></li><li><p><strong>如果A和B距离很远，B和C距离很近，那么A和C距离也很远</strong>。</p></li></ul><h4 id="6-2-2-kd树原理"><a href="#6-2-2-kd树原理" class="headerlink" title="6.2.2 kd树原理"></a>6.2.2 kd树原理</h4>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>机器视觉</title>
      <link href="/2024/04/01/ji-qi-shi-jue/"/>
      <url>/2024/04/01/ji-qi-shi-jue/</url>
      
        <content type="html"><![CDATA[<h2 id="一、图像预处理-图像增强"><a href="#一、图像预处理-图像增强" class="headerlink" title="一、图像预处理(图像增强)"></a>一、图像预处理(图像增强)</h2><h3 id="1-1-RGB转Gray"><a href="#1-1-RGB转Gray" class="headerlink" title="1.1 RGB转Gray"></a>1.1 RGB转Gray</h3><p>$Gray=R \times 0.3+G \times 0.59+B \times 0.11$</p><h3 id="1-2-图像处理方法概述"><a href="#1-2-图像处理方法概述" class="headerlink" title="1.2 图像处理方法概述"></a>1.2 图像处理方法概述</h3><img src="image-20230711155659517.png" style="zoom:25%;"><h3 id="1-3-均衡化"><a href="#1-3-均衡化" class="headerlink" title="1.3 均衡化"></a>1.3 均衡化</h3><h4 id="1-3-1-直方图均衡化"><a href="#1-3-1-直方图均衡化" class="headerlink" title="1.3.1 直方图均衡化"></a>1.3.1 直方图均衡化</h4><ul><li>利用图像直方图对图像<strong>对比度</strong>进行调整的方法</li><li>通常用来增加图像的局部对比度，而不影响整体的对比度</li><li>实质是对图像进行<strong>非线性拉伸</strong>，重新分配各个像素单位中的像素点数量，是数量大致相等</li><li><strong>解决图像太亮或太暗的方法</strong></li><li>效果如下</li></ul><img src="image-20230711160715766.png" style="zoom: 33%;"><h4 id="1-3-2-自适应直方图均衡化-AHE算法"><a href="#1-3-2-自适应直方图均衡化-AHE算法" class="headerlink" title="1.3.2 自适应直方图均衡化(AHE算法)"></a>1.3.2 自适应直方图均衡化(AHE算法)</h4><ul><li>图像中<strong>既有特别亮也有特别暗</strong>的部分</li><li>算法主要步骤<ul><li>移动模板在原始图像上，按特定步长滑动</li><li>每次移动后，模板区域做直方图均衡化，映射后的结果赋值给模板区域所有点</li><li>每次模板滑动会覆盖相同的点，所有每个点会有不同的赋值，取其<strong>均值</strong>作为该点最终赋值</li></ul></li><li><strong>缺点</strong>：会过度放大图像中相对均匀区域的噪声</li></ul><h4 id="1-3-3-限制对比度自适应直方图均衡-CLAHE算法"><a href="#1-3-3-限制对比度自适应直方图均衡-CLAHE算法" class="headerlink" title="1.3.3 限制对比度自适应直方图均衡(CLAHE算法)"></a>1.3.3 限制对比度自适应直方图均衡(CLAHE算法)</h4><ul><li><p>相较于AHE算法，有一个<strong>直方图修剪</strong>过程，修剪后其图像对比度会更加自然</p></li><li><img src="image-20230711163129854.png" style="zoom:33%;"></li><li><p>算法步骤</p><ul><li>图像分块</li><li>先计算直方图，然后修剪直方图，最后均衡</li><li>遍历各个图像块，进行<strong>块间双线性插值</strong></li><li>与原图做图层滤色混合操作（可选）</li></ul></li><li><p>效果如下</p></li></ul><img src="image-20230711165455356.png" style="zoom:33%;"><h3 id="1-4-形态学运算"><a href="#1-4-形态学运算" class="headerlink" title="1.4 形态学运算"></a>1.4 形态学运算</h3><p>当有噪声的图像用阈值二值化后，所得到的边界是很不平滑的，物体区域具有一些错判的孔洞，背景区域散步着一些小的噪声物体，连续的开闭运算可以显著改善这种情况</p><h4 id="1-4-1-膨胀"><a href="#1-4-1-膨胀" class="headerlink" title="1.4.1 膨胀"></a>1.4.1 膨胀</h4><ul><li>对图像中高亮部分进行膨胀，类似于领域扩张</li></ul><h4 id="1-4-2-腐蚀"><a href="#1-4-2-腐蚀" class="headerlink" title="1.4.2 腐蚀"></a>1.4.2 腐蚀</h4><ul><li>领域蚕食</li></ul><h4 id="1-4-3-开运算"><a href="#1-4-3-开运算" class="headerlink" title="1.4.3 开运算"></a>1.4.3 开运算</h4><ul><li>先腐蚀再膨胀，去掉目标外的孤立点</li></ul><h4 id="1-4-4-闭运算"><a href="#1-4-4-闭运算" class="headerlink" title="1.4.4 闭运算"></a>1.4.4 闭运算</h4><ul><li>先膨胀再腐蚀，去掉目标内的孔洞</li></ul><h3 id="1-5-空间域处理-滤波-卷积"><a href="#1-5-空间域处理-滤波-卷积" class="headerlink" title="1.5 空间域处理(滤波/卷积)"></a>1.5 空间域处理(滤波/卷积)</h3><h4 id="1-5-1-平滑-去噪"><a href="#1-5-1-平滑-去噪" class="headerlink" title="1.5.1 平滑/去噪"></a>1.5.1 平滑/去噪</h4><h5 id="1-5-1-1-均值滤波-很少用"><a href="#1-5-1-1-均值滤波-很少用" class="headerlink" title="1.5.1.1 均值滤波(很少用)"></a>1.5.1.1 均值滤波(很少用)</h5><ul><li>均值滤波本身存在缺陷，既没有很好的去除噪声点，也破坏了图像的细节，反而使图像变得模糊</li><li>效果如下</li></ul><img src="image-20230711181112309.png" style="zoom:33%;"><h5 id="1-5-1-2-中值滤波"><a href="#1-5-1-2-中值滤波" class="headerlink" title="1.5.1.2 中值滤波"></a>1.5.1.2 中值滤波</h5><ul><li>对区域内像素取中位数</li><li>对于椒盐噪声，可以较好的还原图像</li><li>效果如下</li></ul><img src="image-20230711183054441.png" style="zoom: 33%;"><h5 id="1-5-1-3-高斯滤波"><a href="#1-5-1-3-高斯滤波" class="headerlink" title="1.5.1.3 高斯滤波"></a>1.5.1.3 高斯滤波</h5><ul><li>模拟人眼，关注中心区域，离中心越远，感受到的精度越模糊</li><li>有效去除高斯噪声</li><li>参数<ul><li>x,y是卷积参数坐标</li><li>$\delta$是标准差，$\delta$越小，关注区域越集中<img src="image-20230711183916602.png" style="zoom:33%;"></li></ul></li></ul><h5 id="1-5-1-4-高斯金字塔"><a href="#1-5-1-4-高斯金字塔" class="headerlink" title="1.5.1.4 高斯金字塔"></a>1.5.1.4 高斯金字塔</h5><ul><li>高斯滤波的模糊化，是为了引入高斯金字塔</li><li>直接降采样损失信息，用高斯滤波来减少降采样带来的信息损失</li></ul><img src="image-20230711190914908.png" style="zoom:33%;"><h4 id="1-5-2-梯度-锐化"><a href="#1-5-2-梯度-锐化" class="headerlink" title="1.5.2 梯度/锐化"></a>1.5.2 梯度/锐化</h4><h5 id="1-5-2-1-Prettier"><a href="#1-5-2-1-Prettier" class="headerlink" title="1.5.2.1 Prettier"></a>1.5.2.1 Prettier</h5><h5 id="1-5-2-2-Sobel算子"><a href="#1-5-2-2-Sobel算子" class="headerlink" title="1.5.2.2 Sobel算子"></a>1.5.2.2 Sobel算子</h5><ul><li>sobel滤波找竖直的线，也可以找水平的线，对于<strong>斜向的线易遗漏</strong></li></ul><img src="image-20230711200309925.png" style="zoom: 50%;"><img src="image-20230711200152745.png" style="zoom: 50%;"><h5 id="1-5-2-3-Laplacian算子"><a href="#1-5-2-3-Laplacian算子" class="headerlink" title="1.5.2.3 Laplacian算子"></a>1.5.2.3 Laplacian算子</h5><ul><li>找突变的地方</li><li>块图检测：周边高于/低于中心点</li><li><strong>边缘检测</strong>：像素值快速变化的区域</li><li>算子和必须是0，要满足微分等式，避免把完全平滑的区域选出来</li></ul><img src="image-20230711185605398.png" style="zoom:33%;"><ul><li>效果如下</li></ul><img src="image-20230711190102480.png" style="zoom:33%;"><h2 id="二、特征检测"><a href="#二、特征检测" class="headerlink" title="二、特征检测"></a>二、特征检测</h2><h3 id="2-1-颜色特征"><a href="#2-1-颜色特征" class="headerlink" title="2.1 颜色特征"></a>2.1 颜色特征</h3><h4 id="2-1-1-量化颜色直方图"><a href="#2-1-1-量化颜色直方图" class="headerlink" title="2.1.1 量化颜色直方图"></a>2.1.1 量化颜色直方图</h4><ul><li>适用空间：RGB、HSV</li><li>操作<ul><li>颜色空间量化，单元由单元中心代表</li><li>统计落在量化单元上的像素数量</li></ul></li></ul><h4 id="2-1-2-聚类颜色直方图"><a href="#2-1-2-聚类颜色直方图" class="headerlink" title="2.1.2 聚类颜色直方图"></a>2.1.2 聚类颜色直方图</h4><ul><li>适用空间：LAB<ul><li>LAB空间是用数字化的方法来描述人的视觉感应</li><li>L代表像素<strong>亮度</strong>，取值范围是[0,100]，表示从纯黑到纯白</li><li>A代表从<strong>品红色到深绿色</strong>的范围，取值范围是[127,-128]</li><li>B代表从<strong>黄色到蓝色</strong>的范围，取值范围是[127,-128]</li></ul></li></ul><img src="image-20230713133746258.png" style="zoom:33%;"><ul><li>操作<ul><li>使用聚类算法对所有像素点颜色向量进行聚类</li><li>单元由聚类中心代表</li></ul></li></ul><h3 id="2-2-几何特征"><a href="#2-2-几何特征" class="headerlink" title="2.2 几何特征"></a>2.2 几何特征</h3><h4 id="2-2-1-边缘特征"><a href="#2-2-1-边缘特征" class="headerlink" title="2.2.1 边缘特征"></a>2.2.1 边缘特征</h4><ul><li>边缘（Edge）<ul><li>像素明显变化的区域</li><li>具有丰富的语义</li><li>作用<ul><li>物体识别</li><li>几何、视角交换</li></ul></li><li>数学角度定义<ul><li>像素值函数快速变化的区域$\rightarrow$一阶导数的极值区域</li></ul></li></ul></li></ul><img src="image-20230713134610371.png" style="zoom:33%;"><ul><li>边缘提取<ul><li>先<strong>高斯去噪（平滑图像）</strong>，使像素变化连续，再使用一阶导数获得极值</li><li>导数对噪声敏感</li></ul></li></ul><h4 id="2-2-2-基于特征点的特征描述子"><a href="#2-2-2-基于特征点的特征描述子" class="headerlink" title="2.2.2 基于特征点的特征描述子"></a>2.2.2 基于特征点的特征描述子</h4><ul><li><p>从不同距离、不同方向、角度，不同的光照下观察同一个物体，物体的形状大小明暗都会有所不同，但我们依然可以判断它是同一个物体</p></li><li><p>理想的特征描述子应在大小、方向、明暗不同的图像中，同一特征点应具有足够相似的描述子</p></li><li><p>特征点</p><ul><li>不同视角图片之间的映射</li><li>稳定局部特征点<ul><li>可重复性、显著性</li><li>抗图片变换（亮度、光照、平移、选择、尺度）</li></ul></li></ul></li></ul><img src="image-20230713140445623.png" style="zoom: 50%;"><ul><li>找到这些关键点后，可实现图像拼接、运动跟踪、物体识别、机器人导航、3D重建</li></ul><h5 id="2-2-2-1-Harris角点"><a href="#2-2-2-1-Harris角点" class="headerlink" title="2.2.2.1 Harris角点"></a>2.2.2.1 Harris角点</h5><h5 id="2-2-2-2FAST角点"><a href="#2-2-2-2FAST角点" class="headerlink" title="2.2.2.2FAST角点"></a>2.2.2.2FAST角点</h5><ul><li><p>FAST角点检测是一种快速角点特征检测算法</p></li><li><p>FAST角点定义：若某像素点与其周围领域内足够多的像素点处于不同区域，则该像素点可能为角点</p></li><li><p>FAST特征点检测是对兴趣点所在圆周上的16个像素点进行判断</p></li><li><p>FAST角点检测算法<strong>复杂度小</strong>，检测效果好</p></li><li><p>FAST不产生多尺度特征，没有方向信息，会<strong>失去旋转不变性</strong></p></li><li><p>算法步骤</p><ul><li>确定一个阈值t，观察检测像素点p为中心的一个半径等于3像素的离散化的圆，这个圆边界上有<strong>16个像素</strong></li><li>如果在这个圆上，有<strong>连续12个像素</strong>点，它们的像素值要么都比$I_p+t$大/小，则点p是一个角点</li></ul></li></ul><img src="image-20230713142300065.png" style="zoom: 50%;"><h2 id="三、图像分割"><a href="#三、图像分割" class="headerlink" title="三、图像分割"></a>三、图像分割</h2><p>其目的是将感兴趣目标从复杂背景中提取出来，以便进行目标识别和分析</p><h3 id="3-1-阈值分割"><a href="#3-1-阈值分割" class="headerlink" title="3.1 阈值分割"></a>3.1 阈值分割</h3><h4 id="3-1-1-图像二值化"><a href="#3-1-1-图像二值化" class="headerlink" title="3.1.1 图像二值化"></a>3.1.1 图像二值化</h4><ul><li>当背景与前景的灰度分布差异明显时，可以使用单个阈值处理图像</li></ul><h5 id="3-1-1-1-自动阈值算法"><a href="#3-1-1-1-自动阈值算法" class="headerlink" title="3.1.1.1 自动阈值算法"></a>3.1.1.1 自动阈值算法</h5><ul><li>当物体与背景的直方图之间存在一个相当清晰的波谷时，这个算法工作效果很好</li><li>算法步骤<ul><li>(1) 为全局选定一个<strong>初始阈值T</strong></li><li>(2) 用初值T对图像进行分割，把图像<strong>分割为2组像素</strong>，$G_1$由灰度值大于T的像素组成，$G_2$由小于等于的像素组成</li><li>(3) 对$G_1$和$G-2$分别计算平均灰度值$m_1$和$m_2$</li><li>(4) 更新阈值$T=\frac{m_1+m_2}{2}$</li><li>(5) 重复(2)-(4)，直到相邻2次T值之差小于预定的$\Delta T$为止</li></ul></li></ul><img src="image-20230713150526131.png" style="zoom: 50%;"><h5 id="3-1-1-2-Otsu最佳阈值处理（最大类间差方法）"><a href="#3-1-1-2-Otsu最佳阈值处理（最大类间差方法）" class="headerlink" title="3.1.1.2 Otsu最佳阈值处理（最大类间差方法）"></a>3.1.1.2 Otsu最佳阈值处理（最大类间差方法）</h5><ul><li><p>Otsu算法是一种自适应阈值确定方法，是一种全局的二值化方法</p></li><li><p>它根据图像的灰度特性，将图像分为前景和背景两个部分。当取最佳阈值时，两部分之间的差别最大。</p></li><li><p>Otsu算法采用的衡量差别的标准为最大类间方差。前景与背景之间的类间方差越大，就说明构成图像的两部分差别越大</p></li><li><p>当部分目标被错分为背景或部分背景被错分为目标时，都会导致两部分差别变小</p></li><li><p>当所取阈值的分割使类间方差最大时，意味着错分概率最小</p></li><li><p>算法过程</p><ul><li><p>假设一幅尺寸为M*N的图像中有L个不同的灰度级{0,1,2,…,L-1}，$n_i$表示灰度级为i的像素个数，$p_i$表示归一化的直方图分量</p><ul><li>$p_i=\frac{n_i}{MN}，\sum\limits _{i=0}^{L-1} p_i=1$</li></ul></li><li><p>选择一个阈值$T(k)=k (0&lt;k&lt;L-1)$，用它将图像阈值分为两类</p><ul><li>$C_1$灰度值在[0,k]</li><li>$C_2$灰度值在[k+1,L-1]</li></ul></li></ul></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>OpenMv Cam H7</title>
      <link href="/2024/04/01/openmv/"/>
      <url>/2024/04/01/openmv/</url>
      
        <content type="html"><![CDATA[<h2 id="一、图像处理背景"><a href="#一、图像处理背景" class="headerlink" title="一、图像处理背景"></a>一、图像处理背景</h2><h3 id="1-1-什么是颜色"><a href="#1-1-什么是颜色" class="headerlink" title="1.1 什么是颜色"></a>1.1 什么是颜色</h3><p>颜色就是不同波长的电磁波</p><img src="image-20230225110627109-1711976615648-15.png" style="zoom:50%;"><h3 id="1-2-LAB色域"><a href="#1-2-LAB色域" class="headerlink" title="1.2 LAB色域"></a>1.2 LAB色域</h3><p>Openmv查找色块算法使用<strong>LAB模式</strong></p><p>Lab颜色空间中，<strong>L亮度；a的正数代表红色，负端代表绿色；b的正数代表黄色，负端代表兰色（墨水蓝，天蓝色）</strong>。不像RGB和CMYK色彩空间，Lab颜色被设计来接近人类视觉。因此，L分量可以调整亮度对，修改a和b分量的输出色阶来做精确的颜色平衡。</p><h3 id="1-3-光源"><a href="#1-3-光源" class="headerlink" title="1.3 光源"></a>1.3 光源</h3><p>保持一个稳定的光源是<strong>至关重要</strong>的，尤其在颜色算法中。亮度一变，整个颜色的值会变化的很大！</p><h3 id="1-4-焦距"><a href="#1-4-焦距" class="headerlink" title="1.4 焦距"></a>1.4 焦距</h3><p>镜头焦距：是指镜头光学后<strong>主点到焦点的距离</strong>，是镜头的重要性能指标。镜头焦距的长短<strong>决定着拍摄的成像大小，视场角大小，景深大小和画面的透视强弱</strong>。当对同一距离远的同一个被摄目标拍摄时，镜头焦距长的所成的象大，镜头焦距短的所成的象小。注意<strong>焦距越长，视角越小</strong>。</p><img src="image-20230225111407279-1711976615648-17.png" style="zoom: 33%;"><h2 id="二、Openmv图像处理方法"><a href="#二、Openmv图像处理方法" class="headerlink" title="二、Openmv图像处理方法"></a>二、Openmv图像处理方法</h2><h3 id="2-1-sensor模块"><a href="#2-1-sensor模块" class="headerlink" title="2.1 sensor模块"></a>2.1 sensor模块</h3><h4 id="2-1-1-导入sensor"><a href="#2-1-1-导入sensor" class="headerlink" title="2.1.1 导入sensor"></a>2.1.1 导入sensor</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python">import sensor<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="2-1-2-初始化摄像头"><a href="#2-1-2-初始化摄像头" class="headerlink" title="2.1.2 初始化摄像头"></a>2.1.2 初始化摄像头</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python">sensor.reset()<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="2-1-3-设置图像模式"><a href="#2-1-3-设置图像模式" class="headerlink" title="2.1.3 设置图像模式"></a>2.1.3 设置图像模式</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python">'''可选参数：- sensor.GRAYSCALE: 灰度图，每个像素8bit- sensor.RGB565: 彩图，每个像素16bit'''sensor.set_pixformat(sensor.RGB565)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-1-4-设置图像尺寸"><a href="#2-1-4-设置图像尺寸" class="headerlink" title="2.1.4 设置图像尺寸"></a>2.1.4 设置图像尺寸</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python">'''可选参数太多，列举几个：- sensor.VGA: 640x480- sensor.QVGA: 320x240- sensor.QQVGA: 160x120- sensor.QQQVGA: 80x60'''sensor.set_framesize(sensor.QVGA)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-1-5-提取图像区域"><a href="#2-1-5-提取图像区域" class="headerlink" title="2.1.5 提取图像区域"></a>2.1.5 提取图像区域</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python">'''设置窗口ROI- Region Of Interest，感兴趣区，就是在要处理的图像中提取出的要处理的区域其中，roi格式为(x, y, w, h)的tupple- x:ROI区域中左上角的x坐标，从0开始计数，由左往右增大- y:ROI区域中左上角的y坐标，同样从0开始计数，由上往下增大- w:ROI的宽度- h:ROI的高度'''sensor.set_windowing((640, 80)) #取图像中间的640*80区域<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-1-6-图像翻转"><a href="#2-1-6-图像翻转" class="headerlink" title="2.1.6 图像翻转"></a>2.1.6 图像翻转</h4><ul><li>水平翻转</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">sensor.set_hmirror(True)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>垂直翻转</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">sensor.set_vflip(True)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>转置</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">sensor.set_transpose(True)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="2-1-7-自动增益"><a href="#2-1-7-自动增益" class="headerlink" title="2.1.7 自动增益"></a>2.1.7 自动增益</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python">'''- 自动增益，开启（True）或者关闭（False）- 在使用颜色追踪时，需要关闭自动增益'''sensor.set_auto_gain(False) <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-1-8-自动白平衡"><a href="#2-1-8-自动白平衡" class="headerlink" title="2.1.8 自动白平衡"></a>2.1.8 自动白平衡</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python">'''- 自动白平衡开启（True）或者关闭（False）- 在使用颜色追踪时，需要关闭自动白平衡'''sensor.set_auto_whitebal(False) <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-1-9-跳帧"><a href="#2-1-9-跳帧" class="headerlink" title="2.1.9 跳帧"></a>2.1.9 跳帧</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python">'''- 跳过n张照片，等待感光元件变稳定'''sensor.skip_frames(10)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-1-10-拍照"><a href="#2-1-10-拍照" class="headerlink" title="2.1.10 拍照"></a>2.1.10 拍照</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python">'''- sensor.snapshot() 拍摄一张照片- 返回一个image对象'''img = sensor.snapshot()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-1-11-获取传感器窗口宽高"><a href="#2-1-11-获取传感器窗口宽高" class="headerlink" title="2.1.11 获取传感器窗口宽高"></a>2.1.11 获取传感器窗口宽高</h4><ul><li>图像宽度</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">sensor.width()<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>图像高度</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">sensor.height()<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="2-2-image模块"><a href="#2-2-image模块" class="headerlink" title="2.2 image模块"></a>2.2 image模块</h3><h4 id="2-2-1-获取-设置像素值"><a href="#2-2-1-获取-设置像素值" class="headerlink" title="2.2.1 获取/设置像素值"></a>2.2.1 获取/设置像素值</h4><ul><li>获取像素点</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">'''- 对于灰度图: 返回(x,y)坐标的灰度值- 对于彩色图: 返回(x,y)坐标的(r,g,b)的tuple'''image.get_pixel(x, y)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>设置像素值</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">'''- 对于灰度图: 设置(x,y)坐标的灰度值- 对于彩色图: 设置(x,y)坐标的(r,g,b)的值'''image.set_pixel(x, y, pixel)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>举例：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">img = sensor.snapshot()img.get_pixel(10,10)#获取坐标（10，10）处的灰度值/rgbimg.set_pixcel(10,10,(255,0,0))#设置坐标(10,10)的像素点为红色(255,0,0)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="2-2-2-获取拍摄图像宽高"><a href="#2-2-2-获取拍摄图像宽高" class="headerlink" title="2.2.2 获取拍摄图像宽高"></a>2.2.2 获取拍摄图像宽高</h4><ul><li>图像宽度</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">image.width()<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>图像高度</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">image.height()<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>图像尺寸</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">'''- 返回图像的大小(byte)，其值等于 长x宽'''image.size()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-2-3-获取图像格式"><a href="#2-2-3-获取图像格式" class="headerlink" title="2.2.3 获取图像格式"></a>2.2.3 获取图像格式</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python">'''- 灰度图返回 sensor.GRAYSCALE- 彩色图返回 sensor.RGB565'''image.format()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-2-4-图像运算"><a href="#2-2-4-图像运算" class="headerlink" title="2.2.4 图像运算"></a>2.2.4 图像运算</h4><ul><li><strong>取反</strong>，对于二值化的图像，0(黑)变成1(白)，1(白)变成0(黑)</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">image.invert()<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>与另一个图片进行<strong>与非</strong>（NAND）运算<ul><li>先与后非</li></ul></li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">image.nand(image)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>与另一个图片进行<strong>或非</strong>（NOR）运算<ul><li>先或后非</li></ul></li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">image.nor(image)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>与另一个图片进行<strong>异或</strong>（XOR）运算<ul><li>相同为0，相异为1</li></ul></li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">image.xor(image)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>与另一个图片进行<strong>同或</strong>（XNOR）运算<ul><li>相同为1，相异为0</li></ul></li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">image.xnor(image)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><strong>减法</strong>，从这张图片减去另一个图片，经常用来做==移动检测==</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">image.difference(image)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="2-2-5-Statistics-统计信息"><a href="#2-2-5-Statistics-统计信息" class="headerlink" title="2.2.5 Statistics 统计信息"></a>2.2.5 Statistics 统计信息</h4><h5 id="2-2-5-1-创建Statistics对象"><a href="#2-2-5-1-创建Statistics对象" class="headerlink" title="2.2.5.1 创建Statistics对象"></a>2.2.5.1 创建Statistics对象</h5><pre class="line-numbers language-python" data-language="python"><code class="language-python">'''- roi必须显示输入，否则不知道统计哪一块的像素信息'''image.get_statistics(roi=Auto)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="2-2-5-2-Statistics方法"><a href="#2-2-5-2-Statistics方法" class="headerlink" title="2.2.5.2 Statistics方法"></a>2.2.5.2 Statistics方法</h5><ul><li>返回灰度<strong>均值</strong></li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">statistics.mean()<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>返回灰度<strong>中值</strong></li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">statistics.median()<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>返回灰度均值</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">statistics.mean()<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>返回灰度<strong>众数</strong></li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">statistics.mode()<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>返回灰度<strong>标准差</strong></li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">statistics.stdev()<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>返回灰度<strong>最值</strong></li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">statistics.max()statistics.min()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="2-2-6-Blob-色块信息"><a href="#2-2-6-Blob-色块信息" class="headerlink" title="2.2.6 Blob 色块信息"></a>2.2.6 Blob 色块信息</h4><h5 id="2-2-6-1-创建Blob对象"><a href="#2-2-6-1-创建Blob对象" class="headerlink" title="2.2.6.1 创建Blob对象"></a>2.2.6.1 创建Blob对象</h5><pre class="line-numbers language-python" data-language="python"><code class="language-python">'''- thresholds 为目标颜色阈值，可以是多个阈值构成的列表，即同时查找多种颜色- roi 感兴趣区域- x_stride 查找某色块时需要跳过的x像素的数量（有点卷积步长的感觉）- y_stride 查找某色块时需要跳过的y像素的数量- invert 反转阈值操作，识别阈值之外的目标- area_threshold 面积阈值，色块的面积，即方框面积- pixels_threshold 像素个数阈值，方框内的阈值像素个数- merge 若为True，合并待识别的多种目标颜色色块。如，当目标颜色为红色和蓝色时，红色的code为0001，蓝 色的code为0010，当merge为True时，若色块中同时检测到两种颜色，该blob.ocde的返回值为0011 （感觉不太正确）- margin 边界，如果设置为1，那么两个blob如果间距1一个像素点会被合并'''# 返回的是blob列表blobs=image.find_blobs(    thresholds=[(),()],     # 必须是二维列表！元素可以是列表，也可以是元组    # 若为灰度图，元组由最小最大值组成(g_l,g_h)    # 若为RGB565,元组为LAB阈值        roi=Auto,     x_stride=2,     y_stride=1,     invert=False,     area_threshold=10,     pixels_threshold=10,     merge=False,     margin=0, )<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="2-2-6-2-blob方法"><a href="#2-2-6-2-blob方法" class="headerlink" title="2.2.6.2 blob方法"></a>2.2.6.2 blob方法</h5><ul><li>返回色块<strong>外框信息</strong></li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">blob.rect()  # 外框(x,y,w,h)blob.x()blob.y()blob.w()blob.h()blob.cx()blob.cy()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>返回色块<strong>code</strong></li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">blob.code() <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>返回色块<strong>旋转角度</strong></li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">blob.rotation() # 单位为弧度<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>返回色块<strong>外框面积</strong></li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">blob.area() <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>返回色块内<strong>阈值像素个数</strong></li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">blob.pixels()<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>返回色块<strong>密度</strong><ul><li>密度越高，目标锁定越好</li></ul></li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">blob.density()<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="2-2-7-绘图"><a href="#2-2-7-绘图" class="headerlink" title="2.2.7 绘图"></a>2.2.7 绘图</h4><h5 id="2-2-7-1-画直线"><a href="#2-2-7-1-画直线" class="headerlink" title="2.2.7.1 画直线"></a>2.2.7.1 画直线</h5><pre class="line-numbers language-python" data-language="python"><code class="language-python">'''- line_tuple 的格式是(x0, y0, x1, y1)，意思是(x0, y0)到(x1, y1)的直线- color 显示赋值，可以是灰度值(0-255)，或者是彩色值(r, g, b)的tupple，默认白色- thickness 设置直线粗细'''image.draw_line(line_tuple, color=(255,0,0), thickness=1)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="2-2-7-2-画矩形"><a href="#2-2-7-2-画矩形" class="headerlink" title="2.2.7.2 画矩形"></a>2.2.7.2 画矩形</h5><pre class="line-numbers language-python" data-language="python"><code class="language-python">'''- rect_tuple 的格式是 (x, y, w, h)，含义同ROI- color- thickness- fill 若为True，用color填充矩形'''image.draw_rectangle(rect_tuple, color=(0,0,255),  thickness=1, fill=False)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="2-2-7-3-画圆"><a href="#2-2-7-3-画圆" class="headerlink" title="2.2.7.3 画圆"></a>2.2.7.3 画圆</h5><pre class="line-numbers language-python" data-language="python"><code class="language-python">'''- circle_tuple的格式(x, y, radius)，中心坐标，半径- color- thickness- fill'''image.draw_circle((x, y, radius), color=White, thickness=1, fill=False)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="2-2-7-4-画十字"><a href="#2-2-7-4-画十字" class="headerlink" title="2.2.7.4 画十字"></a>2.2.7.4 画十字</h5><pre class="line-numbers language-python" data-language="python"><code class="language-python">'''- (x,y) 十字中心位置- size 十字延伸长度- color- fill'''image.draw_cross((x, y), size=5, color=(255,0,0)), thickness=1, fill=False)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="2-2-7-5-画箭头"><a href="#2-2-7-5-画箭头" class="headerlink" title="2.2.7.5 画箭头"></a>2.2.7.5 画箭头</h5><pre class="line-numbers language-python" data-language="python"><code class="language-python">'''- (x0, y0)到(x1, y1)的箭头- color- thickness'''image.draw_arrow((x0, y0, x1, y1), color=(255,0,0), thickness=1 )<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="2-2-7-6-写字"><a href="#2-2-7-6-写字" class="headerlink" title="2.2.7.6 写字"></a>2.2.7.6 写字</h5><pre class="line-numbers language-python" data-language="python"><code class="language-python">'''- x,y是坐标- text是要写的字符串,使用转义字符会产生相应变化'''image.draw_string(x, y, text, color=White) <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="三、应用"><a href="#三、应用" class="headerlink" title="三、应用"></a>三、应用</h2><h3 id="3-1-AprilTag标记跟踪及测距"><a href="#3-1-AprilTag标记跟踪及测距" class="headerlink" title="3.1 AprilTag标记跟踪及测距"></a>3.1 AprilTag标记跟踪及测距</h3><h5 id="3-1-1-AprilTag识别"><a href="#3-1-1-AprilTag识别" class="headerlink" title="3.1.1 AprilTag识别"></a>3.1.1 AprilTag识别</h5><ul><li>可得到Tag相对于相机的xyz换算坐标及旋转角度</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">'''- roi，可指定，但是隔一段时间没识别到Tag会报错，中断程序运行- families，Tag家族，默认image.TAG36H11，其识别精度最高- fx, fy, cx, cy 决定位置及旋转角度'''image.find_apriltags(roi, families=image.TAG36H11, fx, fy, cx, cy)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="3-1-2-AprilTag类方法"><a href="#3-1-2-AprilTag类方法" class="headerlink" title="3.1.2 AprilTag类方法"></a>3.1.2 AprilTag类方法</h5><ul><li>返回Tag<strong>边框信息</strong></li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">apriltag.rect() # 矩形元组（x,y,w,h）apriltag.x()apriltag.y()apriltag.w()apriltag.h()apriltag.cx()apriltag.cy()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>返回Tag标签<strong>ID</strong></li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">apriltag.id() # TAG36H11 -&gt; 0 to 586<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>返回Tag换算<strong>位置坐标</strong></li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">apriltag.x_translation()apriltag.y_translation()apriltag.z_translation()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>返回Tag<strong>旋转角度</strong></li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">apriltag.x_rotation()apriltag.y_rotation()apriltag.z_rotation()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h5 id="3-1-3-例程"><a href="#3-1-3-例程" class="headerlink" title="3.1.3 例程"></a>3.1.3 例程</h5><pre class="line-numbers language-python" data-language="python"><code class="language-python">'''- 输出的姿态的单位是弧度，可以转换成角度- 位置的单位及大小跟参考物体有关，需要等比例换算- f_x 是x的像素为单位的焦距,等于2.8/3.984*sensor.width()- f_y 是y的像素为单位的焦距,等于2.8/2.952*sensor.height()- c_x 是图像的x中心位置- c_y 是图像的y中心位置'''import sensor, image, time, mathsensor.reset()sensor.set_pixformat(sensor.RGB565)sensor.set_framesize(sensor.QQVGA) # we run out of memory if the resolution is much bigger...sensor.skip_frames(30)sensor.set_auto_gain(False)  # must turn this off to prevent image washout...sensor.set_auto_whitebal(False)  # must turn this off to prevent image washout...clock = time.clock()f_x = (2.8 / 3.984) * 160 # 默认值f_y = (2.8 / 2.952) * 120 # 默认值c_x = 160 * 0.5 # 默认值(image.w * 0.5)c_y = 120 * 0.5 # 默认值(image.h * 0.5)k=-4 # z轴实际距离 / Tz ，x，y轴系数应该是一样的计算方法def degrees(radians):    return (180 * radians) / math.piwhile(True):    clock.tick()    img = sensor.snapshot()    for tag in img.find_apriltags(fx=f_x, fy=f_y, cx=c_x, cy=c_y): # 默认为TAG36H11        img.draw_rectangle(tag.rect(), color = (255, 0, 0))        img.draw_cross(tag.cx(), tag.cy(), color = (0, 255, 0))        print_args = (tag.x_translation(), tag.y_translation(), tag.z_translation(), \            degrees(tag.x_rotation()), degrees(tag.y_rotation()), degrees(tag.z_rotation()))        # 位置的单位是未知的，旋转的单位是角度        print('z轴距离：'+str(print_args[2]*k)+'cm')        #print("Tx: %f, Ty %f, Tz %f, Rx %f, Ry %f, Rz %f" % print_args)    print(clock.fps())<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-2-NCC模板匹配"><a href="#3-2-NCC模板匹配" class="headerlink" title="3.2 NCC模板匹配"></a>3.2 NCC模板匹配</h3><h4 id="3-2-1-NCC简介"><a href="#3-2-1-NCC简介" class="headerlink" title="3.2.1 NCC简介"></a>3.2.1 NCC简介</h4><ul><li><p>图像匹配的方法主要有三种：<strong>基于灰度，基于特征，基于变换域</strong></p></li><li><p>NCC (normalized cross correlation) 算法，<strong>归一化互相关匹配</strong>法，是基于图像<strong>灰度信息</strong>的匹配方法</p></li><li><p>NCC算法可以<strong>有效降低光照对图像比较结果的影响</strong></p></li><li><p>NCC最终结果在0到1之间，<strong>容易量化比较结果</strong>，只要给出一个阈值就可以判断结果的好与坏</p></li><li><p><strong>缺点</strong>：只能匹配与模板图片大小和角度基本一致的图案，可从多角度多大小保存多个模板去克服</p></li></ul><h4 id="3-2-2-相关函数"><a href="#3-2-2-相关函数" class="headerlink" title="3.2.2 相关函数"></a>3.2.2 相关函数</h4><ul><li>导入模板图像</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">'''- 模板图像必须为灰度的pgm图像，IDE存取的是bmp格式，可在https://convertio.co/zh/bmp-pgm/在线转换- path 为导入模板图像路径，一般将模板图像存在同一文件夹下，直接写相对路径（文件名.pgm）'''image.Image(path)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>模板匹配</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">'''- template 是进行匹配的导入的模板- threshold 相似度阈值，越大准确率越高，但匹配速率会降低- roi- step 查找模板时跳过的像素数量，跳过像素可提高算法运行速度- search 模板匹配算法，有 image.SEARCH_DS 和 image.SEARCH_EX，一般选用image.SEARCH_EX，匹配更   为全面（若模板位于图像边缘周围，image.SEARCH_DS可能无法成功搜索），但运行速度会低一点'''image.find_template(template, threshold, roi, step=2, search=image.SEARCH_EX)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-2-3-例程"><a href="#3-2-3-例程" class="headerlink" title="3.2.3 例程"></a>3.2.3 例程</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python">import time, sensor, imagefrom image import SEARCH_EX, SEARCH_DSsensor.reset()sensor.set_contrast(1) # 设置对比度sensor.set_gainceiling(16) # 设置增益上限sensor.set_framesize(sensor.QQVGA)sensor.set_pixformat(sensor.GRAYSCALE)# 用列表存下多个模板文件名templates = ["/0.pgm", "/1.pgm", "/2.pgm", "/6.pgm"] #保存多个模板clock = time.clock()while (True):    clock.tick()    img = sensor.snapshot()    # 遍历列表进行模板匹配    for t in templates:        template = image.Image(t)        r = img.find_template(template, 0.70, step=4, search=SEARCH_EX)                if r:            img.draw_rectangle(r)            print(t) #打印模板名字<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-3-扫码"><a href="#3-3-扫码" class="headerlink" title="3.3 扫码"></a>3.3 扫码</h3><h4 id="3-3-1-二维码"><a href="#3-3-1-二维码" class="headerlink" title="3.3.1 二维码"></a>3.3.1 二维码</h4><h5 id="3-3-1-1-样例"><a href="#3-3-1-1-样例" class="headerlink" title="3.3.1.1 样例"></a>3.3.1.1 样例</h5><img src="image-20230716144928915-1711976615648-16.png" style="zoom:33%;"><h5 id="3-3-1-2-调用函数"><a href="#3-3-1-2-调用函数" class="headerlink" title="3.3.1.2 调用函数"></a>3.3.1.2 调用函数</h5><ul><li>二维码<strong>读取</strong></li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">'''- [roi]可不写'''image.find_qrcodes([roi])<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><strong>畸变矫正</strong>，去除镜头造成的图像鱼眼效果</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">'''- 消解镜头的桶形畸变,得到一个更为平展的二维码- strength 该值确定了对图像进行去鱼眼效果的程度- zoom 对图像进行缩放的倍数- x_corr/y_corr 一般不用，没了解'''image.lens_corr(strength=1.8, zoom=1.0, x_corr=0.0, y_corr=0.0)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="3-3-1-3-qrcode类方法"><a href="#3-3-1-3-qrcode类方法" class="headerlink" title="3.3.1.3 qrcode类方法"></a>3.3.1.3 qrcode类方法</h5><ul><li>常见，返回<strong>边框信息</strong></li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">qrcode.rec()qrcode.x()qrcode.y()qrcode.w()qrcode.h()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>返回二维码<strong>信息</strong></li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">qrcode.payload()<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h5 id="3-3-1-4-例程"><a href="#3-3-1-4-例程" class="headerlink" title="3.3.1.4 例程"></a>3.3.1.4 例程</h5><pre class="line-numbers language-python" data-language="python"><code class="language-python">import sensor, imagesensor.reset()sensor.set_pixformat(sensor.RGB565)sensor.set_framesize(sensor.QQVGA) # can be QVGA on M7...sensor.skip_frames(30)sensor.set_auto_gain(False) # must turn this off to prevent image washout...while(True):    img = sensor.snapshot()    img.lens_corr(1.8) # strength of 1.8 is good for the 2.8mm lens.    for code in img.find_qrcodes():        print(code)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-3-2-条形码"><a href="#3-3-2-条形码" class="headerlink" title="3.3.2 条形码"></a>3.3.2 条形码</h4><h5 id="3-3-2-1-样例"><a href="#3-3-2-1-样例" class="headerlink" title="3.3.2.1 样例"></a>3.3.2.1 样例</h5><img src="image-20230716150916140-1711976615648-18.png" style="zoom:50%;"><h5 id="3-3-2-2-调用函数"><a href="#3-3-2-2-调用函数" class="headerlink" title="3.3.2.2 调用函数"></a>3.3.2.2 调用函数</h5><ul><li>一维码<strong>读取</strong></li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">'''- 同样，[roi]可不写，进行全图扫描'''image.find_barcodes([roi])<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="3-3-2-3-barcode类方法"><a href="#3-3-2-3-barcode类方法" class="headerlink" title="3.3.2.3 barcode类方法"></a>3.3.2.3 barcode类方法</h5><ul><li>常见，返回<strong>边框信息</strong></li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">barcode.rec()barcode.x()barcode.y()barcode.w()barcode.h()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>返回条形码<strong>信息</strong></li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">barcode.payload()<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>返回条形在图像中<strong>被扫描的次数</strong></li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">barcode.quality()<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h5 id="3-3-2-4-例程"><a href="#3-3-2-4-例程" class="headerlink" title="3.3.2.4 例程"></a>3.3.2.4 例程</h5><pre class="line-numbers language-python" data-language="python"><code class="language-python">import sensor, image, time, mathsensor.reset()sensor.set_pixformat(sensor.GRAYSCALE)sensor.set_framesize(sensor.VGA) # High Res!sensor.set_windowing((640, 80)) # V Res of 80 == less work (40 for 2X the speed).sensor.skip_frames(30)sensor.set_auto_gain(False)  # must turn this off to prevent image washout...sensor.set_auto_whitebal(False)  # must turn this off to prevent image washout...clock = time.clock()while(True):    clock.tick()    img = sensor.snapshot()    codes = img.find_barcodes()    for code in codes:        img.draw_rectangle(code.rect())        print_args = (code.payload(), (180 * code.rotation()) / math.pi, code.quality(), clock.fps())        print("Payload \"%s\", rotation %f (degrees), quality %d, FPS %f" % print_args)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-3-3-Datamatrix"><a href="#3-3-3-Datamatrix" class="headerlink" title="3.3.3 Datamatrix"></a>3.3.3 Datamatrix</h4><p>基本没遇到，懒得写了</p><h3 id="3-4-巡线"><a href="#3-4-巡线" class="headerlink" title="3.4 巡线"></a>3.4 巡线</h3><h4 id="3-4-1-无岔口"><a href="#3-4-1-无岔口" class="headerlink" title="3.4.1 无岔口"></a>3.4.1 无岔口</h4><h2 id="四、pyb外设模块"><a href="#四、pyb外设模块" class="headerlink" title="四、pyb外设模块"></a>四、pyb外设模块</h2><h3 id="4-1-LED调用"><a href="#4-1-LED调用" class="headerlink" title="4.1 LED调用"></a>4.1 LED调用</h3><ul><li>需要导入模块</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">from pyb import LED<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>可用灯</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">LED(1) -&gt; 红LEDLED(2) -&gt; 绿LEDLED(3) -&gt; 蓝LEDLED(4) -&gt; 红外LED，两个<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li>使用方法</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">led = LED(1) # 红ledled.on()#亮led.off()#灭<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-2-时间相关函数"><a href="#4-2-时间相关函数" class="headerlink" title="4.2 时间相关函数"></a>4.2 时间相关函数</h3><ul><li><strong>延时</strong>函数</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">pyb.delay(50) # 延时 50 毫秒pyb.udelay(us) # 延时微秒<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>计录<strong>使用时间</strong></li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">pyb.millis() # 插件重置后，返回毫秒数<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>算<strong>时间差</strong></li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">'''- 计算当前时刻，与start时刻的时间差'''start = pyb.millis()pyb.elapsed_millis(start)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-3-Servo控制舵机"><a href="#4-3-Servo控制舵机" class="headerlink" title="4.3 Servo控制舵机"></a>4.3 Servo控制舵机</h3><ul><li>导入模块</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">from pyb import Servo<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>创建舵机对象</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">'''- Servo(1) -&gt; P7 (PD12)- Servo(2) -&gt; P8 (PD13)- Servo(3) -&gt; P9 (PD14)'''s1 = Servo(1) # servo on position 1 (P7)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>控制角度</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">s1.angle(45) # move to 45 degreess1.angle(-60, 1500) # move to -60 degrees in 1500mss1.speed(50) # 连续运动时才需要设置速度<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-4-UART通信"><a href="#4-4-UART通信" class="headerlink" title="4.4 UART通信"></a>4.4 UART通信</h3><ul><li>引脚</li></ul><table><thead><tr><th align="center">名称</th><th align="center">引脚</th></tr></thead><tbody><tr><td align="center">UART 3 RX</td><td align="center">P5 (PB11)</td></tr><tr><td align="center">UART 3 TX</td><td align="center">P4 (PB10)</td></tr><tr><td align="center">UART 1 RX</td><td align="center">P0 (PB15)</td></tr><tr><td align="center">UART 1 TX</td><td align="center">P1 (PB14)</td></tr></tbody></table><ul><li>导入模块</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">from pyb import UART<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>初始化串口</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">uart = UART(3, 9600)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>传出数据</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">uart.write("Hello World!\r")<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>读取数据</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">UART.readline() # 读一行UART.any() # 返回已经读入的字节数<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="4-5-光源扩展"><a href="#4-5-光源扩展" class="headerlink" title="4.5 光源扩展"></a>4.5 光源扩展</h3><ul><li>导包</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">import timefrom pyb import Pin, Timer<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>定义变量并设置亮度</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 50kHz pin6 timer2 channel1light = Timer(2, freq=50000).channel(1, Timer.PWM, pin=Pin("P6"))light.pulse_width_percent(100) # 控制亮度 0~100while (True):    time.sleep_ms(1000)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="五、图像预处理"><a href="#五、图像预处理" class="headerlink" title="五、图像预处理"></a>五、图像预处理</h2><h3 id="5-1-畸变校正"><a href="#5-1-畸变校正" class="headerlink" title="5.1 畸变校正"></a>5.1 畸变校正</h3><ul><li>去除镜头的<strong>鱼眼</strong>效果</li><li><img src="image-20230717202535971-1711976615648-19.png" style="zoom:50%;"></li><li>畸变校正函数</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">'''- strength 确定去鱼眼效果的程度- zoom 对图像进行缩放的倍数'''image.lens_corr(strength=1.8, zoom=1.0, x_corr=0.0, y_corr=0.0)# 使用例子img = sensor.snapshot().lens_corr(strength = 1.8, zoom = 1.0)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-2-二值化"><a href="#5-2-二值化" class="headerlink" title="5.2 二值化"></a>5.2 二值化</h3><ul><li>根据阈值将图像划分为二值图像</li><li>二值化函数</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">'''- thresholds 将该阈值范围内的像素设置为白色  - 对于灰度图，该阈值元组需要包含两个值，最小灰度和最大灰度  - 对于RGB565图，阈值元组需要有六个值，LAB三个通道的范围- invert 翻转二值化结果，将黑变白，白变黑'''image.binary([thresholds], invert=False)# 例子，针对RGB565图像中的红色部分进行二值化img.binary([(24, 57, 22, 83, 39, -10)],invert=True)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-3-直方图"><a href="#5-3-直方图" class="headerlink" title="5.3 直方图"></a>5.3 直方图</h3><ul><li>没看明白到底有啥用</li><li>调用函数</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">img.get_histogram(bins=8)# 例子while(True):    clock.tick()    img = sensor.snapshot()    # Gets the grayscale histogram for the image into 8 bins.    # Bins defaults to 256 and may be between 2 and 256.    print(img.get_histogram(bins=8))    print(clock.fps())<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-4-图像滤波"><a href="#5-4-图像滤波" class="headerlink" title="5.4 图像滤波"></a>5.4 图像滤波</h3><h4 id="5-4-1-自适应直方图均衡"><a href="#5-4-1-自适应直方图均衡" class="headerlink" title="5.4.1 自适应直方图均衡"></a>5.4.1 自适应直方图均衡</h4><ul><li><p>改善图像<strong>对比度</strong></p></li><li><p>自适应直方图均衡将图像<strong>分割成区域</strong>，然后均衡这些区域中的直方图，以改善图像对比度</p></li><li><p>使用效果</p><ul><li><img src="image-20230717210346666-1711976615648-20.png" style="zoom: 80%;"></li></ul></li><li><p>调用函数</p></li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">'''- adaptive 设置为True，将在图像上运行自适应直方图均衡化- clip_limit 用于限制自适应直方图均衡的对比度， 使用较小的值(例如10)可以生成良好的对比度受限图像'''image.histeq(adaptive=False, clip_limit=-1)# 例子img = sensor.snapshot().histeq(adaptive=True, clip_limit=3)print(clock.fps())<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="5-4-2-中值滤波"><a href="#5-4-2-中值滤波" class="headerlink" title="5.4.2 中值滤波"></a>5.4.2 中值滤波</h4><ul><li>在<strong>保留边缘</strong>的条件下，中值滤波是用来<strong>平滑表面</strong>的最佳滤波，但是<strong>运行速度极慢</strong></li><li>调用函数</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">'''- Size 是内核大小。取1是3x3内核，取2是5x5内核或更大内核- percentile 控制内核中所使用值的百分位数，默认每个像素使用相邻的第五十个百分位数（中心）替换- threshold 设置为True，启动图像的自适应阈值处理，根据环境像素的亮度（核函数周围的像素的亮度有关），   将像素设置为1或者0'''median(size, percentile=0.5, threshold=False)# 例子img.median(1, percentile=0.5)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="5-4-3-中点滤波"><a href="#5-4-3-中点滤波" class="headerlink" title="5.4.3 中点滤波"></a>5.4.3 中点滤波</h4><ul><li>跟中值滤波有区别，没看懂！！！</li><li>调用函数</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">'''- Size 内核大小- bias 图像混合的程度- threshold 设置为True，启动图像的自适应阈值处理，根据环境像素的亮度（核函数周围的像素的亮度有关），   将像素设置为1或者0'''image.midpoint(size, bias=0.5, threshold=False)# 例子img.midpoint(1, bias=0.5)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="5-4-4-高斯滤波"><a href="#5-4-4-高斯滤波" class="headerlink" title="5.4.4 高斯滤波"></a>5.4.4 高斯滤波</h4><ul><li>平滑图像</li><li>使用效果<ul><li><img src="image-20230717213020972-1711976615648-21.png" style="zoom:80%;"></li></ul></li><li>调用函数</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">'''- size- unsharp 设置为True，不仅进行高斯滤波操作，还执行非锐化掩模操作，提高边缘的图像清晰度- mul 用来与卷积像素结果相乘的数字- add 与卷积结果相加的数字- threshold 设置为True，启动图像的自适应阈值处理，根据环境像素的亮度（核函数周围的像素的亮度有关），   将像素设置为1或者0'''image.gaussian(size, unsharp=False, mul, add=0, threshold=False)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="5-4-5-自定义卷积函数"><a href="#5-4-5-自定义卷积函数" class="headerlink" title="5.4.5 自定义卷积函数"></a>5.4.5 自定义卷积函数</h4><ul><li>通过自行设计过滤器内核对图像进行卷积</li><li>使用函数</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">'''- size 设置内核大小，内核的大小控制为((size*2)+1)x((size*2)+1)像素- kernel 内核，可为一个元组或一个取值[-128:127]的列表- mul- add- threshold'''image.morph(size, kernel, mul, add=0, threshold=False)# 使用例子kernel_size = 1 # 3x3==1, 5x5==2, 7x7==3, etc.kernel = [-2, -1,  0, \          -1,  1,  1, \           0,  1,  2]img = sensor.snapshot()# Run the kernel on every pixel of the image.img.morph(kernel_size, kernel)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Tensorflow 2.0</title>
      <link href="/2024/02/06/tensorflow-2-0/"/>
      <url>/2024/02/06/tensorflow-2-0/</url>
      
        <content type="html"><![CDATA[<h2 id="一、神经网络设计过程"><a href="#一、神经网络设计过程" class="headerlink" title="一、神经网络设计过程"></a>一、神经网络设计过程</h2><h3 id="1-1-神经网络训练过程"><a href="#1-1-神经网络训练过程" class="headerlink" title="1.1 神经网络训练过程"></a>1.1 神经网络训练过程</h3><ul><li><p>采集大量<strong>数据对</strong>（输入特征，标签）构成数据集</p></li><li><p>将数据集<strong>喂入</strong>搭建好的神经<strong>网络结构</strong></p></li><li><p>网络<strong>优化参数</strong>得到模型</p></li><li><p>模型读取新输入特征</p></li><li><p>输出识别结果</p></li></ul><h3 id="1-2-损失函数（loss-function）"><a href="#1-2-损失函数（loss-function）" class="headerlink" title="1.2 损失函数（loss function）"></a>1.2 损失函数（loss function）</h3><ul><li><strong>衡量预测值（y）与实际值（y_）的差距</strong></li><li>定量判断 权重$W$ 和 偏置$b$ 的优劣，当损失函数输出最小时，参数$W、b$ 会出现最优值</li></ul><h4 id="1-2-1-均方误差（MSE）"><a href="#1-2-1-均方误差（MSE）" class="headerlink" title="1.2.1 均方误差（MSE）"></a>1.2.1 均方误差（MSE）</h4><ul><li>$MSE(y_{-},y) = \frac{\sum^n_{k=0}(y-y_{-})^2}{n}$</li></ul><h3 id="1-3-梯度"><a href="#1-3-梯度" class="headerlink" title="1.3 梯度"></a>1.3 梯度</h3><ul><li>模型训练的目的是：找到一组参数$W、b$，使 $loss\ function$ 最小</li><li><strong>损失函数输出值减小的方向，即函数梯度下降的方向</strong><ul><li>梯度：函数对各参数求偏导后的向量</li></ul></li></ul><h4 id="1-3-1-梯度下降"><a href="#1-3-1-梯度下降" class="headerlink" title="1.3.1 梯度下降"></a>1.3.1 梯度下降</h4><ul><li>参数更新：<ul><li>$w_{t+1} = w_t - lr*\frac{\partial loss}{\partial w_t}$</li><li>$b_{t+1} = b_t - lr * \frac{\partial loss}{\partial b_t}$</li><li>$w_{t+1} * x + b_{t+1} \rightarrow y$</li></ul></li><li>上式中，$lr$ 为学习率（$learning$ $rate$），是梯度下降的速度，是一个超参数，当 $lr$ 设置过小时，收敛过程会变得十分缓慢，过大时，梯度可能会在最小值附近来回震荡，甚至无法收敛<img src="/2024/02/06/tensorflow-2-0/image-20240206125753088.png"></li></ul><h3 id="1-4-反向传播"><a href="#1-4-反向传播" class="headerlink" title="1.4 反向传播"></a>1.4 反向传播</h3><ul><li>从后向前，逐层求损失函数对每层神经元参数的偏导数，迭代更新所有参数</li></ul><h3 id="1-5-感受训练过程"><a href="#1-5-感受训练过程" class="headerlink" title="1.5 感受训练过程"></a>1.5 感受训练过程</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python">import tensorflow as tf# 设定可训练参数 w 的随机初始值为 5w = tf.Variable(tf.constant(5, dtype = tf.float32))# 学习率 lr 设置为 0.01lr = 0.01# 循环迭代次数 40次epoch = 40for epoch in range(epoch):    with tf.GradientTape() as tape:        # 损失函数 loss 定义为 (w + 1)^2        loss = tf.square(w + 1)        # .gradient()，指定损失函数 loss 关于 w 求导    grads = tape.gradient(loss, w)        # .assign_sub()，让变量做自减，即，w -= lr * grads    w.assign_sub(lr * grads)    print("After %s epoch, w is %f, loss is %f" % (epoch, w.numpy(), loss))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="二、Tensorflow-2-0-——-基本知识"><a href="#二、Tensorflow-2-0-——-基本知识" class="headerlink" title="二、Tensorflow 2.0 —— 基本知识"></a>二、Tensorflow 2.0 —— 基本知识</h2><h3 id="2-1-创建-tensor"><a href="#2-1-创建-tensor" class="headerlink" title="2.1 创建 tensor"></a>2.1 创建 tensor</h3><ul><li>张量（$Tensor$）：<strong>多维数组</strong>（列表），可以表示0阶到n阶数组</li><li>阶：张量的维数</li></ul><table><thead><tr><th align="center">维数</th><th align="center">阶</th><th align="center">名字</th><th align="center">例子</th></tr></thead><tbody><tr><td align="center">0-D</td><td align="center">0</td><td align="center">标量 scalar</td><td align="center">s = 1</td></tr><tr><td align="center">1-D</td><td align="center">1</td><td align="center">向量 vector</td><td align="center">v = [1, 2, 3]</td></tr><tr><td align="center">2-D</td><td align="center">2</td><td align="center">矩阵 matrix</td><td align="center">m = [[1, 2, 3], [4, 5 6]]</td></tr><tr><td align="center">n-D</td><td align="center">n</td><td align="center">张量 tensor</td><td align="center">t = [[[[…]]]]</td></tr></tbody></table><h4 id="2-1-1-普通-tensor"><a href="#2-1-1-普通-tensor" class="headerlink" title="2.1.1 普通 tensor"></a>2.1.1 普通 tensor</h4><ul><li><code>tf.constant(张量内容, dtype = 数据类型（可选）)</code></li></ul><p>例如：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">import tensorflow as tfa = tf.constant([1, 5], dtype = tf.int64)print(a)print(a.dtype)print(a.shape)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果：</p><blockquote><pre class="line-numbers language-none"><code class="language-none">tf.Tensor([1 5], shape=(2,), dtype=int64)&lt;dtype: 'int64'&gt;(2,)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></blockquote><h4 id="2-1-2-numpy-转-tensor"><a href="#2-1-2-numpy-转-tensor" class="headerlink" title="2.1.2 numpy 转 tensor"></a>2.1.2 numpy 转 tensor</h4><ul><li><code>tf.convert_to_tensor(数据名, dtype = 数据类型（可选）)</code></li></ul><p>例如：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">import tensorflow as tfimport numpy as npa = np.arange(0, 5)b = tf.convert_to_tensor(a, dtype = tf.int64)print(a)print(b)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果：</p><blockquote><pre class="line-numbers language-none"><code class="language-none">[0 1 2 3 4]tf.Tensor([0 1 2 3 4], shape=(5,), dtype=int64)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></blockquote><h4 id="2-1-3-同值-tensor"><a href="#2-1-3-同值-tensor" class="headerlink" title="2.1.3 同值 tensor"></a>2.1.3 同值 tensor</h4><ul><li><p><code>tf.zeros(维度)</code>：全 $0$ $tensor$</p></li><li><p><code>tf.ones(维度)</code>：全 $1$ $tensor$</p></li><li><p><code>tf.fill(维度, 指定值)</code>：全为指定值的 $tensor$</p></li></ul><p>例如：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">import tensorflow as tfa = tf.zeros([2, 3])b = tf.ones(4)c = tf.fill([2, 2], 9)print(a)print(b)print(c)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果：</p><blockquote><pre class="line-numbers language-none"><code class="language-none">tf.Tensor([[0. 0. 0.] [0. 0. 0.]], shape=(2, 3), dtype=float32) tf.Tensor([1. 1. 1. 1.], shape=(4,), dtype=float32)tf.Tensor([[9 9] [9 9]], shape=(2, 2), dtype=int32)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></blockquote><h4 id="2-1-4-统计分布-tensor"><a href="#2-1-4-统计分布-tensor" class="headerlink" title="2.1.4 统计分布 tensor"></a>2.1.4 统计分布 tensor</h4><ul><li><p><code>tf.random.normal(维度, mean = 均值, stddev = 标准差)</code>：正太分布随机数，默认均值0，标准差1</p></li><li><p><code>tf.random.truncated_normal(维度, mean = 均值, stddev = 标准差)</code>：生成$(\mu-2\sigma, \mu+2\sigma)$之间的正态分布值，若生成值在$(\mu-2\sigma, \mu+2 \sigma)$之外，会进行重新生成，保证了取值在均值附近</p></li><li><p>标准差计算公式：$\sigma = \sqrt{\frac{\sum^n_{i = 1}(x_i - \bar x)^2}{n}}$</p></li><li><p><code>tf.random.uniform(维度, minval = 最小值, maxval = 最大值)</code>：均匀分布随机数</p></li></ul><p>例如：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">import tensorflow as tfd = tf.random.normal([2, 2], mean = 0.5, stddev = 1)print(d)e = tf.random.truncated_normal([2, 2], mean = 0.5, stddev = 1)print(e)f = tf.random.uniform([2, 2], minval = 0, maxval = 1)print(f)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果：</p><blockquote><pre class="line-numbers language-none"><code class="language-none">tf.Tensor([[-1.7673643   1.8214508 ] [ 1.3998327  -0.46976972]], shape=(2, 2), dtype=float32) tf.Tensor([[ 0.9264284  -0.69317317] [ 2.2075253   1.5080855 ]], shape=(2, 2), dtype=float32)  tf.Tensor([[0.7370062  0.24481273] [0.06990469 0.4966843 ]], shape=(2, 2), dtype=float32)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></blockquote><h3 id="2-2-常用函数"><a href="#2-2-常用函数" class="headerlink" title="2.2 常用函数"></a>2.2 常用函数</h3><h4 id="2-2-1-类型强转-极值"><a href="#2-2-1-类型强转-极值" class="headerlink" title="2.2.1 类型强转 &amp; 极值"></a>2.2.1 类型强转 &amp; 极值</h4><ul><li><code>tf.cast(张量名, dtype = 数据类型)</code>：强制类型转换</li><li><code>tf.reduce_min(张量名)</code>：计算张量维度上元素的最小值</li><li><code>tf.reduce_max(张量名)</code>：计算张量维度上的元素最大值</li></ul><p>例如：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">import tensorflow as tfx1 = tf.constant([1., 2., 3.], dtype = tf.float64)print(x1)x2 = tf.cast(x1, tf.int32)print(x2)print(tf.reduce_min(x2), tf.reduce_max(x2))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果：</p><blockquote><pre class="line-numbers language-none"><code class="language-none">tf.Tensor([1. 2. 3.], shape=(3,), dtype=float64)tf.Tensor([1 2 3], shape=(3,), dtype=int32)tf.Tensor(1, shape=(), dtype=int32) tf.Tensor(3, shape=(), dtype=int32)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></blockquote><h4 id="2-2-2-参数-axis"><a href="#2-2-2-参数-axis" class="headerlink" title="2.2.2 参数 axis"></a>2.2.2 参数 axis</h4><ul><li><p>在一个二维 $tensor$ 或数组中，可以通过调整 $axis$ 等于 $0$ 或 $1$ 控制执行维度</p><ul><li><p>$axis = 0$ ：代表跨行（经度，down）</p></li><li><p>$axis = 1$ ：代表跨列（纬度，across）</p></li><li><p>若不指定 $axis$ ，则所有元素参与计算</p></li></ul></li></ul><p><img src="/2024/02/06/tensorflow-2-0/image-20240207111416067.png"></p><ul><li><code>tf.reduce_mean(张量名, axis = 操作轴)</code>：计算 $tensor$ 沿指定维度的平均值</li><li><code>tf.reduce_sum(张量名, axis = 操作轴)</code>：计算 $tensor$ 沿指定维度的和</li></ul><p>例如：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">import tensorflow as tfx = tf.constant([[1, 2, 3], [1, 2, 3]])print(x)print(tf.reduce_mean(x))print(tf.reduce_sum(x, axis = 1))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果：</p><blockquote><pre class="line-numbers language-none"><code class="language-none">tf.Tensor([[1 2 3] [1 2 3]], shape=(2, 3), dtype=int32) tf.Tensor(2, shape=(), dtype=int32)tf.Tensor([6 6], shape=(2,), dtype=int32)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></blockquote><ul><li><code>tf.argmax(张量名, axis = 操作轴)</code>：返回张量沿指定维度最大值的索引</li></ul><p>举例：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">import tensorflow as tfimport numpy as nptest = np.array([[1, 2, 3], [2, 3, 4], [5, 4, 3], [8, 7, 2]])print(test)print(tf.argmax(test, axis = 0)) # 返回每一列最大值的索引print(tf.argmax(test, axis = 1)) # 返回每一行最大值的索引<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果：</p><blockquote><pre class="line-numbers language-none"><code class="language-none">[[1 2 3] [2 3 4] [5 4 3] [8 7 2]] tf.Tensor([3 3 1], shape=(3,), dtype=int64)tf.Tensor([2 2 0 0], shape=(4,), dtype=int64)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></blockquote><h4 id="2-2-3-变量标记“可训练”"><a href="#2-2-3-变量标记“可训练”" class="headerlink" title="2.2.3 变量标记“可训练”"></a>2.2.3 变量标记“可训练”</h4><ul><li><code>tf.Variable(初始值)</code>：将变量标记为“可训练”，被标记的变量会在<strong>反向传播中记录梯度信息</strong>。神经网络训练中，常用该函数<strong>标记待训练参数</strong></li></ul><p>例如：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">'''注释：首先生成正太分布随机数，再给生成的随机数标记为可训练，之后在反向传播中就可以通过梯度下降更新参数 w 了'''w = tf.Variable(tf.random.normal([2, 2], mean = 0, stddev = 1))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-2-4-数学运算"><a href="#2-2-4-数学运算" class="headerlink" title="2.2.4 数学运算"></a>2.2.4 数学运算</h4><ul><li><code>tf.add(张量1, 张量2)</code>、<code>tf.subtract(张量1, 张量2)</code>、<code>tf.multiply(张量1, 张量2)</code>、<code>tf.divide(张量1, 张量2)</code>：<strong>对应元素</strong>四则运算，只有<strong>维度相同</strong>的张量才可以做四则运算</li></ul><p>举例：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">import tensorflow as tfa = tf.ones([1, 3])b = tf.fill([1, 3], 3.)print(a)print(b)print(tf.add(a, b))print(tf.subtract(a, b))print(tf.multiply(a, b))print(tf.divide(a, b))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果：</p><blockquote><pre class="line-numbers language-none"><code class="language-none">tf.Tensor([[1. 1. 1.]], shape=(1, 3), dtype=float32)tf.Tensor([[3. 3. 3.]], shape=(1, 3), dtype=float32)tf.Tensor([[4. 4. 4.]], shape=(1, 3), dtype=float32)tf.Tensor([[-2. -2. -2.]], shape=(1, 3), dtype=float32)tf.Tensor([[3. 3. 3.]], shape=(1, 3), dtype=float32)tf.Tensor([[0.33333334 0.33333334 0.33333334]], shape=(1, 3), dtype=float32)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></blockquote><ul><li><code>tf.square</code>(张量名)、<code>tf.pow(张量名, n次方数)</code>、<code>tf.sqrt(张量名)</code>：平方、次方、开方<ul><li>其中，需要注意的是<code>tf.sqrt()</code><strong>不能对整型数据进行开方</strong>，只能对浮点型数据进行运算</li></ul></li></ul><p>举例：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">import tensorflow as tfa = tf.fill([1, 2], 3.)print(a)print(tf.pow(a, 3))print(tf.square(a))print(tf.sqrt(a))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果：</p><blockquote><pre class="line-numbers language-none"><code class="language-none">tf.Tensor([[3. 3.]], shape=(1, 2), dtype=float32)tf.Tensor([[27. 27.]], shape=(1, 2), dtype=float32)tf.Tensor([[9. 9.]], shape=(1, 2), dtype=float32)tf.Tensor([[1.7320508 1.7320508]], shape=(1, 2), dtype=float32)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></blockquote><ul><li><code>tf.matmul(矩阵1, 矩阵2)</code>：矩阵乘</li></ul><p>举例：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">import tensorflow as tfa = tf.ones([3, 2])b = tf.fill([2, 3], 3.)print(tf.matmul(a, b))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果：</p><blockquote><pre class="line-numbers language-none"><code class="language-none">tf.Tensor([[6. 6. 6.] [6. 6. 6.] [6. 6. 6.]], shape=(3, 3), dtype=float32)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></blockquote><h4 id="2-2-5-构建数据集"><a href="#2-2-5-构建数据集" class="headerlink" title="2.2.5 构建数据集"></a>2.2.5 构建数据集</h4><ul><li><code>tf.data.Dataset.from_tensor_slices((输入特征, 标签))</code>：切分传入张量的第一维度，<strong>生成输入特征/标签对</strong>，构建数据集（$numpy$ 和 $tensor$ 格式都可用该读入数据）</li></ul><p>举例：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">import tensorflow as tffeatures = tf.constant([12, 23, 10, 17])labels = tf.constant([0, 1, 1, 0])dataset = tf.data.Dataset.from_tensor_slices((features, labels))print(dataset)for element in dataset:    print(element)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果：</p><blockquote><pre class="line-numbers language-none"><code class="language-none">&lt;TensorSliceDataset shapes: ((), ()), types: (tf.int32, tf.int32)&gt;(&lt;tf.Tensor: shape=(), dtype=int32, numpy=12&gt;, &lt;tf.Tensor: shape=(), dtype=int32, numpy=0&gt;)(&lt;tf.Tensor: shape=(), dtype=int32, numpy=23&gt;, &lt;tf.Tensor: shape=(), dtype=int32, numpy=1&gt;)(&lt;tf.Tensor: shape=(), dtype=int32, numpy=10&gt;, &lt;tf.Tensor: shape=(), dtype=int32, numpy=1&gt;)(&lt;tf.Tensor: shape=(), dtype=int32, numpy=17&gt;, &lt;tf.Tensor: shape=(), dtype=int32, numpy=0&gt;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></blockquote><h4 id="2-2-6-求导运算"><a href="#2-2-6-求导运算" class="headerlink" title="2.2.6 求导运算"></a>2.2.6 求导运算</h4><ul><li><code>tf.GradientTape()</code></li><li>一般使用 $with$ 结构记录计算过程，$gradient$ 求出张量的梯度</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">with tf.GradientTape() as tape:    # 若干计算过程grad = tape.gradient(函数, 求导变量)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>举例：</p><p>计算 $\frac{\partial w^2}{\partial w} = 2w$ ，当 $w = 3.0$ 时的导数值</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">import tensorflow as tfwith tf.GradientTape() as tape:    w = tf.Variable(tf.constant(3.0))    loss = tf.pow(w, 2)grad = tape.gradient(loss, w)print(grad)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果：</p><blockquote><pre class="line-numbers language-none"><code class="language-none">tf.Tensor(6.0, shape=(), dtype=float32)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></blockquote><h4 id="2-2-7-枚举"><a href="#2-2-7-枚举" class="headerlink" title="2.2.7 枚举"></a>2.2.7 枚举</h4><ul><li><code>enumerate(列表名)</code>：$python$ 内建函数，可遍历每个元素（如列表、元组或字符串），组合为：索引 + 元素</li></ul><p>举例：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">seq = ['one', 'two', 'three']for i, element in enumerate(seq):    print(i, element)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>运行结果：</p><blockquote><pre class="line-numbers language-none"><code class="language-none">0 one1 two2 three<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></blockquote><h4 id="2-2-8-独热编码-one-hot-encoding"><a href="#2-2-8-独热编码-one-hot-encoding" class="headerlink" title="2.2.8 独热编码 (one-hot encoding)"></a>2.2.8 独热编码 (one-hot encoding)</h4><ul><li><p><code>tf.one_hot(待转换数据, depth = 几分类)</code>：将待转换数据转换为 $one-hot$ 形式的数据输出。分类问题中，常用独热编码做标签，标记类别 <strong>$1$ 表示是，$0$ 表示非</strong>，编码的<strong>最小标签值是 $0$</strong></p></li><li><p>编码规则：以鸢尾花分类为例，以 $0$ 代表狗尾草鸢尾，$1$ 表示杂色鸢尾，$2$ 表示弗吉尼亚鸢尾</p><ul><li>对于标签 $1$</li><li>独热码：$(0. \quad 1. \quad 0.)$ ，表示非狗尾草鸢尾、是杂色鸢尾、非弗吉尼亚鸢尾</li></ul></li></ul><p>举例：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">import tensorflow as tfclasses = 3labels = tf.constant([1, 0, 2]) # 最小值为0，最大值为2output = tf.one_hot(labels, depth = classes)print(output)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果：</p><blockquote><pre class="line-numbers language-none"><code class="language-none">tf.Tensor([[0. 1. 0.] [1. 0. 0.] [0. 0. 1.]], shape=(3, 3), dtype=float32)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></blockquote><h4 id="2-2-9-得分概率化"><a href="#2-2-9-得分概率化" class="headerlink" title="2.2.9 得分概率化"></a>2.2.9 得分概率化</h4><ul><li><code>tf.nn.softmax(输出的各类得分)</code>：当 $n$ 分类的 $n$ 个输出 $(y_0,y_1,…,y_{n-1})$ 通过 $softmax()$ 函数，使得概率化，且<strong>各类得分概率化后的总和为 $1$<strong>。通过神经网络权重 $w$ 和偏置 $b$ 计算得到的每种类型的得分，这些数字只有</strong>符合概率分布后，才可以与独热码的标签作比较</strong><ul><li>使用公式$\frac{e^{y_i}}{\sum^n_{j = 0} e^{y_j}}$，可将输出的得概率化</li></ul></li></ul><p><img src="/2024/02/06/tensorflow-2-0/image-20240207150745130.png" alt="网络计算输出得分"></p><p><img src="/2024/02/06/tensorflow-2-0/image-20240207150934015.png" alt="得分概率化"></p><p>举例：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">import tensorflow as tfy = tf.constant([1.01, 2.01, -0.66]) # 神经网络前向传播后的结果y_pro = tf.nn.softmax(y)print(y_pro)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果：</p><blockquote><pre class="line-numbers language-none"><code class="language-none">tf.Tensor([0.25598174 0.69583046 0.04818781], shape=(3,), dtype=float32)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></blockquote><h4 id="2-2-10-参数自更新"><a href="#2-2-10-参数自更新" class="headerlink" title="2.2.10 参数自更新"></a>2.2.10 参数自更新</h4><ul><li><code>可训练变量.assign_sub(变量自减的内容)</code>：自减运算，更新参数值并返回。调用 $assign_sub$ 前，先用 $tf.Variable()$ 定义变量为可训练（可自更新）</li></ul><p>举例：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">import tensorflow as tfw = tf.Variable(4)w.assign_sub(1)print(w)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果：</p><blockquote><pre class="line-numbers language-none"><code class="language-none">&lt;tf.Variable 'Variable:0' shape=() dtype=int32, numpy=3&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></blockquote><h3 id="2-3-案例-——-鸢尾花分类"><a href="#2-3-案例-——-鸢尾花分类" class="headerlink" title="2.3. 案例 —— 鸢尾花分类"></a>2.3. 案例 —— 鸢尾花分类</h3><h4 id="2-3-1-Iris-数据集"><a href="#2-3-1-Iris-数据集" class="headerlink" title="2.3.1 Iris 数据集"></a>2.3.1 Iris 数据集</h4><ul><li>$Iris$ 数据集共有 $150$ 组，每组包括花萼长、花萼宽、花瓣长、花瓣宽 $4$ 个输入特征。同时，给出了每组特征对应的鸢尾花类别，类别包括狗尾草鸢尾花、杂色鸢尾花、弗吉尼亚鸢尾花 $3$ 类，分别用数字 $0,1,2$ 表示</li></ul><p><img src="/2024/02/06/tensorflow-2-0/image-20240207153922533.png"></p><ul><li>从 $sklearn$ 包 $datasets$ 读入数据集</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">from sklearn.datasets import load_irisx_data = load_iris().data   # 返回 iris 数据集所有输入特征y_data = load_iris().target # 返回 iris 数据集所有标签<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li>另外，可将 $Iris$ 数据集通过 $pandas$ 库绘制表格进行可视化</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">from sklearn import datasetsfrom pandas import DataFrameimport pandas as pdx_data = datasets.load_iris().datay_data = datasets.load_iris().targetprint("x_data from datasets：\n", x_data)print("y_data from datasets：\n", y_data)x_data = DataFrame(x_data, columns = ['花萼长', '花萼宽', '花瓣长', '花瓣宽'])pd.set_option('display.unicode.east_asian_width', True) # 设置列名对齐print("x_data add index：\n", x_data)x_data['类别'] = y_data # 新加一列，列名为 类别，数据为 y_dataprint("x_data add a column：\n", x_data)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-3-2-实现过程概览"><a href="#2-3-2-实现过程概览" class="headerlink" title="2.3.2 实现过程概览"></a>2.3.2 实现过程概览</h4><ul><li><p>准备数据集</p><ul><li>数据集读入</li><li>数据集乱序</li><li>生成训练集和测试集 $(x_train / y_{-}train,\quad x_test/y_{-}test)$</li><li>配对（输入特征，标签），每次读入一小撮 $(batch)$</li></ul></li><li><p>搭建网络</p><ul><li>定义神经网络中所有可训练参数</li></ul></li><li><p>参数优化</p><ul><li>嵌套循环迭代，$with$ 结构更新参数，显示当前 $loss$</li></ul></li><li><p>测试效果</p><ul><li>计算当前参数前向传播后的准确率，显示当前 $acc$</li></ul></li><li><p>$acc/loss$ 可视化</p></li></ul><h4 id="2-3-3-准备数据集"><a href="#2-3-3-准备数据集" class="headerlink" title="2.3.3 准备数据集"></a>2.3.3 准备数据集</h4><h5 id="2-3-3-1-数据集读入"><a href="#2-3-3-1-数据集读入" class="headerlink" title="2.3.3.1 数据集读入"></a>2.3.3.1 数据集读入</h5><pre class="line-numbers language-python" data-language="python"><code class="language-python">from sklearn import datasetsx_data = datasets.load_iris().datay_data = datasets.load_iris().target<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h5 id="2-3-3-2-数据集乱序"><a href="#2-3-3-2-数据集乱序" class="headerlink" title="2.3.3.2 数据集乱序"></a>2.3.3.2 数据集乱序</h5><pre class="line-numbers language-python" data-language="python"><code class="language-python">np.random.seed(116) # 使用相同的种子，使 特征/标签 一一对应np.random.shuffle(x_data)np.random.seed(116)np.random.shuffle(y_data)tf.random.set_seed(116)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="2-3-3-3-划分-train-test"><a href="#2-3-3-3-划分-train-test" class="headerlink" title="2.3.3.3 划分 train &amp; test"></a>2.3.3.3 划分 train &amp; test</h5><pre class="line-numbers language-python" data-language="python"><code class="language-python">x_train = x_data[:-30]y_train = y_data[:-30]x_test = x_data[-30:]y_test = y_data[-30:]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="2-3-3-4-特征-标签-配对"><a href="#2-3-3-4-特征-标签-配对" class="headerlink" title="2.3.3.4 特征/标签 配对"></a>2.3.3.4 特征/标签 配对</h5><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 每 32 组标签对，打包为一个 batch# 喂入神经网络的数据，是以 batch 为单位train_db = tf.data.Dataset.from_tensor_slices((x_train, y_train)).batch(32)test_db = tf.data.Dataset.from_tensor_slices((x_test, y_test)).batch(32)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-3-4-搭建网络"><a href="#2-3-4-搭建网络" class="headerlink" title="2.3.4 搭建网络"></a>2.3.4 搭建网络</h4><ul><li>定义神经网络中的所有可训练参数</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">w1 = tf.Variable(tf.random.truncated_normal([4, 3], stddev = 0.1, seed = 1))b1 = tf.Variable(tf.random.truncated_normal([3], stddev = 0.1, seed = 1))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="2-3-5-参数优化"><a href="#2-3-5-参数优化" class="headerlink" title="2.3.5 参数优化"></a>2.3.5 参数优化</h4><ul><li>嵌套循环迭代，$with$ 结构更新参数，显示当前 $loss$</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">for epoch in range(epoch):    for step, (x_train, y_train) in enumerate(train_db): # batch 级别迭代        with tf.GradientTape() as tape: # 记录梯度信息            # 前向传播过程计算 y            # 计算总 loss        grads = tape.gradient(loss, [w1, b1])        w1.assign_sub(lr * grads[0])        b1.assign_sub(lr * grads[1])    print("Epoch: {}, loss: {}".format(epoch, loss_all/4))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-3-6-测试效果"><a href="#2-3-6-测试效果" class="headerlink" title="2.3.6 测试效果"></a>2.3.6 测试效果</h4><ul><li>计算当前参数前向传播后的准确率，显示当前acc</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">for x_test, y_test in test_db:    y = tf.matmul(x_train, w1) + b1 # y 为预测结果    y = tf.nn.softmax(y)    # y 概率化        pred = tf.argmax(y, axis = 1) # 返回 y 中最大值的索引    pred = tf.cast(pred, dtype = y_test.dtype) # 调整数据类型与标签一致        correct = tf.cast(tf.equal(pred, y_test), dtype = tf.int32)    correct = tf.reduce_sum(correct) # 将每个 batch 中的 correct 数加起来        total_correct += int(correct) # 将所有 batch 中的 correct 数加起来    total_number += x_test.shape[0]    acc = total_correct / total_numberprint("test_acc: ", acc)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-3-7-acc-loss-可视化"><a href="#2-3-7-acc-loss-可视化" class="headerlink" title="2.3.7 acc/loss 可视化"></a>2.3.7 acc/loss 可视化</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python">plt.title('Acc Curve')plt.xlabel('Epoch')plt.ylabel('Acc')plt.plot(test_acc, label = "$Accuracy$")plt.legend()plt.show()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-3-8-完整代码"><a href="#2-3-8-完整代码" class="headerlink" title="2.3.8 完整代码"></a>2.3.8 完整代码</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 导入模块import tensorflow as tffrom sklearn import datasetsfrom matplotlib import pyplot as pltimport numpy as np<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 导入数据x_data = datasets.load_iris().datay_data = datasets.load_iris().target<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 数据集乱序np.random.seed(116) # 使用相同的种子，使 特征/标签 一一对应np.random.shuffle(x_data)np.random.seed(116)np.random.shuffle(y_data)tf.random.set_seed(116)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 划分 train 和 testx_train = x_data[:-30]y_train = y_data[:-30]x_test = x_data[-30:]y_test = y_data[-30:]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 转换 x 的数据类型# 避免之后矩阵相乘时，因数据类型不一致而报错x_train= tf.cast(x_train, tf.float32)x_test = tf.cast(x_test, tf.float32)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 特征/标签 配对# 把数据集分批次，每个批次batch组数据train_db = tf.data.Dataset.from_tensor_slices((x_train, y_train)).batch(32)test_db = tf.data.Dataset.from_tensor_slices((x_test, y_test)).batch(32)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 定义神经网络参数w1 = tf.Variable(tf.random.truncated_normal([4, 3], stddev = 0.1, seed = 1))b1 = tf.Variable(tf.random.truncated_normal([3], stddev = 0.1, seed = 1))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 定义超参数及画图要用的acc/loss列表lr = 0.1 # 学习率epoch = 500 # 循环500轮train_loss_results = [] # 将每轮的loss记录到此列表中，为后续画loss曲线提供数据test_acc = [] # 将每轮的acc记录在此列表中，为后续画acc曲线提供数据loss_all = 0 # 每轮分为4个step，loss_all记录4个step生成的4个loss的和<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 参数优化for epoch in range(epoch):    for step, (x_train, y_train) in enumerate(train_db): # batch 级别迭代        with tf.GradientTape() as tape: # 记录梯度信息            # 前向传播过程计算 y            y = tf.matmul(x_train, w1) + b1            y = tf.nn.softmax(y)            y_ = tf.one_hot(y_train, depth = 3)                        # 计算总 loss            loss = tf.reduce_mean(tf.square(y_ - y))            loss_all += loss.numpy()                # loss 对 w1 和 b1 求偏导        grads = tape.gradient(loss, [w1, b1])                # 参数更新        w1.assign_sub(lr * grads[0])        b1.assign_sub(lr * grads[1])        #每个 epoch 打印 loss 信息    print("Epoch: {}, loss: {}".format(epoch, loss_all / 4))    train_loss_results.append(loss_all / 4) # 记录每个epoch的平均loss    loss_all = 0 # 为下一次epoch的loss做准备            # 测试效果    total_correct, total_number = 0, 0 # 两个变量分别为预测对的样本个数和测试的总样本数    for x_test, y_test in test_db:        # 使用更新后的参数进行预测        y = tf.matmul(x_test, w1) + b1 # y 为预测结果        y = tf.nn.softmax(y)    # y 概率化        pred = tf.argmax(y, axis = 1) # 返回 y 中最大值的索引        pred = tf.cast(pred, dtype = y_test.dtype) # 调整数据类型与标签一致        correct = tf.cast(tf.equal(pred, y_test), dtype = tf.int32)        correct = tf.reduce_sum(correct) # 将每个 batch 中的 correct 数加起来        total_correct += int(correct) # 将所有 batch 中的 correct 数加起来        total_number += x_test.shape[0]    acc = total_correct / total_number    test_acc.append(acc)    print("test_acc: ", acc)    print("--------------------------")<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 绘制loss曲线plt.title('Loss Function Curve')plt.xlabel('Epoch')plt.ylabel('Loss')plt.plot(train_loss_results, label = "$Loss$")plt.legend()plt.show()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 绘制acc曲线plt.title('Acc Curve')plt.xlabel('Epoch')plt.ylabel('Acc')plt.plot(test_acc, label = "$Accuracy$")plt.legend()plt.show()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果：</p><p><img src="/2024/02/06/tensorflow-2-0/image-20240207173134638.png"></p><p><img src="/2024/02/06/tensorflow-2-0/image-20240207173233205.png"></p><h2 id="三、Tensorflow-2-0-——-网络优化"><a href="#三、Tensorflow-2-0-——-网络优化" class="headerlink" title="三、Tensorflow 2.0 —— 网络优化"></a>三、Tensorflow 2.0 —— 网络优化</h2><ul><li>使用<strong>正则化</strong>减少过拟合，使用<strong>优化器</strong>更新网络参数</li></ul><h3 id="3-1-一些函数"><a href="#3-1-一些函数" class="headerlink" title="3.1 一些函数"></a>3.1 一些函数</h3><h4 id="3-1-1-条件语句"><a href="#3-1-1-条件语句" class="headerlink" title="3.1.1 条件语句"></a>3.1.1 条件语句</h4><ul><li><code>tf.where(条件语句, 真返回A, 假返回B)</code></li></ul><p>举例：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">import tensorflow as tfa = tf.constant([1, 2, 3, 1, 1])b = tf.constant([0, 1, 3, 4, 5])# tf.greater()，将两个 tensor 的对应元素进行比较c = tf.where(tf.greater(a, b), a, b)print("c: ", c)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果：</p><blockquote><pre class="line-numbers language-none"><code class="language-none">c:  tf.Tensor([1 2 3 4 5], shape=(5,), dtype=int32)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></blockquote><h4 id="3-1-2-0-1-的随机数"><a href="#3-1-2-0-1-的随机数" class="headerlink" title="3.1.2 [0, 1) 的随机数"></a>3.1.2 [0, 1) 的随机数</h4><ul><li><code>tf.random.RandomState.rand(维度)</code>：返回一个 $[0, 1)$ 的随机数，若维度为空，则返回标量</li></ul><p>举例：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">import tensorflow as tfimport numpy as nprdm = np.random.RandomState(seed = 1) # seed = 常数，使每次生成的随机数相同a = rdm.rand() # 标量b = rdm.rand(2, 3) # 2行3列，维度不能加 [] ，会报错print(a)print(b)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果：</p><blockquote><pre class="line-numbers language-none"><code class="language-none">0.417022004702574[[7.20324493e-01 1.14374817e-04 3.02332573e-01] [1.46755891e-01 9.23385948e-02 1.86260211e-01]]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></blockquote><h4 id="3-1-3-生成网格坐标点"><a href="#3-1-3-生成网格坐标点" class="headerlink" title="3.1.3 生成网格坐标点"></a>3.1.3 生成网格坐标点</h4><ul><li><code>np.mgrid[起始值 : 结束值 : 步长, 起始值 : 结束值 : 步长]</code>：[起始值, 结束值)</li><li><code>变量.ravel()</code>：将变量一维化，变为一维数组</li><li><code>np.c_[数组1, 数组2, ...]</code>：使返回的间隔数值点配对</li></ul><p>举例：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">import tensorflow as tfimport numpy as npx, y = np.mgrid[1:3:1, 2:4:0.5]grid = np.c_[x.ravel(), y.ravel()]print(x)print(y)print(grid)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果：</p><blockquote><pre class="line-numbers language-none"><code class="language-none">[[1. 1. 1. 1.] [2. 2. 2. 2.]] [[2.  2.5 3.  3.5] [2.  2.5 3.  3.5]] [[1.  2. ] [1.  2.5] [1.  3. ] [1.  3.5] [2.  2. ] [2.  2.5] [2.  3. ] [2.  3.5]]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></blockquote><h3 id="3-2-复杂度-学习率"><a href="#3-2-复杂度-学习率" class="headerlink" title="3.2 复杂度 &amp; 学习率"></a>3.2 复杂度 &amp; 学习率</h3><h4 id="3-2-1-复杂度"><a href="#3-2-1-复杂度" class="headerlink" title="3.2.1 复杂度"></a>3.2.1 复杂度</h4><ul><li>复杂度分为<strong>空间复杂度</strong>和<strong>时间复杂度</strong></li><li>神经网络复杂度，常用 $NN$ 层数和 $NN$ 参数个数表示</li></ul><h5 id="3-2-1-1-空间复杂度"><a href="#3-2-1-1-空间复杂度" class="headerlink" title="3.2.1.1 空间复杂度"></a>3.2.1.1 空间复杂度</h5><ul><li>空间复杂度有<strong>层数</strong>和<strong>总参数个数</strong>两个指标<ul><li>$层数 = 隐藏层层数 + 1个输出层$</li><li>$总参数个数 = 总 w + 总b$ ，注意 $b$ ，每个神经元只有一个偏置，但是 $w$ 跟前一层神经元连接状况相关</li></ul></li></ul><h5 id="3-2-1-2-时间复杂度"><a href="#3-2-1-2-时间复杂度" class="headerlink" title="3.2.1.2 时间复杂度"></a>3.2.1.2 时间复杂度</h5><ul><li>乘加运算次数，整个网络各神经元需要计算的总次数</li></ul><h4 id="3-2-2-学习率"><a href="#3-2-2-学习率" class="headerlink" title="3.2.2 学习率"></a>3.2.2 学习率</h4><ul><li><p>参数更新计算公式</p><ul><li>$w_{t+1} = w_t - lr*\frac{\partial loss}{\partial w_t}$</li><li>$b_{t+1} = b_t - lr * \frac{\partial loss}{\partial b_t}$</li></ul></li><li><p>学习率 $lr$ 设置过小，收敛速度很慢，过大可能不收敛</p></li><li><p>可以先使用较大的学习率，快速得到较优解，然后逐步减小学习率，使模型在训练后期稳定</p></li></ul><h5 id="3-2-2-1-指数衰减学习率"><a href="#3-2-2-1-指数衰减学习率" class="headerlink" title="3.2.2.1 指数衰减学习率"></a>3.2.2.1 指数衰减学习率</h5><ul><li>$指数衰减学习率 = 初始学习率 * 学习率衰减率^{\frac{当前轮数}{多少轮衰减一次}}$</li><li>通过该公式动态改变学习率的值，其中，初始学习率、学习率衰减率、多少轮衰减一次，为超参数</li></ul><p>代码示例：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">epoch = 40LR_BASE = 0.2LR_DECAY = 0.99LR_STEP = 1for epoch in range(epoch):    lr = LR_BASE * LR_DECAY ** (epoch / LR_STEP)    with tf.GradientTape() as tape:        loss = tf.square(w + 1)    grads = tape.gradient(loss, w)        w.assign_sub(lr * grads)    print("After %s epoch, w is %f, loss is %f, lr is %f" %(epoch, w.numpy(), loss, lr))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-3-激活函数"><a href="#3-3-激活函数" class="headerlink" title="3.3 激活函数"></a>3.3 激活函数</h3><h4 id="3-3-1-Sigmoid-函数"><a href="#3-3-1-Sigmoid-函数" class="headerlink" title="3.3.1 Sigmoid 函数"></a>3.3.1 Sigmoid 函数</h4><ul><li><p><code>tf.nn.sigmoid(x)</code></p></li><li><p>$f(x)=\frac{1}{1+e^{-x}}$</p></li></ul><p><img src="/2024/02/06/tensorflow-2-0/image-20240220170857080.png"></p><ul><li>特点<ul><li><strong>易造成梯度消失</strong>，深层神经网络更新参数时，需要从输出层到输入层，逐层进行链式求导，$Sigmoid$ 函数导数取值是 $0$ - $0.25$ 之间的小数，而链式求导需要多层导数连续相乘，会出现多个 $0$ - $0.25$ 之间的小数相乘，结果将趋于 $0$，产生梯度消失，使得参数无法继续更新</li><li><strong>输出非$0$均值，收敛慢</strong>，经过 $Sigmoid$ 函数后的数据都是正数，导致收敛速度慢</li><li><strong>幂运算复杂，训练时间长</strong>，$Sigmoid$ 函数本身存在幂运算，计算复杂，导致训练时间长</li></ul></li></ul><h4 id="3-3-2-Tanh-函数"><a href="#3-3-2-Tanh-函数" class="headerlink" title="3.3.2 Tanh 函数"></a>3.3.2 Tanh 函数</h4><ul><li><p><code>tf.math.tanh(x)</code></p></li><li><p>$f(x)=\frac{1-e^{-2x}}{1+e^{-2x}}$</p></li></ul><p><img src="/2024/02/06/tensorflow-2-0/image-20240220172334130.png"></p><ul><li>特点<ul><li><strong>易造成梯度消失</strong></li><li><strong>输出是 $0$ 均值</strong></li><li><strong>幂运算复杂，训练时间长</strong></li></ul></li></ul><h4 id="3-3-3-Relu-函数"><a href="#3-3-3-Relu-函数" class="headerlink" title="3.3.3 Relu 函数"></a>3.3.3 Relu 函数</h4><ul><li><p><code>tf.nn.relu(x)</code></p></li><li><p>$ f(x)=max(x, 0) = \begin{cases}<br>0 &amp; x &lt; 0 \newline<br>x &amp; x &gt;= 0<br>\end{cases}$</p></li></ul><p><img src="/2024/02/06/tensorflow-2-0/image-20240220173213855.png"></p><ul><li>优点<ul><li><strong>在正区间，解决了梯度消失问题</strong></li><li><strong>只需判断输入是否大于$0$，计算速度快</strong></li><li><strong>收敛速度远快于 $Sigmoid$ 和 $Tanh$</strong></li></ul></li><li>缺点<ul><li><strong>输出非 $0$ 均值，收敛慢</strong></li><li><strong>$Dead$ $Relu$ 问题</strong>：某些神经元可能永远不会被激活，导致相应的参数永远不能被更新。当输入是负数时，$Relu$ 函数输出为负数，反向传播更新参数时，梯度取值为$0$，导致参数无法更新，造成神经元死亡。造成神经元死亡的根本原因是，输入 $Relu$ 函数的负数特征过多，可以改进随机初值化，避免过多的负数特征送入 $Relu$ 函数，可以通过设置更小的学习率 $lr$ ，减小参数分布的巨大变化，避免训练中产生过多负数特征进入 $Relu$ 函数</li></ul></li></ul><h4 id="3-3-4-Leaky-Relu-函数"><a href="#3-3-4-Leaky-Relu-函数" class="headerlink" title="3.3.4 Leaky Relu 函数"></a>3.3.4 Leaky Relu 函数</h4><ul><li><code>tf.nn.leaky_relu(x)</code></li><li>$f(x)=max(\alpha x, x)$</li></ul><p><img src="/2024/02/06/tensorflow-2-0/image-20240220174441482.png"></p><ul><li>$Leaky$ $Relu$ 函数是为了解决 $Relu$ 函数负区间为 $0$，引起神经元死亡的问题而设计的。$Leaky$ $Relu$函数在负区间引入斜率 $\alpha$ ，使负区间的取值不为 $0$</li><li>理论上，$Leaky$ $Relu$ 函数有 $Relu$ 函数的所有优点，且不会有 $Dead$ $ Relu$ 问题，但是在实际操作中，并没有完全证明 $Leaky$ $Relu$ 函数总是好于 $Relu$ 函数</li><li>在实际中，选择 $Relu$ 做激活函数的网络更多</li></ul><h4 id="3-3-5-一些建议"><a href="#3-3-5-一些建议" class="headerlink" title="3.3.5 一些建议"></a>3.3.5 一些建议</h4><ul><li><strong>首选 $Relu$</strong> 做激活函数</li><li><strong>学习率设置较小值</strong></li><li><strong>输入特征标准化</strong>，即让输入特征满足以 $0$ 为均值，$1$ 为标准差的正态分布</li><li><strong>初始参数中心化</strong>，即让随机生成的参数满足以 $0$ 为均值，$\sqrt{\frac{2}{当前层输入特征个数}}$ 为标准差的正态分布</li></ul><h3 id="3-4-损失函数"><a href="#3-4-损失函数" class="headerlink" title="3.4 损失函数"></a>3.4 损失函数</h3><ul><li>损失函数 ($loss$) ：是预测值 ($y$) 与已知答案 ($y_{-}$​) 的差距</li><li>神经网络的优化目标，就是找到一组参数，使得计算得到的 $loss$ 最小</li><li>主流 $loss$ 有 $3$ 种计算方法 $\begin{cases}<br>mse(Mean\ Squared\ Error) \newline<br>自定义 \newline<br>ce(Cross \ Entropy)<br>\end{cases}$</li></ul><h4 id="3-4-1-均方误差-MSE"><a href="#3-4-1-均方误差-MSE" class="headerlink" title="3.4.1 均方误差 MSE"></a>3.4.1 均方误差 MSE</h4><ul><li>$MSE(y_{-},y) = \frac{\sum^n_{k=0}(y-y_{-})^2}{n}$，即前向传播计算出的结果 $y$ 与已知答案 $y_{-}$ 之差的平方，再求平均</li><li><code>loss_mse = tf.reduce_mean(tf.square(y_-y))</code></li></ul><p>示例：</p><blockquote><p>预测酸奶日产量 $y$ ，$x1、x2$ 是影响日销量的因素</p></blockquote><p>建模前，应预先采集的数据集有：每日 $x1、x2$ 和实际销量 $y_{-}$ </p><p>此处没有提供数数据集，所以我们通过自行构造数据进行训练。随机生成 $x1、x2$  的数值，使 $y_{-}=x1+x2$ ，同时，为了使数据更真实，给求和后的 $y_{-}$ 引入随机噪声 $-0.05$ - $+0.05$ </p><p>把这套自制数据集喂入神经网络，构建一个一层的神经网络，预测酸奶日销量</p><p>代码如下：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">import tensorflow as tfimport numpy as npSEED = 23455rdm = np.random.RandomState(seed = SEED) # 生成 [0, 1) 的随机数# 构造数据x = rdm.rand(32, 2)y_ = [[x1 + x2 + (rdm.rand() / 10.0 - 0.05)] for (x1, x2) in x]x = tf.cast(x, dtype = tf.float32)w1 = tf.Variable(tf.random.normal([2, 1], stddev = 1, seed = 1))epoch = 15000lr = 0.002for epoch in range(epoch):    with tf.GradientTape() as tape:        y = tf.matmul(x, w1)        loss_mse = tf.reduce_mean(tf.square(y_ - y))            grads = tape.gradient(loss_mse, w1)    w1.assign_sub(lr * grads)        if epoch % 500 == 0:        print("After %d training steps, w1 is " % (epoch))        print(w1.numpy(), "\n")print("Final w1 is: ", w1.numpy())<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-4-2-自定义损失函数"><a href="#3-4-2-自定义损失函数" class="headerlink" title="3.4.2 自定义损失函数"></a>3.4.2 自定义损失函数</h4><blockquote><p>预测酸奶日产量 $y$ ，$x1、x2$ 是影响日销量的因素</p></blockquote><p>对于该问题，前一节使用均方误差作为损失函数，默认认为销量预测多了或少了，产生的损失是一样的。然而真实情况是，预测多了，损失成本，预测少了，损失利润，$利润 \neq 成本$。在这种情况下，使用均方误差 $MSE$ 计算 $loss$ 是无法使利益最大化的。</p><p>此时，可以使用自定义损失函数：$loss(y_{-},y)=\sum f(y_{-},y)$，使用每一个预测结果 $y$ 与实际值 $y_{-}$ 产生的损失累积和，作为 $loss$</p><p>此题，可以把损失函数 $loss$ 定义为分段函数：$f(y_{-},y)=\begin{cases}<br>PROFIT*(y_{-} - y) &amp; y&lt;y_{-} \newline<br>COST*(y - y_{-}) &amp; y&gt;=y_{-}<br>\end{cases}$​</p><ul><li><code>loss_zdy = tf.reduce_sum(tf.where(tf.greater(y,y_),COST*(y-y_),PROFIT*(y_-y)))</code></li></ul><blockquote><p>更新题目，预测酸奶销量，酸奶成本（COST）1元，酸奶利润（PROFIT）99元</p></blockquote><p>预测少了一件损失利润 $99$ 元，预测多了一件损失成本 $1$ 元。显然，预测少了损失更大，所以我们希望生成的预测函数往预测多了的方向去预测</p><p>代码如下：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">import tensorflow as tfimport numpy as npSEED = 23455rdm = np.random.RandomState(seed = SEED) # 生成 [0, 1) 的随机数# 构造数据x = rdm.rand(32, 2)y_ = [[x1 + x2 + (rdm.rand() / 10.0 - 0.05)] for (x1, x2) in x]x = tf.cast(x, dtype = tf.float32)w1 = tf.Variable(tf.random.normal([2, 1], stddev = 1, seed = 1))epoch = 10000lr = 0.002COST = 1PROFIT = 99for epoch in range(epoch):    with tf.GradientTape() as tape:        y = tf.matmul(x, w1)        loss_zdy = tf.reduce_sum(tf.where(tf.greater(y,y_),COST*(y-y_),PROFIT*(y_-y)))            grads = tape.gradient(loss_zdy, w1)    w1.assign_sub(lr * grads)        if epoch % 500 == 0:        print("After %d training steps, w1 is " % (epoch))        print(w1.numpy(), "\n")print("Final w1 is: ", w1.numpy())<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-4-3-交叉熵损失函数-CE"><a href="#3-4-3-交叉熵损失函数-CE" class="headerlink" title="3.4.3 交叉熵损失函数 CE"></a>3.4.3 交叉熵损失函数 CE</h4><ul><li>交叉熵损失函数 $CE\ (Cross Entropy)$ ：表征两个概率分布之间的距离，交叉熵越小，两个概率分布越近，交叉熵越大，两个概率分布越远</li><li>$H(y_{-},y)=-\sum (y_{-}*ln y)$​</li><li><code>tf.losses.categorical_crossentropy(y_,y)</code></li></ul><p><img src="/2024/02/06/tensorflow-2-0/image-20240222170501508.png"></p><p>使用代码验证计算结果：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">import tensorflow as tfloss_ce1 = tf.losses.categorical_crossentropy([1,0],[0.6,0.4])loss_ce2 = tf.losses.categorical_crossentropy([1,0],[0.8,0.2])print("loss_ce1: ",loss_ce1)print("loss_ce2: ",loss_ce2)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果：</p><blockquote><pre class="line-numbers language-none"><code class="language-none">loss_ce1:  tf.Tensor(0.5108256, shape=(), dtype=float32)loss_ce2:  tf.Tensor(0.22314353, shape=(), dtype=float32)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></blockquote><h4 id="3-4-4-softmax-与-交叉熵-结合"><a href="#3-4-4-softmax-与-交叉熵-结合" class="headerlink" title="3.4.4 softmax 与 交叉熵 结合"></a>3.4.4 softmax 与 交叉熵 结合</h4><ul><li>输出先经过 $softmax()$ ，让输出结果符合概率分布</li><li>再求 $y_{-}$ 与 $y$ 的交叉熵损失函数</li><li><code>tf.nn.softmax_cross_entropy_with_logits(y_,y)</code>，同时计算概率分布和交叉熵</li></ul><p>举例：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">import tensorflow as tfimport numpy as npy_ = np.array([[1,0,0],[0,1,0],[0,0,1],[1,0,0],[0,1,0]])y = np.array([[12,3,2],[3,10,1],[1,2,5].[4,6.5,1.2],[3,6,1]])y_pro = tf.nn.softmax(y)loss_ce1 = tf.losses.categorical_crossentropy(y_,y_pro)loss_ce2 = tf.nn.softmax_cross_entropy_with_logits(y_,y)print("分布计算的结果：",loss_ce1)print("结合计算的结果：",loss_ce2)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果：</p><blockquote><pre class="line-numbers language-none"><code class="language-none">分布计算的结果： tf.Tensor([1.68795487e-04 1.03475622e-03 6.58839038e-02 2.58349207e+00 5.49852354e-02], shape=(5,), dtype=float64) 结合计算的结果： tf.Tensor([1.68795487e-04 1.03475622e-03 6.58839038e-02 2.58349207e+00 5.49852354e-02], shape=(5,), dtype=float64)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></blockquote><h3 id="3-5-拟合效果"><a href="#3-5-拟合效果" class="headerlink" title="3.5 拟合效果"></a>3.5 拟合效果</h3><p><img src="/2024/02/06/tensorflow-2-0/image-20240223153137866.png"></p><ul><li><p>欠拟合：对现有数据集拟合不彻底，不能有效表征各数据点</p><ul><li><strong>增加输入特征项</strong>，给网络更多维度得输入特征</li><li><strong>增加网络参数</strong>，扩展网络规模，增加网络深度，提升模型表达力</li><li>减少正则化参数</li></ul></li><li><p>过拟合：对当前数据拟合得太好了，但对新数据难以做出正确得判断和预测，模型缺乏泛化力</p><ul><li><strong>数据清洗</strong>，减少噪声，使数据更纯净</li><li><strong>增大训练集</strong>，让模型见到更多的数据</li><li><strong>采用正则化</strong></li><li>增大正则化参数</li></ul></li></ul><h4 id="3-5-1-正则化缓解过拟合"><a href="#3-5-1-正则化缓解过拟合" class="headerlink" title="3.5.1 正则化缓解过拟合"></a>3.5.1 正则化缓解过拟合</h4><ul><li><p>正则化：在损失函数中引入模型复杂度指标，给每个参数 $w$ 加上权重，抑制训练集中数据的噪声。正则化通常只对参数 $w$ 使用，一般不对偏置 $b$ 使用正则化</p></li><li><p>$loss = loss(y,y_{-})+REGULARIZER*loss(w)$</p><ul><li>$loss(y,y_{-})$ ：前向传播预测结果 $y$ 与实际值 $y_{-}$ 的差距，即损失函数，如：交叉熵、均方误差</li><li>$REGULARIZER$ ：超参数，给出参数 $w$ 在总 $loss$ 中的比例，即正则化权重</li><li>$loss(w)$ ：需要正则化的参数，有两种计算方式$\begin{cases} loss_{L1}(w)=\sum|w_i| \newline loss_{L2}(w)=\sum|w_i^2| \end{cases}$ <ul><li>$L1$ 正则化大概率会使很多参数变为 $0$ ，因此该方法可通过稀疏参数，即减少参数的数量，降低模型复杂度</li><li>$L2$ 正则化会使参数很接近 $0$ 但不为 $0$ ，因此该方法可通过减少参数值的大小，可以有效缓解数据集中因噪声引起的过拟合，降低模型复杂度</li></ul></li></ul></li><li><p>主要代码</p></li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">with tf.GradientTape() as tape: # 记录梯度信息    h1 = tf.matmul(x_train, w1) + b1    h1 = tf.nn.relu(h1)    y = tf.matmul(h1, w2) + b2        loss_mse = tf.reduce_mean(tf.square(y_train - y))        # 采用 L2 正则化    loss_regularization = []    loss_regularization.append(tf.nn.l2_loss(w1))    loss_regularization.append(tf.nn.l2_loss(w2))    loss_regularization = tf.reduce_sum(loss_regularization)    loss = loss_mse + 0.03 * loss_regularizationvariables = [w1, b1, w2, b2]grads = tape.gradient(loss, variables)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>c#上位机开发</title>
      <link href="/2024/01/13/shang-wei-ji/"/>
      <url>/2024/01/13/shang-wei-ji/</url>
      
        <content type="html"><![CDATA[<h2 id="一、C"><a href="#一、C" class="headerlink" title="一、C#"></a>一、C#</h2><h3 id="1-1-编译过程"><a href="#1-1-编译过程" class="headerlink" title="1.1 编译过程"></a>1.1 编译过程</h3><ul><li><p>C# —- 编译器编译 —-IL中间语言 —- 通过.NET平台的CLR动态转换为机器指令</p></li><li><p>提升开发效率，代码直接转化为机器指令比较耗时</p></li><li><p>性能较c/c++较低</p></li></ul><h3 id="1-2-代码结构"><a href="#1-2-代码结构" class="headerlink" title="1.2 代码结构"></a>1.2 代码结构</h3><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 命名空间namespace HelloWorldCS{    // 类型    internal class Program    {        // 函数 方法        static void Main(String[] args)        {                    }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="1-2-1-命名空间"><a href="#1-2-1-命名空间" class="headerlink" title="1.2 1 命名空间"></a>1.2 1 命名空间</h4><ul><li><p>命名空间在导入时，可取别名<code>using 别名 = 要调用的命名空间</code></p></li><li><p>命名空间使用<code>.</code>标识符，进入命名空间下一级</p></li><li><p>全局命名空间<code>using global::要调用的命名空间</code></p></li></ul><h5 id="1-2-1-1-基本命名空间"><a href="#1-2-1-1-基本命名空间" class="headerlink" title="1.2.1.1 基本命名空间"></a>1.2.1.1 基本命名空间</h5><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">using System;  // 使用基本的数据类型等using System.Collections.Generic;  // 加载泛型等using System.ComponentModel;  // 控件组件模型工具using System.Data;  // 加载与数据库连接类等有关空间using System.Drawing;  // 绘制using System.Linq;  // 简化数据增删改查的一种语法using System.Text;  // 文本空间using System.Threading.Tasks;  // 线程using System.Windows.Forms;  // 窗体<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="1-2-1-2-命名空间定义"><a href="#1-2-1-2-命名空间定义" class="headerlink" title="1.2.1.2 命名空间定义"></a>1.2.1.2 命名空间定义</h5><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">namespace 空间名{  }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="1-3-数据类型"><a href="#1-3-数据类型" class="headerlink" title="1.3 数据类型"></a>1.3 数据类型</h3><h4 id="1-3-1-值类型"><a href="#1-3-1-值类型" class="headerlink" title="1.3.1 值类型"></a>1.3.1 值类型</h4><ul><li><p>从类<code>System.ValueType</code>中派生来</p></li><li><p>值类型变量可以直接分配给一个值</p></li><li><p>可用值类型</p><table><thead><tr><th align="center">类型</th><th align="center">描述</th><th align="center">默认值</th></tr></thead><tbody><tr><td align="center">bool</td><td align="center">布尔值</td><td align="center">False</td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">sbyte</td><td align="center">8位有符号整数</td><td align="center">0</td></tr><tr><td align="center">byte</td><td align="center">8位无符号整数</td><td align="center">0</td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">char</td><td align="center">16位Unicode字符</td><td align="center">‘\0’</td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">short</td><td align="center">16 位有符号整数</td><td align="center">0</td></tr><tr><td align="center">ushort</td><td align="center">16 位无符号整数</td><td align="center">0</td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">int</td><td align="center">32位有符号整数</td><td align="center">0</td></tr><tr><td align="center">uint</td><td align="center">32 位无符号整数</td><td align="center">0</td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">long</td><td align="center">64位有符号整数</td><td align="center">0L</td></tr><tr><td align="center">ulong</td><td align="center">64 位无符号整数</td><td align="center">0</td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">float</td><td align="center">32位单精度浮点型</td><td align="center">0.0F</td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">double</td><td align="center">64位双精度浮点型</td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">decimal</td><td align="center">128位精确十进制值，28-29有效位数</td><td align="center">0.0M</td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td></tr></tbody></table></li></ul><h4 id="1-3-2-引用类型"><a href="#1-3-2-引用类型" class="headerlink" title="1.3.2 引用类型"></a>1.3.2 引用类型</h4><ul><li>引用类型指向一个内存位置</li></ul><h4 id="1-3-3-Object类型"><a href="#1-3-3-Object类型" class="headerlink" title="1.3.3 Object类型"></a>1.3.3 Object类型</h4><ul><li>Object类型是所有数据类型的终极基类</li><li>可被分配任何其他类型（值类型、引用类型、预定义类型、自定义类型）的值</li><li>当一个值类型转换位Object类时，称为<strong>装箱</strong>，反之为<strong>拆箱</strong></li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">object obj;obj = 100;    // 装箱<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="1-3-4-String类"><a href="#1-3-4-String类" class="headerlink" title="1.3.4 String类"></a>1.3.4 String类</h4><h5 id="1-3-4-1-拼接字符串"><a href="#1-3-4-1-拼接字符串" class="headerlink" title="1.3.4.1 拼接字符串"></a>1.3.4.1 拼接字符串</h5><ul><li><p>使用**<code>+</code>运算符**，对多个<code>string</code>进行拼接</p></li><li><p>会产生一个<strong>新的<code>String</code>对象</strong></p></li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">string s1 = "hello";string s2 = "world";// 拼接后产生新的 String 对象string s = s1 + " " + s2;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="1-3-4-2-比较字符串"><a href="#1-3-4-2-比较字符串" class="headerlink" title="1.3.4.2 比较字符串"></a>1.3.4.2 比较字符串</h5><ul><li><p>使用**<code>==</code>比较运算符**</p></li><li><p>**<code>Equals()</code>**方法</p></li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">/*两种常用方法*/// 第一种public bool Equals(string strB)    // 第二种public static bool Equals(string strA, string strB)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>**<code>Compare()</code>**方法</li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">/*    两种重载方法    Int 返回值，strA == strB 返回 0               strA &gt; strB 返回 1               strA &lt; strB 返回 -1*/// 第一种public static int Compare(string strA, string strB)// 第二种// ignorCase 若设置为 True ，则在比较字符串时会  忽略大小写！！！public static int Compare(string strA, string strB, bool ignorCase)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>**<code>CompareTo()</code>**方法</li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">/*该方法返回值情况同 Compare()*/public int CompareTo(string strB)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h5 id="1-3-4-3-格式化字符串"><a href="#1-3-4-3-格式化字符串" class="headerlink" title="1.3.4.3 格式化字符串"></a>1.3.4.3 格式化字符串</h5><ul><li><code>String</code>类提供了一个静态<code>Format()</code>方法，将字符串格式化为指定格式</li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">/*format 参数格式：{参数列表索引:格式字符串}，如{0:C}、{0:F2}数值类型格式说明符（大小写均可）：c - 货币 - ￥123d - Decimal- 123e - 指数 - 1.025e+003f - 定点 - 124.76f2: 取2位小数n - Number - 12,800p - 百分比 - 100.00%   p0: 0位小数x - 十六进制 - 00FF   x4: 4位    日期时间的格式化（区分大小写）：    d - 简短日期：YYYY-MM-dd    D - 完整日期：YYYY年MM月dd日    t - 简短时间：hh:mm    T - 完整时间：hh:mm:ss    f - 简短日期/时间：YYYY-MM-dd hh:mm    F - 完整日期/时间：YYYY年MM月dd日 hh:mm:ss    g - 简短的可排序的日期/时间：YYYY-MM-dd hh:mm    G - 完整的可排序的日期/时间：YYYY-MM-dd hh:mm:ss    M/m - 月/日：MM月dd日    Y/y - 年/月：YYYY年MM月    */public static string Format(string format, object obj)    // 数值举例    运行结果：天才是1%的灵感，加上99%的汗水Console.WriteLine(string.Format("天才是{0:P0}的灵感，加上{1:P0}的汗水",0.01,0.99));// 日期时间举例    运行结果：2023年11月3日DateTime dt = DateTime.Now;string strB = String.Format("{0:D}",dt);Console.WriteLine(strB);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>ToString()</code>方法也可传入指定格式说明符，对数值/日期时间数据进行格式化</li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">int money = 1298;Console.WriteLine(money.ToString("C")); // 转换为货币形式DateTime dTime = DateTime.Now;Console.WriteLine(dTime.ToString("Y")); // 转换为年月// 运行结果：// ￥1298// 2023年11月<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="1-3-4-4-截取字符串"><a href="#1-3-4-4-截取字符串" class="headerlink" title="1.3.4.4 截取字符串"></a>1.3.4.4 截取字符串</h5><ul><li><code>Substring()</code>方法，截取指定位置和指定长度的子字符串</li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">/*参数：startIndex：字符串截取索引位置Length：截取长度，当Length大于字符串长度时，截取完为止*/public string Substring(int startIndex, int length)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="1-3-4-5-分割字符串"><a href="#1-3-4-5-分割字符串" class="headerlink" title="1.3.4.5 分割字符串"></a>1.3.4.5 分割字符串</h5><ul><li><code>Split()</code>方法，分割字符串，返回字符串数组对象</li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">/*params关键字：函数传参时用，意为函数参数不固定，此处跟char[]，表示其是一个可变数量数组参数：separator：分隔符数组*/public string[] Split(params char[] separator)    // 举例string strA = "你干嘛，哎哟";char[] separator = {'，'};String[] splitstring = new String[100];splitstring = strA.Split(separator);for(int i = 0; i&lt;splitstring.Length; i++{    Console.WriteLine("item{0}:{1}", i, splitstring[i]);}    // 运行结果：//    item0:你干嘛//   item1:哎哟<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="1-3-4-6-插入字符"><a href="#1-3-4-6-插入字符" class="headerlink" title="1.3.4.6 插入字符"></a>1.3.4.6 插入字符</h5><ul><li><code>Insert()</code>方法，向字符串任意位置插入新元素</li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">/*参数：startIndex：插入字符串索引value：要插入的字符串*/public string Insert(int startIndex, string value)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>PadLeft()</code>和<code>PadRight()</code>，分别在字符串左侧和右侧填充字符</li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">/*参数：totalWidth：填充后的字符串长度paddingChar：要填充的字符，若省略，填充空格*/public string PadLeft(int totalWidth, char paddingChar)public string PadRight(int totalWidth, char paddingChar)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="1-3-4-7-删除字符串"><a href="#1-3-4-7-删除字符串" class="headerlink" title="1.3.4.7 删除字符串"></a>1.3.4.7 删除字符串</h5><ul><li><code>Remove()</code>方法</li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 两种重载方法/*参数：startIndex：开始删除索引count：删除字符数目*/public String Remove(int startIndex)  // 删到最后一个字符public String Remove(int startIndex, int count)  // 删除指定个数字符<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="1-3-4-8-复制字符串"><a href="#1-3-4-8-复制字符串" class="headerlink" title="1.3.4.8 复制字符串"></a>1.3.4.8 复制字符串</h5><ul><li><code>Copy()</code>和<code>CopyTo()</code>，分别复制到另一个字符串或<code>Char[]</code></li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">public static string Copy(string str)/*参数：sourceIndex：待复制字符的起始位置destination：目标字符数组destinationIndex：目标数组开始存放字符的位置count：要复制的个数*/public void CopyTo(int sourceIndex, cahr[] destination, int destinationIndex, int count)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="1-3-4-9-替换字符串"><a href="#1-3-4-9-替换字符串" class="headerlink" title="1.3.4.9 替换字符串"></a>1.3.4.9 替换字符串</h5><ul><li><code>Replace()</code>方法，替换字符或字符串</li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">public string Replace(char OChar, char NChar)public string Replace(string OValue, string NValue)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="1-3-5-数组"><a href="#1-3-5-数组" class="headerlink" title="1.3.5 数组"></a>1.3.5 数组</h4><ul><li>一组相同数据类型的数据序列</li><li><code>String</code>类型本身就是由<code>char</code>类型组成的数组</li></ul><h5 id="1-3-3-1-初始化数组"><a href="#1-3-3-1-初始化数组" class="headerlink" title="1.3.3.1 初始化数组"></a>1.3.3.1 初始化数组</h5><ul><li>声明一个长度为2的<code>String</code>数组，<code>string a = new string[2];</code></li><li>声明并初始化，<code>string a = new string[2]{"你干嘛","哎哟"}</code></li></ul><h4 id="1-3-6-正则表达式"><a href="#1-3-6-正则表达式" class="headerlink" title="1.3.6 正则表达式"></a>1.3.6 正则表达式</h4><ul><li>作用：查找符合某些复杂规则的字符串</li><li>实质：正则表达式是记录文本规则的代码</li></ul><h5 id="1-3-6-1-行定位符"><a href="#1-3-6-1-行定位符" class="headerlink" title="1.3.6.1 行定位符"></a>1.3.6.1 行定位符</h5><ul><li><p>用来描述字符串的边界</p></li><li><p><code>^</code>和<code>$</code>分别用于表示行的开始和结尾</p></li><li><p><code>^tm</code>可用于<code>tm</code>开头的字符串，如<code>tm123dhak</code></p><ul><li><code>tm$</code>用于匹配<code>tm</code>结尾的字符串，如<code>dkah123tm</code></li></ul></li><li><p>若<code>tm</code>可出现在字符串任意部位，正则表达式可直接写为<code>tm</code></p></li></ul><h5 id="1-3-6-2-元字符"><a href="#1-3-6-2-元字符" class="headerlink" title="1.3.6.2 元字符"></a>1.3.6.2 元字符</h5><ul><li><p>常用元字符</p><table><thead><tr><th align="center">元字符</th><th align="center">说明</th><th align="center">元字符</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">.</td><td align="center">匹配除换行符外的任意字符</td><td align="center">\b</td><td align="center">匹配单词的开或结束</td></tr><tr><td align="center">\w</td><td align="center">匹配字母、数字、下划线或汉字</td><td align="center">^</td><td align="center">匹配字符串的开始</td></tr><tr><td align="center">\s</td><td align="center">匹配任意的空白字符</td><td align="center">$</td><td align="center">匹配字符串的结束</td></tr><tr><td align="center">\d</td><td align="center">匹配数字</td><td align="center"></td><td align="center"></td></tr></tbody></table><ul><li>如<code>\bmr\w*\b</code>，该正则表达式表示，匹配以<code>mr</code>开头的单词，先匹配单词开始处<code>\b</code>，然后匹配字母<code>mr</code>，接着匹配任意数量的字母或数字<code>\w*</code>，最后匹配单词结束处<code>\b</code>。该表达式可匹配<code>mrsoft、mrbook、mr123456</code>等</li></ul></li></ul><h5 id="1-3-6-3-限位符"><a href="#1-3-6-3-限位符" class="headerlink" title="1.3.6.3 限位符"></a>1.3.6.3 限位符</h5><ul><li><p>匹配指定数量的字符</p></li><li><p>常用限位符</p><table><thead><tr><th align="center">限位符</th><th align="center">说明</th><th align="center">举例</th></tr></thead><tbody><tr><td align="center">?</td><td align="center">匹配前面的字符零次或一次</td><td align="center">go?gle，该表达式可匹配ggle和gogle</td></tr><tr><td align="center">+</td><td align="center">匹配前面的字符一次或多次</td><td align="center">go+gle，该表达式可匹配范围从gogle到goo…gle</td></tr><tr><td align="center">*</td><td align="center">匹配前面的字符零次或多次</td><td align="center">go*gle，该表达式可匹配范围从ggle到goo…gle</td></tr><tr><td align="center">{n}</td><td align="center">匹配前面的字符n次</td><td align="center">go{2}gle，只能匹配google</td></tr><tr><td align="center">{n,}</td><td align="center">匹配前面的字符至少n次</td><td align="center">go{2,}gle，该表达式可匹配范围从google到goo…gle</td></tr><tr><td align="center">{n,m}</td><td align="center">匹配前面的字符[n, m]次</td><td align="center">go{0,2}gle，该表达式可匹配范围从ggle、gogle、google</td></tr></tbody></table><ul><li>如<code>\d{8}$</code>，匹配8位数字</li></ul></li></ul><h5 id="1-3-6-4-自定义字符"><a href="#1-3-6-4-自定义字符" class="headerlink" title="1.3.6.4 自定义字符"></a>1.3.6.4 自定义字符</h5><ul><li>使用<code>[]</code>，匹配指定字符<ul><li>例，要匹配元音字母，<code>[aeiou]</code>，该表达式即可匹配任意一个元音字母</li></ul></li><li>若要排除指定字符，在<code>[]</code>内使用<code>^</code><ul><li>例，<code>[^a-zA-Z]</code>，匹配一个非字母字符</li></ul></li></ul><h5 id="1-3-6-5-选择字符"><a href="#1-3-6-5-选择字符" class="headerlink" title="1.3.6.5 选择字符"></a>1.3.6.5 选择字符</h5><ul><li>在面对身份证的匹配时，身份证号码长度为15或18，如果15位则全是数字；如果为18位，则前17位为数字最后一位是校验位，既可以是数字也可以是字符X或x</li><li>该匹配规则隐含选择逻辑，使用字符<code>|</code>来实现<ul><li><code>(^\d{15}$)|(^\d{18}$)|(^\d{17}(X|x)$)</code></li></ul></li></ul><h5 id="1-3-6-6-转义字符"><a href="#1-3-6-6-转义字符" class="headerlink" title="1.3.6.6 转义字符"></a>1.3.6.6 转义字符</h5><ul><li>当需要匹配<code>.</code>、<code>?</code>、<code>\</code>等字符时，由于正则表达式已有相应含有，可通过转义字符转换为普通字符<ul><li>例，需要匹配127.0.0.1这样的IP地址，可使用<code>\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}</code>进行匹配</li></ul></li></ul><h5 id="1-3-6-7-分组"><a href="#1-3-6-7-分组" class="headerlink" title="1.3.6.7 分组"></a>1.3.6.7 分组</h5><ul><li>使用小括号<code>()</code>，其除了可以改变限定符的作用范围，还可以进行分组<ul><li>例，<code>(\.[0-9]{1,3}){3}</code>，对分组<code>\.[0-9]{1,3}</code>进行3次重复操作</li></ul></li></ul><h5 id="1-3-6-8-使用正则表达式"><a href="#1-3-6-8-使用正则表达式" class="headerlink" title="1.3.6.8 使用正则表达式"></a>1.3.6.8 使用正则表达式</h5><ul><li>借助<code>System.Text.RegularExpression</code>命名空间下的<code>Regex</code>类</li><li>该类有许多静态方法<ul><li><code>IsMatch()</code>，指示正则表达式在输入字符串中是否找到匹配项</li><li><code>Match()</code>，在输入字符串中搜索正则表达式的匹配项，并将精确结果作为单个<code>Match</code>对象进行返回</li><li><code>Matches()</code>，返回正则表达式所有成功的匹配，相当于多次调用<code>Match()</code></li><li><code>Replace()</code>，用指定替换字符串去替换匹配正则表达式的所有匹配项</li><li><code>Split()</code>，在正则表达式定义的位置将输入字符串拆分为一个字符串数组</li></ul></li></ul><h4 id="1-3-7-哈希表"><a href="#1-3-7-哈希表" class="headerlink" title="1.3.7 哈希表"></a>1.3.7 哈希表</h4><ul><li>集合类型，类似于python字典，键值对</li><li>哈希表每一个元素都是存储在<code>DictionaryEntry</code>对象中的键值对，键不能为空，值可用</li></ul><h5 id="1-3-7-1-构造函数"><a href="#1-3-7-1-构造函数" class="headerlink" title="1.3.7.1 构造函数"></a>1.3.7.1 构造函数</h5><ul><li><code>Hashtable()</code>构造方法创建<code>Hashtable</code>对象</li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 使用默认的初始容量、加载因子、哈希代码来创建实例public Hashtable()// 使用指定初始容量、默认加载因子、默认哈希代码来创建实例public Hashtable(int capacity)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="1-3-7-2-Hashtable属性"><a href="#1-3-7-2-Hashtable属性" class="headerlink" title="1.3.7.2 Hashtable属性"></a>1.3.7.2 Hashtable属性</h5><ul><li><code>Count</code>：获取键值对数目</li><li><code>Item</code>：获取或设置与指定键相关联的值</li><li><code>Keys</code>：获取<code>Hashtable</code>中键的<code>ICollection</code></li><li><code>Values</code>：获取值的<code>ICollection</code></li></ul><h5 id="1-3-7-3-添加元素"><a href="#1-3-7-3-添加元素" class="headerlink" title="1.3.7.3 添加元素"></a>1.3.7.3 添加元素</h5><ul><li><code>Add()</code>，添加键值对</li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 参数 value可为空public virtual void Add(Object key, Object value)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 例Hashtable hash = new Hashtable();hash.Add("id", "Bh001");hash.Add("name", "TM");hash.Add("sex", "男");Console.WriteLine(hash,Count);// 运行结果为：3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="1-3-7-4-删除元素"><a href="#1-3-7-4-删除元素" class="headerlink" title="1.3.7.4 删除元素"></a>1.3.7.4 删除元素</h5><ul><li><code>Clear()</code>和<code>Remove()</code></li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// Clear()，清空Hashtablepublic virtual void Clear()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// Remove()，删除指定键元素// 参数：key 为待删除元素的键public virtual void Remove(Object key)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h5 id="1-3-7-5-遍历哈希表"><a href="#1-3-7-5-遍历哈希表" class="headerlink" title="1.3.7.5 遍历哈希表"></a>1.3.7.5 遍历哈希表</h5><ul><li>因为哈希表元素是键值对，所以要使用<code>DictionaryEntry</code>结构进行遍历，其表示一个键值对的集合</li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 遍历哈希表，假设哈希表中已有元素foreach(DictionaryEntry dic in hash){Console.WriteLine("\t" + dic.Key + "\t" + dic.Value);    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="1-3-7-6-查找元素"><a href="#1-3-7-6-查找元素" class="headerlink" title="1.3.7.6 查找元素"></a>1.3.7.6 查找元素</h5><ul><li><code>Contains()、ContainsKey()、ContainsValue()</code></li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 寻找指定 键// Contains() 和 ContainsKey() 方法功能、语法相同// 只介绍Contains()方法public virtual bool Contains(Object key)    // 寻找指定 值public virtual bool ContainsValue(Object Value)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-4-类与对象"><a href="#1-4-类与对象" class="headerlink" title="1.4 类与对象"></a>1.4 类与对象</h3><h4 id="1-4-1-类"><a href="#1-4-1-类" class="headerlink" title="1.4.1 类"></a>1.4.1 类</h4><ul><li>类是一种数据类型，包含<strong>数据成员</strong>（常量和变量）、<strong>函数成员</strong>（方法、属性、事件、索引器、运算符、构造函数和析构函数）和<strong>嵌套类型</strong></li><li>==类可在不同源文件之间进行拆分==</li></ul><h5 id="1-4-1-1-类的声明"><a href="#1-4-1-1-类的声明" class="headerlink" title="1.4.1.1 类的声明"></a>1.4.1.1 类的声明</h5><ul><li>类的声明</li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">访问修饰符 class 类名{    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h5 id="1-4-1-2-构造函数和析构函数"><a href="#1-4-1-2-构造函数和析构函数" class="headerlink" title="1.4.1.2 构造函数和析构函数"></a>1.4.1.2 构造函数和析构函数</h5><ul><li><p>对象的生命周期从构造函数开始，析构函数结束</p></li><li><p>构造函数：用于对对象进行初始化，实例化对象时自动调用</p><ul><li>定义类时，若未定义构造函数，编译器会自动创建一个不带参数的默认构造函数</li></ul></li><li><p>要使用有参构造函数，需显式实例化，传入参数</p></li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">public class Book{    public Book()  // 无参构造函数    {            }        public Book(int args)  // 有参构造函数    {        args = 2 + 3;}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>析构函数：用于回收对象资源，销毁对象时自动调用</p><ul><li><p>当某个实例化对象被认为不再有效，并符合析构条件时，<code>.NET Framework</code>类库的垃圾回收功能会自动调用析构函数实现垃圾回收</p></li><li><p>一个类只有一个析构函数，且无法调用析构函数，它是自动调用的</p></li></ul></li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// Main()函数执行完后，创建的demo实例pro不再有效，调用~demo析构函数，并打印字符串public class demo{    ~demo()    {        Console.WriteLine("析构函数自动调用");    }    static void Main(string[] args)    {        demo pro = new demo();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="1-4-1-3-属性"><a href="#1-4-1-3-属性" class="headerlink" title="1.4.1.3 属性"></a>1.4.1.3 属性</h5><ul><li><p>对象拥有的所有特征，在类中表示时称为类的属性</p></li><li><p>属性可以像使用公共数据成员一样使用，但它实际上是一种称为“访问器”的特殊方法，其指定了属性值被读取或写入时要执行的语句。通过该机制，可以把读取、写入对象的某些特性于操作关联起来</p></li><li><p>调用<code>对象名.属性名</code></p></li><li><p>属性的声明</p></li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">访问修饰符 数据类型 属性名{    // get访问器必须返回属性类型的值    get    {        return 变量名;    }        // 使用value隐式参数，此参数的类型是属性的类型    set    {        // set访问器可以包含大量语句，可对能赋予的值进行检查，避免给属性值设置错误        变量名 = value;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// c#支持自动实现的属性，即在访问器中没有任何逻辑// 自动实现的属性，必须同时拥有get和set两个访问器public int Age{    get;    set;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="1-4-1-4-方法"><a href="#1-4-1-4-方法" class="headerlink" title="1.4.1.4 方法"></a>1.4.1.4 方法</h5><ul><li><p>声明方法时，除了可以使用访问修饰符外，还可以使用<code>new、static、virtual、override、sealed、abstract、extern</code>等修饰符</p></li><li><p>关于新修饰符</p><ul><li><code>static、virtual、override</code>最多包含一个</li><li><code>new、override</code>最多包含一个</li><li>若声明中使用了<code>abstract</code>，则不能使用<code>static、virtual、sealed、extern </code></li><li>若使用了<code>private</code>，不能使用<code>virtual、override、abstract</code></li><li>若使用了<code>sealed</code>，那么还得包含<code>override</code>修饰符</li></ul></li><li><p>方法声明</p></li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">修饰符 返回值类型 方法名(参数列表){    // 方法的具体实现}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>方法形参的声明，可使用<code>params、ref、out</code>修饰</p><ul><li><p>==属性不能作为<code>ref、out</code>参数进行传递==</p></li><li><p><code>params</code>用来指定在参数数目可变的方法参数，<strong>必须是一维数组</strong></p></li></ul></li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">static void demo(params string[] list){    for(int i = 0; i &lt; list.Length; i++)    {        Consolde.WriteLine(list[i]);    }}static void Main(){    string[] a = new string[]{"我","是","中","国","人"};    demo(a);    Console.Read();}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p><code>ref</code>表示按<strong>引用传递</strong>参数</p><ul><li><p>如果使用<code>ref</code>参数，那么在方法声明和调用方法时都必须显式使用<code>ref</code>关键字</p></li><li><p>实参在传递前必须初始化</p></li></ul></li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">public static void Method(ref int i){    i = 44;}public static void Main(){    int val = 0;    Method(ref val);    Console.WriteLine(val);    Console.Read();}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p><code>out</code>同样是<strong>引用传递</strong></p><ul><li><p>在方法声明和调用方法时都必须显式使用<code>out</code>关键字</p></li><li><p>实参不需要初始化</p></li></ul></li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">public static void Method(out int i){    i = 44;}public static void Main(){    int val;    Method(out val);    Console.WriteLine(val);    Console.Read();}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="1-4-2-对象"><a href="#1-4-2-对象" class="headerlink" title="1.4.2 对象"></a>1.4.2 对象</h4><h5 id="1-4-2-1-对象的创建"><a href="#1-4-2-1-对象的创建" class="headerlink" title="1.4.2.1 对象的创建"></a>1.4.2.1 对象的创建</h5><ul><li>使用<code>new</code>关键字，如有一个<code>demo</code>类，实例化，<code>demo a = new demo()</code></li></ul><h5 id="1-4-2-2-访问对象的属性和行为"><a href="#1-4-2-2-访问对象的属性和行为" class="headerlink" title="1.4.2.2 访问对象的属性和行为"></a>1.4.2.2 访问对象的属性和行为</h5><ul><li>使用<code>.</code>操作符调用类的成员变量和成员方法</li></ul><h5 id="1-4-2-3-对象销毁"><a href="#1-4-2-3-对象销毁" class="headerlink" title="1.4.2.3 对象销毁"></a>1.4.2.3 对象销毁</h5><ul><li>有以下两种情况时，会被<code>.NET</code>垃圾回收器视为垃圾并进行回收<ul><li>对象引用超过其作用范围，</li><li>将对象赋值为<code>null</code></li></ul></li></ul><h4 id="1-4-3-静态类及其成员"><a href="#1-4-3-静态类及其成员" class="headerlink" title="1.4.3 静态类及其成员"></a>1.4.3 静态类及其成员</h4><ul><li><p>当属性和方法被修饰为<code>static</code>时，它们不属任一实例对象，直接通过类名进行调用</p></li><li><p>c# 不支持静态局部变量，==不能在方法中声明静态变量==</p></li><li><p>静态成员的作用</p><ul><li>保留已实例化的对象数的计数</li><li>存储必须在所有实例间共享的值</li></ul></li><li><p>若在定义类时加上关键字<code>static</code></p><ul><li>那么该类中只能包含静态成员</li><li>其无法实例化，所以也不能定义实例构造函数</li></ul></li><li><p>静态类会进行密封，<strong>无法继承</strong>，它们不能继承自任何的类或接口（<strong>除了Object</strong>）</p></li></ul><h4 id="1-4-4-this关键字"><a href="#1-4-4-this关键字" class="headerlink" title="1.4.4 this关键字"></a>1.4.4 this关键字</h4><ul><li><p><code>this</code>引用的是本类的一个对象</p></li><li><p>当局部变量或方法参数覆盖了成员变量时，就需要添加关键字<code>this</code>，来明确引用的是类成员还是局部变量或方法参数</p></li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">private void setName(String name){    // 如果写为 name = name ，则只会把参数name的值赋给参数变量，成员变量name不会改变    this.name = name;  // 将参数值赋予类中的成员变量}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>this</code>还可作为方法返回值</li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">public Book getBook(){    return this;  // 返回Book类的引用}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="1-4-5-继承"><a href="#1-4-5-继承" class="headerlink" title="1.4.5 继承"></a>1.4.5 继承</h4><h5 id="1-4-5-1-继承的实现"><a href="#1-4-5-1-继承的实现" class="headerlink" title="1.4.5.1 继承的实现"></a>1.4.5.1 继承的实现</h5><ul><li><p>基本思想：基于某个父类的扩展，指定出一个新的子类（派生类）</p></li><li><p>子类可以继承父类原有的属性和方法，也可以增加父类不具备的属性和方法，或者重写父类的方法</p></li><li><p>使用<code>:</code>来标识两个类的继承关系，当对一个类使用<code>sealed</code>修饰后，该类将不能被继承</p></li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">public class Computer{    // 父类}public class Pad:Computer  // Pad继承于Computer{    // 子类}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="1-4-5-2-base关键字"><a href="#1-4-5-2-base关键字" class="headerlink" title="1.4.5.2 base关键字"></a>1.4.5.2 base关键字</h5><ul><li><p>当子类对父类成员方法进行重写后，若要访问父类原有的方法，需要使用关键字<code>base</code>，使用方法同<code>this</code></p><ul><li>==重写父类方法时，修饰权限只能变大或者不变，变小访问权限是错误的==</li></ul></li><li><p>若要使用<code>base</code>调用父类的属性或方法，父类相应的属性和方法必须定义为<code>public</code>或<code>protected</code></p></li><li><p>另外，使用<code>base</code>关键字还可以指定创建子类实例时应调用的父类构造函数</p><ul><li>访问父类成员只能在构造函数、实例方法或实例属性中进行，==在静态方法中使用<code>base</code>关键字是错误的==</li></ul></li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 父类构造函数public Goods(string tradecode, string fullname){    TradeCode = tradecode;    FullName = fullname;}// 子类基于父类定义构造函数public JHInfo(string jhid, string tradecode, string fullname):base(tradecode,fullname){    JHID = jhid;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="1-4-5-3-继承中的构造-析构函数"><a href="#1-4-5-3-继承中的构造-析构函数" class="headerlink" title="1.4.5.3 继承中的构造/析构函数"></a>1.4.5.3 继承中的构造/析构函数</h5><ul><li>调用顺序，构造函数从最顶层父类依次调用到子类，析构函数反之<img src="image-20231107213904383-1705156191266-1.png" alt="" style="zoom:50%;"></li></ul><h4 id="1-4-6-多态"><a href="#1-4-6-多态" class="headerlink" title="1.4.6 多态"></a>1.4.6 多态</h4><h5 id="1-4-6-1-重写虚方法"><a href="#1-4-6-1-重写虚方法" class="headerlink" title="1.4.6.1 重写虚方法"></a>1.4.6.1 重写虚方法</h5><ul><li><p>方法默认情况下不是虚拟的，除构造函数外，其他方法可以显式地声明为<code>virtual</code></p></li><li><p>在方法前面加上关键字<code>virtual</code>，则该方法称为虚方法</p><ul><li><p>==类中的成员字段和静态方法不能声明为<code>virtual</code>==</p></li><li><p><code>virtual</code>只对类中的实例函数和属性有意义</p></li></ul></li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 声明一个虚方法public virtual void Move(){    Console.WriteLine("交通工具可以移动");}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>定义虚方法后，可以在派生类中重写虚方法，使用关键字<code>override</code></li></ul><pre class="line-numbers language-C#" data-language="C#"><code class="language-C#">// 在派生类中重写虚方法public override void Move(){    Console。WriteLine("火车可以移动");}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="1-4-6-2-方法重载"><a href="#1-4-6-2-方法重载" class="headerlink" title="1.4.6.2 方法重载"></a>1.4.6.2 方法重载</h5><ul><li><p>指的是方法名相同，但参数的数据类型、个数和顺序不同的方法</p></li><li><p>当类中有两种以上同名方法（重载），需清楚要调用哪种方法</p></li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 定义静态方法Add()，参数为两个int，返回值为intpublic static int Add(int x, int y){    return x+y;}// 重载Add()，参数为一个int一个double，返回值为doublepublic double Add(int x, double y){    return x+y;}// 再次重载Add()，其参数个数较第一个函数增加为3个public int Add(int x, int y, int z){    return x+y+z;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="1-4-7-结构"><a href="#1-4-7-结构" class="headerlink" title="1.4.7 结构"></a>1.4.7 结构</h4><ul><li>值类型，用来封装一组相关变量</li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">结构修饰符 struct 结构名{    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li>结构可包括构造函数、常量、字段、方法、属性、运算符、事件和嵌套类型等</li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 声明一个矩形结构，定义宽高，Area()方法public struct Rect{    public double width;    public double height;    public double Area()    {        return width*height;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>向方法传递结构时，结构是通过传值方式进行传递的，不是作为引用传递</p></li><li><p>结构可以声明构造函数，但必须带参数</p></li><li><p>结构实例化，可以不用<code>new</code></p></li><li><p>所有结构都直接继承自<code>System.ValueType</code>，所以一个结构不能继承于另一个结构或类</p></li><li><p>在结构中初始化实例字段是错误的</p></li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">public struct Rect{    public double width;    public double height;        // 构造函数    public Rect(double x, double y)    {        width = x;        height = y;    }        public double Area()    {        return width*height;    }}static void Main(string[] args){    Rect rect1;  // 实例化一个矩形结构    rect1.width = 5;    rect1.height = 3;    Console.WriteLine("矩形面积为：" + rect1.Area());        Rect rect2 = new Rect(6, 4);  // 使用构造函数实例化矩形结构    Console.WriteLine("矩形面积为：" + rect2.Area());}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-5-控制台应用程序"><a href="#1-5-控制台应用程序" class="headerlink" title="1.5 控制台应用程序"></a>1.5 控制台应用程序</h3><h4 id="1-5-1-主要语句"><a href="#1-5-1-主要语句" class="headerlink" title="1.5.1 主要语句"></a>1.5.1 主要语句</h4><ul><li><strong>打印</strong></li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 打印且换行// cw + 2下Tab  快捷生成该语句System.Console.WriteLine();// 打印不换行System.Console.Write();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><strong>读取</strong></li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 读取单个按键System.Console.ReadKey();// 读取字串System.Console.ReadLine();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="1-5-2-示例"><a href="#1-5-2-示例" class="headerlink" title="1.5.2 示例"></a>1.5.2 示例</h4><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">using System;namespace fund{    internal static class Program    {        static void Main()        {           int temp = 0;            // 使用int类方法Parse()，将接收的string强转为int            temp = int.Parse(Console.ReadLine());            // "结果为："+temp+30    temp和30会自动转为字符串，与"结果为："进行拼接            Console.WriteLine("结果为："+temp+30);            Console.ReadKey();        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-6-文件操作"><a href="#1-6-文件操作" class="headerlink" title="1.6 文件操作"></a>1.6 文件操作</h3><ul><li>使用命名空间<code>using System.IO;</code></li></ul><h4 id="1-6-1-获取文件"><a href="#1-6-1-获取文件" class="headerlink" title="1.6.1 获取文件"></a>1.6.1 获取文件</h4><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 获取对应路径下的文件string path = @"C:\Users\echo\Desktop";DirectoryInfo root = new DirectoryInfo(path);FileInfo[] files = root.GetFiles();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="1-6-2-删除指定文件"><a href="#1-6-2-删除指定文件" class="headerlink" title="1.6.2 删除指定文件"></a>1.6.2 删除指定文件</h4><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 遍历文件集合for (int i = 0; i &lt; files.Length; i++){FileInfo fi = files[i];        // 打印 文件绝对路径    //Console.WriteLine(fi.FullName);    // 打印 文件名    //Console.WriteLine(fi.Name);    // 删除 指定文件    if (fi.Name == "123.txt")    {        // 传入绝对路径        File.Delete(fi.FullName);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="1-6-3-更改文件名"><a href="#1-6-3-更改文件名" class="headerlink" title="1.6.3 更改文件名"></a>1.6.3 更改文件名</h4><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 文件改名bool isHave = fi.Name.Contains("123");  // 也可参数补全文件后缀，删更改指定文件类型的文件名if (isHave){    // 获取原始绝对路径文件名    string srcFileName = fi.FullName;    // 定义新绝对路径文件名，不更改文件类型    string dstFileName = fi.Directory.FullName+@"\ddd"+fi.Extension;    // 对文件进行更名，并移动到指定位置    File.Move(srcFileName, dstFileName);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-7-随机数"><a href="#1-7-随机数" class="headerlink" title="1.7 随机数"></a>1.7 随机数</h3><h4 id="1-7-1-Random类"><a href="#1-7-1-Random类" class="headerlink" title="1.7.1 Random类"></a>1.7.1 Random类</h4><ul><li>通过<code>Random</code>类产生，该类并非静态类，所以必须通过实例化产生</li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 实例化一个random类，并产生1-33的随机整数Random a = new random();a.Next(1,34);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="1-7-2-例程1-–-双色球"><a href="#1-7-2-例程1-–-双色球" class="headerlink" title="1.7.2 例程1 – 双色球"></a>1.7.2 例程1 – 双色球</h4><ul><li><p>具体代码文件见<code>D:\Program Files\Microsoft Visual Studio\projects\start\write</code></p></li><li><p>以双色球开奖为例，6个红色球取值为1-33，1个蓝色球取值为1-16</p></li><li><p>界面搭建如图</p><ul><li><img src="image-20231031162713259-1705156191295-2.png" alt="" style="zoom: 25%;"></li></ul></li><li><p>通过<code>开始抽奖</code>按钮（button1），启动时钟，并设置时间间隔；<code>停止抽奖</code>按钮（button2）关闭时钟；<code>timer1</code>时钟触发<code>tick</code>事件内，执行产生7位随机数</p></li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 开始抽奖按钮private void button1_Click(object sender, EventArgs e){    timer1.Enabled = true;    timer1.Interval = 100;    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 停止抽奖按钮private void button2_Click(object sender, EventArgs e){    timer1.Enabled=false;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 时钟触发事件 private void timer1_Tick(object sender, EventArgs e) { Random a = new Random(); // 感觉生成7个随机数的代码有些冗余，不知道能不能通过循环实现，后续优化！！！      /* // 简化代码 // 设置文本的 Label 集合    Label[] labels = {label1, label2, label3, label4, label5, label6};    // 循环设置每个 Label 的文本    foreach (Label label in labels)    {        label.Text = Convert.ToString(random.Next(1, 34));    }    label7.Text = Convert.ToString(a.Next(1, 17)); */         label1.Text = Convert.ToString(a.Next(1,34));    label2.Text = Convert.ToString(a.Next(1, 34));    label3.Text = Convert.ToString(a.Next(1, 34));    label4.Text = Convert.ToString(a.Next(1, 34));    label5.Text = Convert.ToString(a.Next(1, 34));    label6.Text = Convert.ToString(a.Next(1, 34));    label7.Text = Convert.ToString(a.Next(1, 17)); }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>效果如下<img src="双色球-1705156191295-3.gif" alt="" style="zoom: 33%;"></li></ul><h4 id="1-7-3-例程2-–-按键图片切换"><a href="#1-7-3-例程2-–-按键图片切换" class="headerlink" title="1.7.3 例程2 – 按键图片切换"></a>1.7.3 例程2 – 按键图片切换</h4><ul><li><p>具体代码文件见<code>D:\Program Files\Microsoft Visual Studio\projects\start\write2</code></p></li><li><p>每次按键，随机切换图片</p></li><li><p>在<code>debug</code>文件夹下新建一个<code>img</code>文件夹，并在其中存入<code>1-6.jpg</code></p></li><li><p>搭建界面如下</p><ul><li><img src="image-20231031180022076-1705156191295-5.png" alt="" style="zoom: 25%;"></li></ul></li><li><p>通过点击<code>button</code>按钮，触发<code>click</code>事件，产生随机数，导入图片到<code>pictureBox</code>展示</p></li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// button_click事件private void button2_Click(object sender, EventArgs e){    Random a = new Random();    double num = a.NextDouble();    // 产生1-6的数字    int picnum = Convert.ToInt32(Math.Floor(num*6) + 1);    // 图片载入    pictureBox1.SizeMode = PictureBoxSizeMode.StretchImage;        // 相对路径，默认路径为项目文件下的debug文件    pictureBox1.Image = Image.FromFile(@"img\" + picnum + ".jpg");}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>效果如下<img src="/2024/01/13/shang-wei-ji/%E6%8C%89%E9%94%AE%E5%9B%BE%E7%89%87%E5%88%87%E6%8D%A2-1705156191295-4.gif" alt="按键图片切换"></li></ul><h3 id="1-8-访问修饰符"><a href="#1-8-访问修饰符" class="headerlink" title="1.8 访问修饰符"></a>1.8 访问修饰符</h3><ul><li><p>所有的<strong>类型及其成员</strong>都具有可访问性级别</p></li><li><p><strong>程序集</strong>通过编译单个或多个<code>.cs</code>文件产生的<code>.dll</code>或<code>.exe</code></p></li><li><p><code>public</code>：同一程序集中的<strong>任何其他代码</strong>或引用该程序集的其他程序集<strong>都可访问该类型或成员</strong></p></li><li><p><code>private</code>：只有<strong>同一<code>class</code>或<code>struct</code>中的代码</strong>可以访问类型或成员</p></li><li><p><code>protected</code>：只有**同一<code>class</code>或从其派生出的<code>class</code>**可以访问</p></li><li><p><code>internal</code>：<strong>同一程序集中的任何代码</strong>均可访问，但外部程序集不行</p></li><li><p><code>protected internal</code>：本程序集中及其他程序集的派生<code>class</code></p></li><li><p><code>private protected</code>：在类内及本程序集派生类中可访问</p></li><li><p>访问修饰符摘要表</p><ul><li><img src="image-20231031224437966-1705156191295-6.png" alt="" style="zoom: 50%;"></li></ul></li></ul><h3 id="1-9-字段"><a href="#1-9-字段" class="headerlink" title="1.9 字段"></a>1.9 字段</h3><ul><li>什么是字段<ul><li>字段(field)是一种表示与对象或类型（类与结构体）相关联的变量</li><li>字段是类型的成员，也被称为“成员变量”</li><li>类型方法体内定义的变量属于局部变量，不是字段</li><li>分类<ul><li>实例字段：与实例化对象相关联的成员变量</li><li>静态字段：与类型相关联的成员变量，由<code>static</code>修饰</li></ul></li></ul></li></ul><h3 id="1-10-属性"><a href="#1-10-属性" class="headerlink" title="1.10 属性"></a>1.10 属性</h3><h2 id="二、控件及事件-–-B站刘金玉视频总结"><a href="#二、控件及事件-–-B站刘金玉视频总结" class="headerlink" title="二、控件及事件 – B站刘金玉视频总结"></a>二、控件及事件 – B站刘金玉视频总结</h2><h3 id="2-1-控件简介"><a href="#2-1-控件简介" class="headerlink" title="2.1 控件简介"></a>2.1 控件简介</h3><ul><li>所有的控件都是对象，对象三要素<strong>属性、方法、事件</strong></li><li>当控件从工具箱被拖到form窗体后，变成实例对象</li><li>控件分类<ul><li>公共控件：以表单为主</li><li>容器控件：界面布局使用，使界面干净整洁</li><li>菜单和工具栏控件</li><li>组件</li><li>打印控件</li><li>对话框控件</li><li>数据控件</li><li>WPF互操作性</li></ul></li><li>控件基本操作：点选控件 =&gt; 更改其属性</li></ul><h3 id="2-2-Form窗体"><a href="#2-2-Form窗体" class="headerlink" title="2.2 Form窗体"></a>2.2 Form窗体</h3><h4 id="2-2-1-基本介绍"><a href="#2-2-1-基本介绍" class="headerlink" title="2.2.1 基本介绍"></a>2.2.1 基本介绍</h4><ul><li><p><code>Form1.cs[设计]</code> 文件：可视化窗体界面</p></li><li><p><code>Form1.cs</code> 文件：后台代码界面</p></li><li><p><code>Form1.Designer.cs</code> 文件：具体窗体设计代码，其中方法被调用</p></li><li><p>Form窗体加载过程：</p><ul><li>项目起点，<code>Program.cs</code>中的<code>Main()</code>，创建Form实例</li><li>到<code>Form1.cs</code>中调用<code>InitializeComponent()</code>，初始化窗体界面</li><li>再到<code>Form1.Designer.cs</code>中执行相应代码，实现窗体和控件布局</li></ul></li></ul><h4 id="2-2-2-例程-–-Form窗体控制"><a href="#2-2-2-例程-–-Form窗体控制" class="headerlink" title="2.2.2 例程 – Form窗体控制"></a>2.2.2 例程 – Form窗体控制</h4><ul><li><p>具体代码文件见<code>D:\Program Files\Microsoft Visual Studio\projects\start\控件</code></p></li><li><p>以两按钮分别控制Form窗体背景颜色及标题</p></li><li><p>拖两个<code>Button</code>控件到<code>Form</code>窗体内，分别修改<code>Text</code>为：背景变色、换标题</p></li><li><p>分别双击创建相应<code>ButtonClick</code>事件，并自动跳转到<code>Form.cs</code>中生成相应方法</p></li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 背景变色private void button1_Click(object sender, EventArgs e){    // 注意ActiveForm，窗体必须是被激活的当前窗体，才能修改其属性    Form1.ActiveForm.BackColor = Color.AliceBlue;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 换标题private void button2_Click(object sender, EventArgs e){    Form1.ActiveForm.Text = "换标题";}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>效果如下<img src="form窗体控制-1705156191295-7.gif" alt="" style="zoom:33%;"></li></ul><h3 id="2-3-鼠标事件"><a href="#2-3-鼠标事件" class="headerlink" title="2.3 鼠标事件"></a>2.3 鼠标事件</h3><ul><li><p>具体代码文件见<code>D:\Program Files\Microsoft Visual Studio\projects\start\Mouse</code></p></li><li><p>以<code>PictureBox</code>显示本地图片，通过鼠标触发<code>Click、MouseClick、DoubleClick、MouseHover事件</code></p></li></ul><h4 id="2-3-1-PictureBox显示图片"><a href="#2-3-1-PictureBox显示图片" class="headerlink" title="2.3.1 PictureBox显示图片"></a>2.3.1 PictureBox显示图片</h4><ul><li>拖动该控件到<code>Form1</code>窗体内</li><li>找到<code>Image</code>属性，通过<code>...</code>导入本地图片即可</li></ul><h4 id="2-3-2-例程1-–-Click事件"><a href="#2-3-2-例程1-–-Click事件" class="headerlink" title="2.3.2 例程1 – Click事件"></a>2.3.2 例程1 – Click事件</h4><ul><li><p>任意<strong>单击</strong>事件，包括鼠标、键盘等</p></li><li><p>点击后通过<code>MessageBox</code>进行提示</p></li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 单击事件private void pictureBox1_Click(object sender, EventArgs e){    MessageBox.Show("Click事件");}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>效果如下<img src="Click事件-1705156191295-8.gif" alt="" style="zoom:33%;"></li></ul><h4 id="2-3-3-例程2-–-MouseClick事件"><a href="#2-3-3-例程2-–-MouseClick事件" class="headerlink" title="2.3.3 例程2 – MouseClick事件"></a>2.3.3 例程2 – MouseClick事件</h4><ul><li><strong>鼠标单击</strong>事件</li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">private void pictureBox1_MouseClick(object sender, MouseEventArgs e){    // e.Button.ToString()的取值分别为Left、Middle、Right，为鼠标三个按键    // 可用于条件判断    MessageBox.Show(e.Button.ToString());}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>效果如下<img src="/2024/01/13/shang-wei-ji/MouseClick%E4%BA%8B%E4%BB%B6-1705156191295-9.gif" alt="MouseClick事件"></li></ul><h4 id="2-3-4-例程3-–-DoubleClick事件"><a href="#2-3-4-例程3-–-DoubleClick事件" class="headerlink" title="2.3.4 例程3 – DoubleClick事件"></a>2.3.4 例程3 – DoubleClick事件</h4><ul><li><p>任意<strong>双击</strong>事件（双击包含单击事件，当同时存在单击事件时，只触发单击事件）</p></li><li><p>同样通过<code>MessageBox</code>提示</p></li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">private void pictureBox1_DoubleClick(object sender, EventArgs e){    MessageBox.Show("DoubleClick事件");}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li>效果如下<img src="DoubleClick事件-1705156191295-10.gif" alt="DoubleClick事件" style="zoom:33%;"></li></ul><h4 id="2-3-5-例程4-–-MouseHover事件"><a href="#2-3-5-例程4-–-MouseHover事件" class="headerlink" title="2.3.5 例程4 – MouseHover事件"></a>2.3.5 例程4 – MouseHover事件</h4><ul><li>当鼠标移动到上方时触发</li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">private void pictureBox1_MouseHover(object sender, EventArgs e){    MessageBox.Show("MouseHover事件");}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li>效果如下<img src="MouseHover事件-1705156191295-11.gif" alt="" style="zoom:33%;"></li></ul><h3 id="2-4-多窗体"><a href="#2-4-多窗体" class="headerlink" title="2.4 多窗体"></a>2.4 多窗体</h3><h4 id="2-4-1-创建启动窗体"><a href="#2-4-1-创建启动窗体" class="headerlink" title="2.4.1 创建启动窗体"></a>2.4.1 创建启动窗体</h4><ul><li>创建一个登录界面，点击登陆后（此处不对账号密码进行判断），跳转界面</li><li>登录界面<code>Form1</code>如下图所示<ul><li><img src="image-20231029181612428-1705156191295-12.png" alt="" style="zoom: 50%;"></li></ul></li></ul><h4 id="2-4-2-创建跳转窗体"><a href="#2-4-2-创建跳转窗体" class="headerlink" title="2.4.2 创建跳转窗体"></a>2.4.2 创建跳转窗体</h4><ul><li>跳转窗体界面<code>Form2</code>如下图所示<ul><li><img src="image-20231029182144541-1705156191295-13.png" alt="" style="zoom: 50%;"></li></ul></li></ul><h4 id="2-4-3-跳转"><a href="#2-4-3-跳转" class="headerlink" title="2.4.3 跳转"></a>2.4.3 跳转</h4><ul><li><p>具体代码文件见<code>D:\Program Files\Microsoft Visual Studio\projects\start\MutipleForm</code></p></li><li><p>点击启动界面的<code>登录</code>按钮后，跳转到新窗体</p></li></ul><h5 id="2-4-3-1-例程1-–-跳转-不关闭原窗口"><a href="#2-4-3-1-例程1-–-跳转-不关闭原窗口" class="headerlink" title="2.4.3.1 例程1 – 跳转-不关闭原窗口"></a>2.4.3.1 例程1 – 跳转-不关闭原窗口</h5><ul><li>双击<code>Form1</code>登录按钮，生成<code>Click</code>事件</li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 登录弹窗private void button2_Click(object sender, EventArgs e){    Form2 f2 = new Form2();    f2.Show();}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>实现效果如下图，此时，关闭<code>Form1</code>，<code>Form2</code>也自动关闭（因为<code>Form2</code>在<code>Form1</code>类内部生成，视作<code>Form1</code>窗体的一部分）；反之需逐一关闭<img src="/2024/01/13/shang-wei-ji/%E8%B7%B3%E8%BD%AC-%E4%B8%8D%E5%85%B3%E9%97%AD%E5%8E%9F%E7%AA%97%E5%8F%A3-1705156191295-14.gif" alt="跳转-不关闭原窗口"></li></ul><h5 id="2-4-3-2-例程2-–-跳转-隐藏原窗口"><a href="#2-4-3-2-例程2-–-跳转-隐藏原窗口" class="headerlink" title="2.4.3.2 例程2 – 跳转-隐藏原窗口"></a>2.4.3.2 例程2 – 跳转-隐藏原窗口</h5><ul><li><p>隐藏窗口后，该窗口仍然占据内存空间，正常运行，需通过任务管理器进行关闭！！！</p></li><li><p>修改<code>button2_Click</code>方法</p></li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">private void button2_Click(object sender, EventArgs e){    Form2 f2 = new Form2();    f2.Show();        // 因为button2_Click()方法在类Form1内，所以以下两种方法皆可，都是对Form1窗口进行隐藏    this.Hide();    // Hide();}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>效果如下<img src="跳转-隐藏原窗口-1705156191295-15.gif" alt="" style="zoom:33%;"></li></ul><h5 id="2-4-3-3-例程3-–-跳转-关闭原窗口"><a href="#2-4-3-3-例程3-–-跳转-关闭原窗口" class="headerlink" title="2.4.3.3 例程3 – 跳转-关闭原窗口"></a>2.4.3.3 例程3 – 跳转-关闭原窗口</h5><ul><li><p>扩展</p><ul><li><p>窗体<code>ShowDialog()</code>方法，默认使用模态方式</p></li><li><p>模态：以当前窗体为焦点，不能点击该程序的其他窗体</p></li></ul></li></ul><p><strong>（1）委托线程</strong></p><ul><li><p>首先在<code>Form1.cs</code>导入命名空间<code>using System.Threading;</code></p></li><li><p>接着修改<code>button2_Click()</code></p></li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">private void button2_Click(object sender, EventArgs e){    Form2 f2 = new Form2();    //f2.Show();    //this.Hide();    // 委托一个线程去显示新窗体    Thread t1 = new Thread(delegate () { f2.ShowDialog(); });    // 开启线程    t1.Start();    Close();}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>效果如下<img src="跳转-关闭原窗口-委托线程-1705156191295-16.gif" alt="" style="zoom:33%;"></li></ul><p><strong>（2）Application.Run()方法</strong></p><ul><li>通过在<code>Program.cs</code>启动文件中建立标志变量监测第一个窗口关闭，之后打开<code>Form2</code></li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// Program.cs文件 Prigram类internal static class Program {     // 定义标志变量flag     public static bool flag = false;     /// &lt;summary&gt;     /// 应用程序的主入口点。     /// &lt;/summary&gt;     [STAThread]     static void Main()     {         Application.EnableVisualStyles();         Application.SetCompatibleTextRenderingDefault(false);         Application.Run(new Form1());                  // 当原窗口被关闭，flag==true时，打开新窗口         if (flag)         {             Application.Run(new Form2());         }     } }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// Form1.cs文件中方法 button2_Click()private void button2_Click(object sender, EventArgs e){    // 因为flag定义在Program类中，所以重新赋值时，需要加上前缀Program.flag    Program.flag = true;    // 关闭Form1    Close();}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>效果如下<img src="/2024/01/13/shang-wei-ji/%E8%B7%B3%E8%BD%AC-%E5%85%B3%E9%97%AD%E5%8E%9F%E7%AA%97%E5%8F%A3-Application.Run()%E6%96%B9%E6%B3%95.gif" alt="跳转-关闭原窗口-Application.Run(./../../../../Typora/Projects/上位机/assets/跳转-关闭原窗口-Application.Run()方法.gif)方法"></li></ul><h3 id="2-5-复选框及复选框列表"><a href="#2-5-复选框及复选框列表" class="headerlink" title="2.5 复选框及复选框列表"></a>2.5 复选框及复选框列表</h3><ul><li><code>CheckBox</code>复选框控件</li><li><code>CheckBoxList</code>复选框列表控件：内含多个复选框控件（需要自行配置）</li></ul><h4 id="2-5-1-CheckBox控件"><a href="#2-5-1-CheckBox控件" class="headerlink" title="2.5.1 CheckBox控件"></a>2.5.1 CheckBox控件</h4><ul><li><p>图例：<img src="image-20231030181830622-1705156191295-17.png" alt="" style="zoom:50%;"></p></li><li><p><code>CheckBox.Checked</code>属性：获取该复选框有没有被勾选</p></li><li><p><code>CheckBox.Text</code>属性：获取该复选框文本内容</p></li></ul><h4 id="2-5-2-CheckBoxList控件"><a href="#2-5-2-CheckBoxList控件" class="headerlink" title="2.5.2 CheckBoxList控件"></a>2.5.2 CheckBoxList控件</h4><ul><li>选择时，首先会定位，然后才能选中</li><li><code>CheckBoxList.SelectItem</code>属性：获取当前选中项</li><li><code>checkedListBox.Items.Add(string)</code>：<strong>动态添加</strong>选项</li><li><code>checkedListBox.Items.Remove</code>：<strong>动态删除</strong>选项</li><li><code>ItemCheck</code>事件：当复选框被勾选时触发</li><li><code>SelectedIndexChanged</code>事件：未勾选选项，选中选项标题时就会触发</li></ul><h3 id="2-6-时钟"><a href="#2-6-时钟" class="headerlink" title="2.6 时钟"></a>2.6 时钟</h3><ul><li><p>时间单位<code>ms</code></p></li><li><p>作用：对有规律的事物进行输出，每隔指定时间，对一程序进行输出</p></li><li><p><code>Timer</code>配置</p><ul><li><p>配置时间，<code>Interval</code>属性</p></li><li><p>是否启动，<code>Enabled</code>属性</p></li><li><p>配置事件，<code>Tick</code>事件，在其中执行相应事件</p></li></ul></li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// Enable后，每隔Interval时间，执行一次Tick事件private void timer1_Tick(object sender, EventArgs e){    // 通过label控件，将当前时间显示在窗口，并每隔Interval时间刷新一下    label1.Text = DateTime.Now.ToString();}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-7-图片"><a href="#2-7-图片" class="headerlink" title="2.7 图片"></a>2.7 图片</h3><h4 id="2-7-1-PictureBox控件"><a href="#2-7-1-PictureBox控件" class="headerlink" title="2.7.1 PictureBox控件"></a>2.7.1 PictureBox控件</h4><ul><li><p><code>PictureBox</code>控件</p></li><li><p><code>Picture.SizeMode</code>属性，更改图片显示拉伸情况</p></li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 将图片设置为自动拉伸，大小随展示图片框变化pictureBox1.SizeMode = PictureBoxSizeMode.StretchImage;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li><code>PictureBox.Image</code>属性，导入图片</li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 传入图片例子PictureBox.Image = Image.FromFile("图片位置");// Application.StartupPath，位置为xx\bin\debugPictureBox.Image = Image.FromFile(Application.StartupPath + @"\自建图片位置");<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p><strong>图片位置坐标</strong></p><ul><li><p><code>PictureBox.Left</code>属性，int类型，为控件左边缘与form窗体左边缘的<strong>像素距离</strong>，即可代表**<code>x</code>坐标**的值</p></li><li><p><code>PictureBox.Top</code>属性，控件上边缘与Form窗体上边缘的像素距离，代表**<code>y</code>坐标**的值</p><ul><li>（x, y）坐标为图片左上角顶点坐标，<strong>xy轴方向同图像坐标</strong></li></ul></li></ul></li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 使用时钟控件，实现图片的自动水平移动private void timer1_Tick(object sender, EventArgs e){  // enable时钟后，随interval时间间隔改变图片x坐标  pictureBox1.Left += 1;  // 改变图片y坐标  pictureBox1.Top += 1;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-7-2-例程1-–-猫咪避障"><a href="#2-7-2-例程1-–-猫咪避障" class="headerlink" title="2.7.2 例程1 – 猫咪避障"></a>2.7.2 例程1 – 猫咪避障</h4><ul><li><p>具体代码文件见<code>D:\Program Files\Microsoft Visual Studio\projects\start\plane</code></p></li><li><p>通过使用<code>MouseDown、MouseUp、MouseMove</code>三个事件，实现鼠标拖动猫咪避障</p></li><li><p>首先定外部变量</p></li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 标志变量记录鼠标左键是否按下bool flag = false;// 图片初始坐标int oldX = 0;int oldY = 0;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>当鼠标左键在图片中被按下时，获取当前鼠标坐标，并作为图片初始移动坐标</li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">private void pictureBox1_MouseDown(object sender, MouseEventArgs e){    // 当被按下的键为鼠标左键时执行    if(e.Button == MouseButtons.Left)    {        flag = true;        oldX = e.X;        oldY = e.Y;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>当鼠标左键抬起时，置<code>flag</code>变量为<code>false</code>，停止鼠标拖动图片移动</li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">private void pictureBox1_MouseUp(object sender, MouseEventArgs e){    if (e.Button == MouseButtons.Left)    {        flag = false;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>当鼠标左键被按下并移动时，更新图片坐标</li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">private void pictureBox1_MouseMove(object sender, MouseEventArgs e){    if (flag)    {        // 更新xy坐标        // 拖动的效果是连续的，因为每当鼠标移动1个像素，图片立即就进行相应移动        // 所以从视觉上来看是连续的，非卡顿的        pictureBox1.Left += e.X - oldX;        pictureBox1.Top += e.Y - oldY;    }    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>效果如下<img src="/2024/01/13/shang-wei-ji/%E7%8C%AB%E5%92%AA%E9%81%BF%E9%9A%9C-1705156191295-18.gif" alt="猫咪避障"></li></ul><h4 id="2-7-3-例程2-–-画布软件"><a href="#2-7-3-例程2-–-画布软件" class="headerlink" title="2.7.3 例程2 – 画布软件"></a>2.7.3 例程2 – 画布软件</h4><ul><li><p>具体代码文件见<code>D:\Program Files\Microsoft Visual Studio\projects\start\draw</code></p></li><li><p>同样使用<code>MouseDown、MouseUp、MouseMove、ButtonClick</code>事件实现复制粘贴图片、画笔绘图操作</p></li><li><p>搭建界面如图</p><ul><li><img src="image-20231101163806614-1705156191295-19.png" alt="" style="zoom: 50%;"></li></ul></li><li><p>首先定义全局变量</p></li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 定义图片对象Image curImg;// 记录鼠标第一次点击bool moving = false;// 定义图片尺寸int curImgWidth = 0;int curImgHeight = 0;// 记录画笔颜色Color curColor;// 是否使用画笔bool usePen = false;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>当已有的两张图片被点击，获取该图片路径及尺寸，并把<code>usePen</code>置为<code>false</code></li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 第一张图的MouseDown事件private void pictureBox1_MouseDown(object sender, MouseEventArgs e){    curImg = Image.FromFile(@"img\1.jpg");    curImgWidth = pictureBox1.Width;    curImgHeight = pictureBox1.Height;        // 为避免在图片粘贴时，同步产生画笔绘制效果，将usePen置为false    usePen = false;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 第二张图MouseDown事件private void pictureBox2_MouseDown(object sender, MouseEventArgs e){    curImg = Image.FromFile(@"img\2.jpg");    curImgWidth = pictureBox2.Width;    curImgHeight = pictureBox2.Height;    usePen = false;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>当<code>使用画笔</code>按钮被按下后，弹出颜色选框，并设定画笔颜色</li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// "使用画笔"按钮，click事件private void button1_Click(object sender, EventArgs e){    // colorDialog控件    // colorDialog1.ShowDialog()，开启颜色选框，返回颜色选择状态    // 如果选择完毕，返回ok    if (colorDialog1.ShowDialog() == DialogResult.OK)    {        // 将当前选中的颜色赋值给curColor对象        curColor = colorDialog1.Color;        // 画笔绘制时，将要粘贴的图片对象置空，避免粘贴图片与画笔绘制冲突        curImg = null;        // 将画笔标志变量置为true        usePen = true;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>对于画布，分别处理<code>MouseDown、MouseUp、MouseMOve</code>事件</li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// MouseDown事件private void pictureBox3_MouseDown(object sender, MouseEventArgs e){    moving = true;    // 创建绘制功能    Graphics g = pictureBox3.CreateGraphics();    // 当图片没有装载的时候，默认值为null        if(curImg == null &amp;&amp; usePen == false)    {        MessageBox.Show("没有点选图片或画笔");        return;    }    if(curImg != null &amp;&amp; usePen == false)    {        // 在xy坐标位置绘制图片，贴图        g.DrawImage(curImg, e.X - curImgWidth / 2, e.Y - curImgHeight / 2, curImgWidth, curImgHeight);    }    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// MouseUp事件private void pictureBox3_MouseUp(object sender, MouseEventArgs e){    moving = false;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// MouseMove事件private void pictureBox3_MouseMove(object sender, MouseEventArgs e){    if (moving &amp;&amp; usePen)    {        // 创建画布功能        Graphics g = pictureBox3.CreateGraphics();        // 画图前必须要先创建画笔        // 构造函数参数是要设置的 画笔颜色        Pen pen = new Pen(curColor);        g.DrawEllipse(pen,e.X,e.Y,2,2);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>对于<code>清空画布</code>按钮，将背景填充为白色即可</li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// "清空画布"按钮private void button2_Click(object sender, EventArgs e){    // 清空画布，填充白色    pictureBox3.CreateGraphics().Clear(Color.White);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>效果如下<img src="/2024/01/13/shang-wei-ji/%E7%94%BB%E5%9B%BE%E8%BD%AF%E4%BB%B6-1705156191296-20.gif" alt="画图软件"></li></ul><h3 id="2-8、Chart图表控件"><a href="#2-8、Chart图表控件" class="headerlink" title="2.8、Chart图表控件"></a>2.8、Chart图表控件</h3><h4 id="2-8-1-界面布局"><a href="#2-8-1-界面布局" class="headerlink" title="2.8.1 界面布局"></a>2.8.1 界面布局</h4><ul><li><code>Tablelayout</code>容器控件</li><li>每个单元格默认放置一个控件</li><li>更好地规划界面</li></ul><h4 id="2-8-2-图表界面简介"><a href="#2-8-2-图表界面简介" class="headerlink" title="2.8.2 图表界面简介"></a>2.8.2 图表界面简介</h4><ul><li><code>Chart</code>控件</li><li>关键属性的配置，如标题、坐标系、图例</li></ul><h4 id="2-8-3-例程-–-图像绘制"><a href="#2-8-3-例程-–-图像绘制" class="headerlink" title="2.8.3 例程 – 图像绘制"></a>2.8.3 例程 – 图像绘制</h4><ul><li>具体代码文件见<code>D:\Program Files\Microsoft Visual Studio\projects\start\chart</code></li></ul><h5 id="2-8-3-1-界面布局"><a href="#2-8-3-1-界面布局" class="headerlink" title="2.8.3.1 界面布局"></a>2.8.3.1 界面布局</h5><ul><li>在Form内，任意放置容器控件<code>TableLayoutPanel</code></li><li>修改属性<code>Dock</code>，填充方式，此处选用<code>Fill</code>，如下图所示<ul><li><img src="image-20231028175453329-1705156191296-21.png" alt="" style="zoom: 25%;"></li></ul></li></ul><h5 id="2-8-3-2-插入图形界面"><a href="#2-8-3-2-插入图形界面" class="headerlink" title="2.8.3.2 插入图形界面"></a>2.8.3.2 插入图形界面</h5><ul><li>在<code>TableLayoutPanel</code>任一单元格内放置<code>Chart</code>图形控件</li><li>同样修改填充属性<code>Dock</code>，全填充<code>Fill</code>，效果如图<ul><li><img src="image-20231028180056717-1705156191296-22.png" alt="" style="zoom: 25%;"></li></ul></li></ul><h6 id="2-8-3-2-1-图表类属性-Titels"><a href="#2-8-3-2-1-图表类属性-Titels" class="headerlink" title="2.8.3.2.1 图表类属性-Titels"></a>2.8.3.2.1 图表类属性-Titels</h6><ul><li><p>点击<code>...</code>打开<code>Titles</code>集合编辑器</p><ul><li><img src="image-20231028181107970-1705156191296-23.png" alt="" style="zoom:25%;"></li></ul></li><li><p>添加成员（可添加多个，即显示出来的图像会有相应个数的标题）</p><ul><li>成员属性<code>Text</code>：设置标题名称</li><li>成员属性<code>ToolTip</code>：设置提示消息，当用户鼠标放置在图形标题名称上时</li></ul></li></ul><h6 id="2-8-3-2-2-图标类属性-Series"><a href="#2-8-3-2-2-图标类属性-Series" class="headerlink" title="2.8.3.2.2 图标类属性-Series"></a>2.8.3.2.2 图标类属性-Series</h6><ul><li><p>可设置图像类型，如条形图、曲线图、扇形图</p></li><li><p>同样点击<code>...</code>打开<code>Series</code>集合编辑器</p><ul><li><img src="image-20231028182104785-1705156191296-24.png" alt="" style="zoom: 25%;"></li></ul></li><li><p>添加成员（每添加一个，显示图形上就会产生一个新的图例）</p><ul><li>成员属性<code>ChartType</code>：设置图像类型，如：<code>Column</code>、<code>Spline</code>、<code>Pie</code>等</li></ul></li></ul><h6 id="2-8-3-2-3-图标类属性-Legends"><a href="#2-8-3-2-3-图标类属性-Legends" class="headerlink" title="2.8.3.2.3 图标类属性-Legends"></a>2.8.3.2.3 图标类属性-Legends</h6><h5 id="2-8-3-3-数据传入"><a href="#2-8-3-3-数据传入" class="headerlink" title="2.8.3.3 数据传入"></a>2.8.3.3 数据传入</h5><ul><li>主要函数<code>chart1.Series[0].Points.Add(数据序列);</code></li></ul><h6 id="2-8-3-3-1-Form窗体Load事件"><a href="#2-8-3-3-1-Form窗体Load事件" class="headerlink" title="2.8.3.3.1 Form窗体Load事件"></a>2.8.3.3.1 Form窗体Load事件</h6><ul><li><p>使用<code>Form</code>窗体<code>Load</code>事件（窗体加载完成时，就绘制好图线）</p></li><li><p>双击<code>Load</code>事件，在<code>Form1_Load</code>方法中随机产生10个数据，窗体加载完成就绘制出完整图形</p></li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">private void Form1_Load(object sender, EventArgs e){Random rnd = new Random();    for (int i = 0; i &lt; 10; i++)    {        //Random rnd = new Random();        // 给图表传入数据        chart1.Series[0].Points.Add(rnd.Next(0, 101));    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h6 id="2-8-3-3-2-Timer组件"><a href="#2-8-3-3-2-Timer组件" class="headerlink" title="2.8.3.3.2 Timer组件"></a>2.8.3.3.2 Timer组件</h6><ul><li><p>行为属性<code>Enable</code>：启动<code>timer</code>计时，必须设置为<code>True</code>才会启动</p></li><li><p>行为属性<code>Interval</code>：时间间隔，单位ms，此例设置为500</p></li><li><p>双击<code>Timer</code>组件，<code>timer1_Tick</code>中每隔500ms产生一个随机数，并绘制到图形上</p></li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">private void timer1_Tick(object sender, EventArgs e){    /*    // 若只显示最新的10个点    if (chart1.Series[0].Points.Count() == 10)    {        // 当存在10个数据时，移除第一个点        chart1.Series[0].Points.RemoveAt(0);    }    */        Random rnd = new Random();    chart1.Series[0].Points.Add(rnd.Next(0, 101));}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h6 id="2-8-3-3-3-数据点取值可视化"><a href="#2-8-3-3-3-数据点取值可视化" class="headerlink" title="2.8.3.3.3 数据点取值可视化"></a>2.8.3.3.3 数据点取值可视化</h6><ul><li><p>在<code>Timer</code>组件基础上进行代码的修改</p></li><li><p>首先引入<code>using System.Windows.Forms.DataVisualization.Charting; </code></p></li><li><p>修改代码如下</p></li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">private void timer1_Tick(object sender, EventArgs e){    // 若只显示最新的10个点    if (chart1.Series[0].Points.Count() == 10)    {        // 当存在10个数据时，移除第一个点        chart1.Series[0].Points.RemoveAt(0);    }    Random rnd = new Random();    int curnum = rnd.Next(0, 101);        // 创建数据点对象    DataPoint dp1 = new DataPoint();    // 通过double[] 为数据点传入y值    dp1.YValues = new double[] { curnum };    // 定义数据点标签    dp1.Label = curnum.ToString();    chart1.Series[0].Points.Add(dp1);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="2-8-3-4-同数据-多图展示"><a href="#2-8-3-4-同数据-多图展示" class="headerlink" title="2.8.3.4 同数据-多图展示"></a>2.8.3.4 同数据-多图展示</h5><ul><li>在6.3.3.3代码基础上修改，通过for循环同时绘制4个图表</li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">private void timer1_Tick(object sender, EventArgs e){    for (int i = 1;i &lt;= 4;i++)    {        // 在tableLayoutPanel1中找到图表控件，并取返回的同名子控件（find参数要设置为true）数组的第一个，转换为Chart类型        Chart myChart = tableLayoutPanel1.Controls.Find("chart" + i.ToString(), true)[0] as Chart;                // 若只显示最新的10个点        if (myChart.Series[0].Points.Count() == 10)        {            // 当存在10个数据时，移除第一个点            myChart.Series[0].Points.RemoveAt(0);        }        Random rnd = new Random();        int curnum = rnd.Next(0, 11);        DataPoint dp1 = new DataPoint();        dp1.YValues = new double[] { curnum };            dp1.Label = curnum.ToString();        myChart.Series[0].Points.Add(dp1);    }    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>效果如下<img src="/2024/01/13/shang-wei-ji/chart%E5%9B%BE%E8%A1%A8-1705156191296-25.gif" alt="chart图表"></li></ul><h3 id="2-9-右键菜单及打开文件对话框"><a href="#2-9-右键菜单及打开文件对话框" class="headerlink" title="2.9 右键菜单及打开文件对话框"></a>2.9 右键菜单及打开文件对话框</h3><h4 id="2-9-1-右键菜单"><a href="#2-9-1-右键菜单" class="headerlink" title="2.9.1 右键菜单"></a>2.9.1 右键菜单</h4><ul><li>使用控件<code>ContexMenuStrip</code>，设置好菜单选项</li><li><code>Form窗体、PictureBox等控件</code>，有个<code>ContextMenuStrip</code>行为属性，可在控件内启用相应的右键菜单功能</li><li>设置好的<strong>每一个菜单选项，都是一个子控件</strong>，拥有自己的属性方法及触发事件</li></ul><h4 id="2-9-2-打开文件对话框"><a href="#2-9-2-打开文件对话框" class="headerlink" title="2.9.2 打开文件对话框"></a>2.9.2 打开文件对话框</h4><ul><li>使用控件<code>openFileDialog</code><ul><li><code>openFileDialog.Title</code>属性，设置对话框<strong>标题</strong></li><li><code>openFileDialog.Filter</code>属性，设置文件<strong>类型过滤</strong></li><li><code>openFileDialog.InitialDirectory</code>属性，设置文件对话框<strong>打开初始路径</strong></li><li><code>openFileDialog.ShowDialog()</code>方法，<strong>打开文件对话框</strong></li><li><code>openFileDialog.FileName</code>属性，返回打开文件的<strong>绝对路径</strong></li></ul></li></ul><h4 id="2-9-3-例程-–-右键菜单更换图片"><a href="#2-9-3-例程-–-右键菜单更换图片" class="headerlink" title="2.9.3 例程 – 右键菜单更换图片"></a>2.9.3 例程 – 右键菜单更换图片</h4><ul><li><p><code>具体代码文件见D:\Program Files\Microsoft Visual Studio\projects\start\RightMenu</code></p></li><li><p>界面设计如下</p><ul><li><img src="image-20231101190346048-1705156191296-26.png" alt="" style="zoom: 50%;"></li></ul></li><li><p>首先设置右键菜单选项，并在<code>Form</code>窗体属性中设置<code>ContextMenuStrip</code>为定义好的<code>右键菜单控件名</code></p></li><li><p>对于右键菜单第一个选项<code>你干嘛</code>，单击该选项，并创建<code>click</code>事件</p></li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 当"你干嘛"选项被选中后，触发该click事件，通过messageBox打印相应语句private void 你干嘛ToolStripMenuItem_Click(object sender, EventArgs e){    MessageBox.Show("你干嘛小黑子");}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>对于第二个选项<code>换背景</code>，同样创建<code>click</code>事件</li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">private void 换背景ToolStripMenuItem_Click(object sender, EventArgs e){    // 设置文件选框标题    openFileDialog1.Title = "请选择一张图片";    // 文件类型过滤    // 配置格式：文件说明|文件扩展名    // 同种类型文件，用分号隔开    openFileDialog1.Filter = "图片文件(*.bmp;*.jpg;*.png;*.jepg;*.gif)|*.bmp;*.jpg;*.png;*.jepg;*.gif|任意类型(*.*)|*.*";    // 选框默认打开路径为前一次文件位置    // 可对选框打开文件位置进行默认设置    // openFileDialog1.InitialDirectory = Application.StartupPath;    // 当文件成功被选择    if(openFileDialog1.ShowDialog() == DialogResult.OK)    {        pictureBox1.SizeMode = PictureBoxSizeMode.StretchImage;        // 将选择的文件绝对路径传给pictureBox进行展示        pictureBox1.Image = Image.FromFile(openFileDialog1.FileName);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>效果展示<img src="右键菜单更换图片-1705156191296-27.gif" alt="" style="zoom: 33%;"></li></ul><h3 id="2-10-（本节因没有本地用户和组，无法进行操作学习！！！！）"><a href="#2-10-（本节因没有本地用户和组，无法进行操作学习！！！！）" class="headerlink" title="2.10 （本节因没有本地用户和组，无法进行操作学习！！！！）"></a>2.10 （本节因没有本地用户和组，无法进行操作学习！！！！）</h3><h4 id="2-10-1-下拉列表"><a href="#2-10-1-下拉列表" class="headerlink" title="2.10.1 下拉列表"></a>2.10.1 下拉列表</h4><ul><li><code>ComboBox</code>控件，下拉列表<ul><li><code>ComboBox.DropDownStyle</code>属性，设置下拉列表样式，可用取值分别为</li><li><code>ComboBox.Items.Add()</code>方法，添加项</li><li><code>ComboBox.Items.Contains()</code>，判断当前下拉框是否包含指定项</li><li><code>ComboBox.Text</code>属性，获取当前选中项文本</li><li><code>ComboBox.Items.Remove()</code>方法，删除指定项</li></ul></li></ul><h4 id="2-10-2"><a href="#2-10-2" class="headerlink" title="2.10.2"></a>2.10.2</h4><ul><li><code>directoryEntry</code>控件</li></ul><h3 id="2-11-系统语音功能及日期时间"><a href="#2-11-系统语音功能及日期时间" class="headerlink" title="2.11 系统语音功能及日期时间"></a>2.11 系统语音功能及日期时间</h3><h4 id="2-11-1-语音功能"><a href="#2-11-1-语音功能" class="headerlink" title="2.11.1 语音功能"></a>2.11.1 语音功能</h4><ul><li>本质上是调用系统的<code>tts</code>功能（将<strong>文本转为语音</strong>的功能，<code>tts</code>在<code>com</code>组件中有）</li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 核心代码Type type = Type.GetTypeFromProgID("SAPI.SpVoice");dynamic spVoice = Activator.CreateInstance(type);spVoice.Speak("Text To Speech 语音朗读文本技术");<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-11-2-日期时间"><a href="#2-11-2-日期时间" class="headerlink" title="2.11.2 日期时间"></a>2.11.2 日期时间</h4><ul><li><p><code>dateTimePicker</code>控件</p><ul><li><p><code>Format</code>属性，设置日期格式</p></li><li><p><code>CustomFormat</code>属性，当<code>Format</code>设置为<code>Custom</code>自定义格式时，可自行设日期时间格式，如</p></li></ul></li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 设置为以下格式yyyy年MM月dd日 HH:mm:ss<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="2-11-3-例程-–-个性语音闹钟"><a href="#2-11-3-例程-–-个性语音闹钟" class="headerlink" title="2.11.3 例程 – 个性语音闹钟"></a>2.11.3 例程 – 个性语音闹钟</h4><ul><li><p><code>具体代码文件见D:\Program Files\Microsoft Visual Studio\projects\start\Voice</code></p></li><li><p>搭建界面如下</p><ul><li><img src="image-20231102112708004-1705156191296-28.png" alt="" style="zoom: 50%;"></li></ul></li><li><p>当按下<code>添加闹钟</code>按钮后，将<code>dateTimePicker</code>的日期时间及<code>textBox</code>中的自定义事件分别存储到<code>listBox</code>中</p></li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">private void button1_Click(object sender, EventArgs e){    // 必须使用Value属性，不能使用Text，不然没有反应！！！    listBox1.Items.Add(dateTimePicker1.Value);    listBox2.Items.Add(textBox1.Text);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>接着，在界面内添加一个<code>timer</code>时钟控件，设置默认状态<code>enable</code>为启动</p></li><li><p>程序开始运行，<code>timerTick</code>事件，不断读取<code>listBox1</code>中的时间，当其与当前系统时间一致时，启动语音模块，并朗读事件，之后删除该闹钟事件</p></li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">private void timer1_Tick(object sender, EventArgs e){    // 遍历listBox1中的时间    for(int i = 0; i &lt; listBox1.Items.Count; i++)    {        // 找到预设闹钟时间        if (listBox1.Items[i].ToString() == DateTime.Now.ToString())        {            // 执行语音            // 找到语音模块            Type t = Type.GetTypeFromProgID("SAPI.SpVoice");            // 创建语音实例            // dynamic 动态进行类型转换，可规避语法错误            dynamic mySp = Activator.CreateInstance(t);            // 语音外放            mySp.Speak(listBox2.Items[i].ToString());            // 删除闹钟事件            listBox1.Items.RemoveAt(i);            listBox2.Items.RemoveAt(i);            return;        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>效果如下</p><ul><li><video src="./video/个性语音闹钟.mp4"></video></li></ul></li></ul><h3 id="2-12-列表视图"><a href="#2-12-列表视图" class="headerlink" title="2.12 列表视图"></a>2.12 列表视图</h3><h4 id="2-12-1-comboBox、listBox、listView的区别"><a href="#2-12-1-comboBox、listBox、listView的区别" class="headerlink" title="2.12.1 comboBox、listBox、listView的区别"></a>2.12.1 comboBox、listBox、listView的区别</h4><ul><li><code>comboBox</code>控件：下拉列表，有下拉、滚动条、下拉+输入三种模式</li><li><code>listBox</code>控件：单行项目记录</li><li><code>listView</code>控件：简单的项目行，表格的感觉</li></ul><h4 id="2-12-2-配置listView"><a href="#2-12-2-配置listView" class="headerlink" title="2.12.2 配置listView"></a>2.12.2 配置listView</h4><ul><li><code>Columns</code>属性：设置列标题<ul><li>添加成员后通过<code>Text</code>设置<strong>列标题</strong>名</li><li>同时通过<code>TextAlign</code>设置居中状态</li></ul></li><li><code>view</code>属性：调整视图模式<ul><li><code>details</code>可在构建界面时展示出列表情况，如列标题</li></ul></li><li><code>Items</code>属性：<ul><li><code>Text</code>设置当前行第一个单元格名称（<strong>行标题</strong>）</li><li><code>SubItems</code>设置第二个及其之后单元格</li><li><code>ImageIndex</code>属性，配置图表，使用<code>SmallImageList</code>中的图片<ul><li>使用前先要将<code>imageList</code>控件拖到<code>Form</code>窗体中，并通过<code>Images</code>属性导入图片</li></ul></li></ul></li></ul><h4 id="2-12-3-例程1-–-表格记录软件"><a href="#2-12-3-例程1-–-表格记录软件" class="headerlink" title="2.12.3 例程1 – 表格记录软件"></a>2.12.3 例程1 – 表格记录软件</h4><ul><li><p><code>具体代码文件见D:\Program Files\Microsoft Visual Studio\projects\start\listView</code></p></li><li><p>界面搭建如下</p><ul><li><img src="image-20231102185842982-1705156191296-29.png" alt="" style="zoom: 50%;"></li></ul></li><li><p><code>imageList</code>要与<code>ListView</code>关联起来</p></li><li><p>首先是<code>添加</code>按键，在<code>textBox</code>中输入文本后，添加进表格</p></li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// "添加"按键事件private void button1_Click(object sender, EventArgs e){    // 添加一行Item    // new ListViewItem()的参数分别为每一单元格的Text数组，和ImageList索引    // listView1.Items.Add(new ListViewItem(new string[] {"1","2","3","4"}, 2));    // 输入添加    listView1.Items.Add(new ListViewItem(new string[] { textBox1.Text, textBox2.Text, textBox3.Text, textBox4.Text }, 2));    // 鼠标单击选中后，修改已有单元格}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>对于<code>修改</code>按键，鼠标选中某一行后，将改行文本显示在<code>textBox</code>中，修改文本过后，更新表格</li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 外部变量，选中对象索引int ind = -1;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 鼠标选中任意行显示到textBoxprivate void listView1_SelectedIndexChanged(object sender, EventArgs e){    // 当选中对象不为空    if (listView1.SelectedItems.Count != 0)    {        // 获取最新选择对象在listview1中的索引        ind = listView1.SelectedIndices[0];        // 将当前listview中被点击的行名称显示到textBox        textBox1.Text = listView1.Items[ind].SubItems[0].Text;        textBox2.Text = listView1.Items[ind].SubItems[1].Text;        textBox3.Text = listView1.Items[ind].SubItems[2].Text;        textBox4.Text = listView1.Items[ind].SubItems[3].Text;    }    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 修改按钮事件private void button2_Click(object sender, EventArgs e){    // 修改    if (listView1.SelectedItems.Count != 0)    {        // 获取最新选择对象在listview1中的索引        ind = listView1.SelectedIndices[0];        // 修改选中行表格数据        listView1.Items[ind].SubItems[0].Text = textBox1.Text;        listView1.Items[ind].SubItems[1].Text = textBox2.Text;        listView1.Items[ind].SubItems[2].Text = textBox3.Text;        listView1.Items[ind].SubItems[3].Text = textBox4.Text;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>对于<code>删除</code>按钮，当某行被选中时，可被删除</li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">private void button3_Click(object sender, EventArgs e){    // 删除    if(ind != -1)    {        listView1.Items.RemoveAt(ind);    }    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>效果如下</p><ul><li><video src="./video/表格记录软件.mp4"></video></li></ul></li></ul><h4 id="2-12-4-例程2-–-图片上传软件"><a href="#2-12-4-例程2-–-图片上传软件" class="headerlink" title="2.12.4  例程2 – 图片上传软件"></a>2.12.4  例程2 – 图片上传软件</h4><ul><li><p><code>具体代码文件见D:\Program Files\Microsoft Visual Studio\projects\start\listView</code></p></li><li><p>界面搭建如下</p><ul><li><img src="image-20231102191339489-1705156191296-30.png" alt="" style="zoom: 50%;"></li></ul></li><li><p><code>listview</code>要与<code>imagelist</code>关联起来</p></li><li><p>首先是<code>浏览图片</code>按键，按下后打开文件对话框，配置文件格式，当用户选中之后将其绝对路径显示到<code>图片路径</code></p></li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 浏览图片按键事件private void button1_Click(object sender, EventArgs e){    // 过滤图片类型    openFileDialog1.Filter = "图片文件(*.png;*.jpg;*.gif)|*.png;*.jpg;*.gif";    if (openFileDialog1.ShowDialog() == DialogResult.OK)    {        // 将文件绝对路径赋给textBox1        textBox1.Text = openFileDialog1.FileName;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>对于<code>立即上传</code>按键，按下后，首先根据<code>textBox1</code>中的图像路径，将图片按指定方式命名并存到相应文件夹下；同时，在<code>textBox2</code>中自定义名称，之后将该图片展示到<code>listView</code>中</li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 立即上传按钮事件private void button2_Click(object sender, EventArgs e){    // 从路径获取image对象    Image demo = Image.FromFile(textBox1.Text);        // 以时间格式命名    demo.Save(Application.StartupPath + @"\img\" + DateTime.Now.ToString("yyyyMMddHHmmss") + ".jpg");    // 首先的导入imagelist    imageList1.Images.Add(demo);    // 将imagelist与listview进行关联    listView1.LargeImageList = imageList1;    // 从imagelist获取最新的图片，并命名为textBox2，添加到listview    listView1.Items.Add(textBox2.Text, imageList1.Images.Count - 1);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>对于<code>修改名称</code>按键，首先当鼠标选中任意图片后，将其在<code>listview</code>中的名称显示到<code>textBox2</code>中；之后对该名称进行修改，按下<code>修改名称</code>按键后，更改<code>listview</code>中对应图片名称</li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 当前选中图片索引int ind = -1;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 鼠标任意选中图片private void listView1_SelectedIndexChanged(object sender, EventArgs e){    if (listView1.SelectedItems.Count != 0)    {        // 获取最新选择对象在listview1中的索引        ind = listView1.SelectedIndices[0];        // 将当前listview中被点击的图片名称显示到textBox2        textBox2.Text = listView1.Items[ind].Text;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 修改对应名称private void button3_Click(object sender, EventArgs e){    if (ind != -1)    {        listView1.Items[ind].Text = textBox2.Text;    }    else    {        MessageBox.Show("未选中图片");    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>对于<code>删除图片</code>按钮事件</li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">private void button4_Click(object sender, EventArgs e){    if(ind != -1)    {        // 从llistview中删除鼠标选中图片        listView1.Items.RemoveAt(ind);    }    else    {        MessageBox.Show("未选中图片");    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>效果如下</p><ul><li><video src="./video/图片上传软件.mp4"></video></li></ul></li></ul><h3 id="2-13-状态栏及富文本框"><a href="#2-13-状态栏及富文本框" class="headerlink" title="2.13 状态栏及富文本框"></a>2.13 状态栏及富文本框</h3><ul><li><code>menuStrip</code>控件，搭建界面菜单</li><li><code>fontDialog</code>控件，字体对话框</li><li><code>colorDialog</code>控件，颜色对话框</li><li></li></ul><h4 id="2-13-1-状态栏"><a href="#2-13-1-状态栏" class="headerlink" title="2.13.1 状态栏"></a>2.13.1 状态栏</h4><ul><li><code>statusStrip</code>控件</li></ul><h4 id="2-13-2-富文本框"><a href="#2-13-2-富文本框" class="headerlink" title="2.13.2 富文本框"></a>2.13.2 富文本框</h4><ul><li><code>richTextBox</code>控件</li></ul><h4 id="2-13-3-例程-–-个性化记事本"><a href="#2-13-3-例程-–-个性化记事本" class="headerlink" title="2.13.3 例程 – 个性化记事本"></a>2.13.3 例程 – 个性化记事本</h4><ul><li>==有bug，不知道怎么解决！！！==</li></ul><h2 id="三、开发例子-–-B站刘金玉视频总结"><a href="#三、开发例子-–-B站刘金玉视频总结" class="headerlink" title="三、开发例子 – B站刘金玉视频总结"></a>三、开发例子 – B站刘金玉视频总结</h2><h3 id="3-1-简易谷歌浏览器开发"><a href="#3-1-简易谷歌浏览器开发" class="headerlink" title="3.1 简易谷歌浏览器开发"></a>3.1 简易谷歌浏览器开发</h3><h4 id="3-1-1-主要内容"><a href="#3-1-1-主要内容" class="headerlink" title="3.1.1 主要内容"></a>3.1.1 主要内容</h4><ul><li><p><code>WebBrowser</code>控件，默认调用IE浏览器作为内核，但该内核已经久远，会报错</p></li><li><p><code>cefsharp</code>，第三方控件，通过<code>管理NuGet程序包</code>下载，使用Chrome内核</p><ul><li>使用时，需要引入命名空间</li></ul></li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">using CefSharp;using CefSharp.WinForms;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="3-1-2-实现过程"><a href="#3-1-2-实现过程" class="headerlink" title="3.1.2 实现过程"></a>3.1.2 实现过程</h4><ul><li><p>具体代码见<code>D:\Program Files\Microsoft Visual Studio\projects\start\Brower</code></p></li><li><p>搭建界面布局如下</p><ul><li><img src="image-20231109162733234-1705156191296-31.png" alt="" style="zoom: 50%;"></li></ul></li><li><p>首先在外部声明全局变量</p></li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">ChromiumWebBrowser myChrome;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>不拖动<code>CefSharp</code>控件，通过代码调用</li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 通过窗体加载事件配置浏览器private void Form1_Load(object sender, EventArgs e){    // 载入谷歌浏览器默认配置，并初始化内核    Cef.Initialize(new CefSettings());        // 设置浏览器默认打开地址    myChrome = new ChromiumWebBrowser("https://www.bilibili.com");        // 将网页显示到panel中    panel1.Controls.Add(myChrome);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>在<code>textBox1</code>中输入网址后，按回车进行调换</li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 通过textBox按键抬起事件private void textBox1_KeyUp(object sender, KeyEventArgs e){    // 当按下回车    if(e.KeyCode == Keys.Enter)    {        // webBrowser1.Url = new Uri(textBox1.Text);                // 将textBox1中文本转为字符串，传给Chrome进行网页跳转        myChrome.LoadUrl(textBox1.Text.ToString());    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>实现浏览器的前进、后退、刷新</li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 前进private void button1_Click(object sender, EventArgs e){    myChrome.Forward();}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 后退private void button2_Click(object sender, EventArgs e){    myChrome.Back();}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 刷新private void button3_Click(object sender, EventArgs e){    myChrome.Reload();}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 查看源代码    调用时一直转圈，没有显示出来，程序还卡了private void button4_Click(object sender, EventArgs e){    richTextBox1.Text = myChrome.GetSourceAsync().Result;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-2-超市商品分类树"><a href="#3-2-超市商品分类树" class="headerlink" title="3.2 超市商品分类树"></a>3.2 超市商品分类树</h3><h4 id="3-2-1-主要内容"><a href="#3-2-1-主要内容" class="headerlink" title="3.2.1 主要内容"></a>3.2.1 主要内容</h4><ul><li><code>treeView</code>树形控件，根节点，子节点</li></ul><h4 id="3-2-2-实现过程"><a href="#3-2-2-实现过程" class="headerlink" title="3.2.2 实现过程"></a>3.2.2 实现过程</h4><ul><li><p>具体代码见<code>D:\Program Files\Microsoft Visual Studio\projects\start\TreeView</code></p></li><li><p>搭建界面如下</p><ul><li><img src="image-20231109182148300-1705156191296-32.png" alt="" style="zoom: 50%;"></li></ul></li><li><p><code>全部展开</code>功能</p></li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">private void button1_Click(object sender, EventArgs e){    // 全部展开，调用ExpandAll()方法    treeView1.ExpandAll();}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>全部闭合</code>功能</li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">private void button2_Click(object sender, EventArgs e){    // 全部闭合，调用CollapseAll()方法    treeView1.CollapseAll();}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>添加根节点</code>功能</li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">private void button3_Click(object sender, EventArgs e){    // 将textBox中的文本添加到根节点    treeView1.Nodes.Add(textBox1.Text);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>添加至当前分类</code>功能</li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">private void button4_Click(object sender, EventArgs e){    // 在被选中的根节点下添加子节点    treeView1.SelectedNode.Nodes.Add(textBox1.Text);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p><code>右键删除</code></p><ul><li>使用<code>contextMenuStrip</code>控件，添加删除选项，并绑定<code>treeview</code></li></ul></li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">private void 删除选中项ToolStripMenuItem_Click(object sender, EventArgs e){    // 获取当前选中项（根节点或子节点）    TreeNode select = treeView1.SelectedNode;        // 删除该节点（根节点或子节点）    treeView1.Nodes.Remove(select);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>网页链接</code></li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">private void linkLabel1_LinkClicked(object sender, LinkLabelLinkClickedEventArgs e){    System.Diagnostics.Process.Start("http://bcczcs.com");}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-3-红绿灯交通模拟-–-调用线程"><a href="#3-3-红绿灯交通模拟-–-调用线程" class="headerlink" title="3.3 红绿灯交通模拟 – 调用线程"></a>3.3 红绿灯交通模拟 – 调用线程</h3><h4 id="3-3-1-主要内容"><a href="#3-3-1-主要内容" class="headerlink" title="3.3.1 主要内容"></a>3.3.1 主要内容</h4><ul><li><code>backgroundWorker</code>后台线程</li></ul><h4 id="3-3-2-实现过程"><a href="#3-3-2-实现过程" class="headerlink" title="3.3.2 实现过程"></a>3.3.2 实现过程</h4><ul><li><p>具体代码见<code>D:\Program Files\Microsoft Visual Studio\projects\start\Traffic</code></p></li><li><p>搭建界面</p><ul><li><img src="image-20231109194202863-1705156191296-33.png" alt="" style="zoom: 50%;"></li></ul></li><li><p>引入全局变量</p></li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">int count = 10;Graphics g;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>在面板内绘制红绿灯</li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 窗体自带一个onpaint事件用来重绘winform界面// 需要对该事件进行重写，以达到红绿灯显示的连续性，解决灯消失不显示的情况protected override void OnPaint(PaintEventArgs e){    base.OnPaint(e);    // 在面板内绘制实心圆    g = panel1.CreateGraphics();    // g.DrawEllipse(new Pen(Color.Red), 0, 0, 40, 40);    // 创建笔刷    Brush brush = new SolidBrush(Color.Red);        // 绘制红绿灯    g.FillEllipse(brush, 0, 0, 40, 40);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>按下<code>开始</code></li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">private void button1_Click(object sender, EventArgs e){    // 先判断后台线程是否已经被开启，避免多次点击报错    if (!backgroundWorker1.IsBusy)    {        // 开启后台线程        backgroundWorker1.RunWorkerAsync();    }    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 将耗时的复杂的计算或死循环放到后台进行，避免卡顿private void backgroundWorker1_DoWork(object sender, DoWorkEventArgs e){    // 判断count取值    while (true)    {        if (count &lt; 0)        {            break;        }        else if (count &lt;= 7 &amp;&amp; count &gt; 4)        {            Brush brush = new SolidBrush(Color.Green);            g.FillEllipse(brush, 0, 0, 40, 40);        }        else if (count &lt;= 4)        {            Brush brush = new SolidBrush(Color.Yellow);            g.FillEllipse(brush, 0, 0, 40, 40);        }        // 本身后台线程是一个线程，而label2控件是在主线程里创建的，直接使用开线程了，使用Invoke解决        // Invoke会一直网上进行查找，直到找到当前控件所在的线程，并对控件的值进行更新        // new action()内启用一个委托，去解决跨线程        Invoke(new Action(() =&gt;         {            label2.Text = count.ToString();            // 刷新界面，不刷新会卡死            Update();        }));        // 另一种解决方法        /*Invoke(new EventHandler(delegate        {            label2.Text = count.ToString();            // 刷新界面，不刷新会卡死            Update();        }));*/                // 暂停线程1秒        System.Threading.Thread.Sleep(1000);        count--;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>当窗体关闭时，关闭后台进程，避免报错</li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">private void Form1_FormClosing(object sender, FormClosingEventArgs e){    // 当窗体关闭时，同时关闭后台线程，避免报错    backgroundWorker1.CancelAsync();}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-4-屏幕滚动文字"><a href="#3-4-屏幕滚动文字" class="headerlink" title="3.4 屏幕滚动文字"></a>3.4 屏幕滚动文字</h3><h4 id="3-4-1主要内容"><a href="#3-4-1主要内容" class="headerlink" title="3.4.1主要内容"></a>3.4.1主要内容</h4><ul><li>通过使用<code>System.IO</code>命名空间下的<code>StreamWrite</code>类进行文件写入</li><li>使用<code>Fill.ReanAllText()</code>方法读取文件</li></ul><h4 id="3-4-2-实现过程"><a href="#3-4-2-实现过程" class="headerlink" title="3.4.2 实现过程"></a>3.4.2 实现过程</h4><ul><li><p>具体代码见<code>D:\Program Files\Microsoft Visual Studio\projects\start\Screen</code></p></li><li><p>界面搭建如下</p><ul><li><img src="image-20231109203744310-1705156191296-34.png" alt="" style="zoom: 50%;"></li></ul></li><li><p>首先设置从属关系</p></li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">private void Form1_Load(object sender, EventArgs e){    // 将label1设置为label2的父窗体    // 通过将label2的背景色设置为Transparent，跟随label1窗体背景颜色    label2.Parent = label1;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>接着启用<code>timer</code>控件，让<code>label2</code>在<code>label1</code>中动起来</li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">private void timer1_Tick(object sender, EventArgs e){    // 边界判断    if (label2.Left &lt; -label2.Width)    {        label2.Left = label1.Width;    }    label2.Left -= 10;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>对于<code>预览</code>键，点击后，将<code>textBox</code>中输入的文本显示到<code>label2</code>上</li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">private void button1_Click(object sender, EventArgs e){    label2.Text = textBox1.Text;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li>对于<code>写入文件保存</code></li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">private void button2_Click(object sender, EventArgs e){    // 通过System.IO中的streamwrite类来写入文件    // 构造函数参数传入的是文件保存名称，默认路径在debug文件下    // 该构造函数还有第二个参数，bool，是否追加    StreamWriter sw = new StreamWriter("sw.txt");    // 写入文件    sw.Write(textBox1.Text);    // 写入完成要进行关闭，关闭后才能看到保存的文本    sw.Close();}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>对于<code>checkBox 从保存文件读入文本</code>，并将文本内容写入<code>label2</code></li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">private void checkBox1_CheckedChanged(object sender, EventArgs e){    if(checkBox1.Checked)    {        label2.Text = File.ReadAllText("sw.txt");    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-5-掩码规则验证及信息提示"><a href="#3-5-掩码规则验证及信息提示" class="headerlink" title="3.5 掩码规则验证及信息提示"></a>3.5 掩码规则验证及信息提示</h3><h4 id="3-5-1-主要内容"><a href="#3-5-1-主要内容" class="headerlink" title="3.5.1 主要内容"></a>3.5.1 主要内容</h4><ul><li><code>maskedTextBox</code>掩码控件<ul><li><code>mask</code>属性设置掩码格式</li><li><code>AsciOnly</code>属性设置是否开启格式验证，若不合格输入不了</li></ul></li><li><code>toolTip</code>提示控件</li></ul><h4 id="3-5-2-实现过程"><a href="#3-5-2-实现过程" class="headerlink" title="3.5.2 实现过程"></a>3.5.2 实现过程</h4><ul><li><p>具体代码见<code>D:\Program Files\Microsoft Visual Studio\projects\start\Mask</code></p></li><li><p>界面搭建如下</p><ul><li><img src="image-20231109221329348-1705156191297-35.png" alt="" style="zoom:50%;"></li></ul></li><li><p>按键切换掩码格式，采用同类型按钮事件</p></li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 同类型按钮事件// 首先要有同类型控件// 将同类型控件选择相同的事件// 通过sender这个object，强制转为指定类型的控件// 通过转化过来的控件，直接调用某一属性去进行区分private void radioButton1_CheckedChanged(object sender, EventArgs e){    RadioButton rdbt = (RadioButton)sender;    if(rdbt.Text == "身份号码")    {        maskedTextBox1.Mask = "000000-00000000-000A";    }    else if(rdbt.Text == "电话号码")    {        maskedTextBox1.Mask = "000-0000-0000";    }    else if (rdbt.Text == "日期时间")    {        maskedTextBox1.Mask = "0000年90月90日 90时00分";    }    else if (rdbt.Text == "自动转为大写")    {        // 没有该类型掩码        // 自定义掩码：0表示0-9的数字；A代表字母数字都可以；        // &gt;&lt;表示转大小写；L只表示字母         // 指定5位字母        maskedTextBox1.Mask = "&gt;LLLLL";    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>输入提示</li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">private void maskedTextBox1_MaskInputRejected(object sender, MaskInputRejectedEventArgs e){    // 当输入不符合规则时提醒     // 提醒输入将超设置长度    if (maskedTextBox1.MaskFull)    {        // 设置提示标题        toolTip1.ToolTipTitle = "啊giao提醒您：";         // 设置提示内容，在相应控件位置显示        // 鼠标必须在控件位置，否则可能失效        toolTip1.Show("输入完成了", maskedTextBox1);    }     // 该条件与前一个情况一样，做例子    else if(e.Position == maskedTextBox1.Mask.Length)    {        toolTip1.Show("已在最后一个位置", maskedTextBox1);    }     else    {        toolTip1.Show("输入不合法", maskedTextBox1);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="四、一些有意思的操作"><a href="#四、一些有意思的操作" class="headerlink" title="四、一些有意思的操作"></a>四、一些有意思的操作</h2><h3 id="4-1-文件对话框"><a href="#4-1-文件对话框" class="headerlink" title="4.1 文件对话框"></a>4.1 文件对话框</h3><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">OpenFileDialog ofd = new OpenFileDialog();ofd.Title = "请选择音乐文件";ofd.InitialDirectory = @"C:\Users\echo\Desktop\Music";ofd.Multiselect = true;ofd.Filter = "音乐文件|*.wav|所有文件|*.*";ofd.ShowDialog();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-2-音乐播放"><a href="#4-2-音乐播放" class="headerlink" title="4.2 音乐播放"></a>4.2 音乐播放</h3><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">SoundPlayer sp = new SoundPlayer();sp.SoundLocation = "xxx";sp.Play();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="五、VS快捷键"><a href="#五、VS快捷键" class="headerlink" title="五、VS快捷键"></a>五、VS快捷键</h2><ul><li><code>Ctrl+鼠标左键点击函数名</code>：跳转该函数具体定义</li><li><code>Ctrl+}</code>：切换光标在代码块标识符<code>{}</code>的位置</li></ul><h2 id="六、TCP-IP通信"><a href="#六、TCP-IP通信" class="headerlink" title="六、TCP/IP通信"></a>六、TCP/IP通信</h2><ul><li><p>上位机是客户端，下位机是服务器，客户端发送命令，服务端做出响应</p></li><li><p>通过<code>TCP</code>传送接收数据时，必须先使用协议和网络地址信息初始化套接字，然后才能进行通信</p></li><li><p><code>TCP/IP</code>使用<strong>一个网络地址和一个服务端口号</strong>来标识唯一设备</p><ul><li>网络地址标识特定的网络目标</li><li>端口号标识该设备要连接的特定服务</li><li>网络地址和服务端口的组合称为<strong>终结点</strong><ul><li>终结点在<code>.NET</code>中由<code>EndPoint</code>类表示</li><li>对于<code>IP</code>地址类型，类为<code>IPEndPoint</code></li></ul></li></ul></li><li><p>使用<code>System.Net.Sockets</code>时，将网络终结点表示为<code>IPEndPoint</code>对象</p><ul><li><code>IPEndPoint</code>使用<code>IPAddress</code>及其端口号构造实例</li><li>在使用<code>Socket</code>发起对话前，在应用和远程目标之间创建数据通道</li></ul></li></ul><h3 id="6-1-进程"><a href="#6-1-进程" class="headerlink" title="6.1 进程"></a>6.1 进程</h3><ul><li><p>进程是操作系统中的一个<strong>执行实例</strong></p></li><li><p>进程是程序的一次执行过程，是一个<strong>程序</strong>与其<strong>关联数据</strong>以及<strong>系统资源</strong>的总称</p></li><li><p>它是计算机系统进行资源分配和调度的基本单位，可以看作是<strong>程序的运行实体</strong></p></li><li><p>打开软件</p></li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 打开edge浏览器，并跳转相应网页Process.Start("msedge","https://www.baidu.com")// 打开微信Process.Start("weixin://")<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>打开文件</li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">ProcessStartInfo psi = new ProcessStartInfo("文件路径");Pocess p = new Process();p.StartInfo = psi;p.Start();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="6-2-线程"><a href="#6-2-线程" class="headerlink" title="6.2 线程"></a>6.2 线程</h3><ul><li>线程是进程内的一个独立执行流，是操作<strong>系统调度的基本单位</strong></li><li><strong>一个进程可以包含多个线程</strong>，它们共享进程的资源，但拥有各自的执行路径和局部变量</li><li>线程是轻量级的执行单元，相比于进程，线程的<strong>创建、销毁和切换成本更低</strong></li><li>程序<strong>任何动作的响应</strong>都是由线程完成的</li></ul><h4 id="6-2-1-主要函数"><a href="#6-2-1-主要函数" class="headerlink" title="6.2.1 主要函数"></a>6.2.1 主要函数</h4><ul><li>线程主要函数分别是<code>Start()</code>和<code>Abort()</code><ul><li><code>Start()</code>：告诉cpu线程已经准好了，可以随时被执行，但是具体执行时间由cpu决定</li><li><code>Abort()</code>：终止线程</li></ul></li><li>其余方法<ul><li><code>Thread.Sleep(1)</code>：静态方法，使线程停止一段时间</li></ul></li></ul><h4 id="6-2-2-关于线程的一些问题"><a href="#6-2-2-关于线程的一些问题" class="headerlink" title="6.2.2 关于线程的一些问题"></a>6.2.2 关于线程的一些问题</h4><ul><li><p>进程与线程的关系？</p><ul><li>一个进程包含多个线程</li></ul></li><li><p>线程分类</p><ul><li>前台线程和后台线程，我们使用<strong>后台线程</strong></li></ul></li><li><p>==为什么要用多线程？==</p><ul><li><p>因为单线程容易造成<strong>程序假死</strong></p></li><li><p>如，Form窗体中只有一个button1</p></li></ul></li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 按下button1后，调用test()// 此时主线程去控制台执行Console.WriteLine()了// 若test()没有执行完，Form窗体会卡死，无法拖动或执行其他操作private void button1_Click(object sender, EventArgs e){    test();}public void test(){    for(int i = 0; i&lt;1000000; i++)    {        Console.WriteLine(i);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>通过==线程调用函数==的一些注意事项</p><ul><li>无参函数</li></ul></li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 通过线程调用无参函数private void button1_Click(object sender, EventArgs e){    Thread th = new Thread(Test);        // 开启后台进程，其会在前台进程结束后 自动终止，不会等待后台进程执行完毕    th.IsBackground = true;    th.Start();}public void test(){    for(int i = 0; i&lt;1000000; i++)    {        Console.WriteLine(i);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>有参函数</li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 对于有参函数// 形参的类型必须是 Object // 线程调用传参，通过对 Start() 写入实参进行传递private void button1_Click(object sender, EventArgs e){    Thread th = new Thread(Test);    th.IsBackground = true;    th.Start("123");}public void test(object s){    string ss = string(s)    for(int i = 0; i&lt;1000000; i++)    {        Console.WriteLine(i);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>跨线程调用控件</p><ul><li>要想跨线程调用控件，可以通过<strong>取消程序的跨线程检查</strong>实现</li></ul></li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">Control.CheckForIllegalCrossThreadCalls = false;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>3个label，1个button</li></ul><img src="image-20231211201441672-1705156191297-36.png" alt="" style="zoom:33%;"><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">bool b = false;private void Form1_Load(object sender, EventArgs e){    // 取消跨线程检查，实现控件的跨线程调用    Control.CheckForIllegalCrossThreadCalls = false;}private void button1_Click(object sender, EventArgs e){    if(b == false)    {        b = true;        button1.Text = "停止";        Thread th = new Thread(PlayGame);        th.IsBackground = true;        th.Start();    }    else    {        b = false;        button1.Text = "开始";    }}private void PlayGame(){    Random r = new Random();    while (b)    {        // 若没有取消跨线程检查，此处会报错        label1.Text = r.Next(0, 9).ToString();        label2.Text = r.Next(0, 9).ToString();        label3.Text = r.Next(0, 9).ToString();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="6-2-3-多线程"><a href="#6-2-3-多线程" class="headerlink" title="6.2.3 多线程"></a>6.2.3 多线程</h4><ul><li>多个执行流同时运行</li><li>实际还是单线程，但对CPU进行了时间切片，在每个时间片内执行一个线程</li><li>如何实现多线程？<ul><li>基于委托异步实现</li><li><code>Thread</code></li><li><code>ThreadPool</code></li><li><code>Task</code></li><li><code>TaskFactory</code></li><li><code>Parallel</code>并行编程</li></ul></li></ul><h5 id="6-2-3-1-基于委托的异步编程"><a href="#6-2-3-1-基于委托的异步编程" class="headerlink" title="6.2.3.1 基于委托的异步编程"></a>6.2.3.1 基于委托的异步编程</h5><ul><li><p>异步编程是建立在<strong>委托</strong>的基础上</p></li><li><p>异步调用的每个方法，都是在<strong>独立的进程</strong>中执行的</p></li><li><p>异步编程是<strong>多线程的一种</strong>，可以说是简化的多线程</p></li><li><p>什么时候使用异步？</p><ul><li>比较适合在后台<strong>耗费时间较长，但任务简单</strong>且各任务间相互独立的情况</li></ul></li><li><p>如果后台要求访问共享资源，并且要按照某种顺序执行，此时异步不适合，应该采用其他多线程去完成</p></li><li><p><code>D:\Program Files\Microsoft Visual Studio\projects\异步-多线程\多线程\Study1</code></p></li></ul><h6 id="6-2-3-1-1-示例"><a href="#6-2-3-1-1-示例" class="headerlink" title="6.2.3.1.1 示例"></a>6.2.3.1.1 示例</h6><ul><li>先声明一个<code>random</code>对象</li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 后续模拟线程耗时// 多线程环境或需要长期保持随机数序列不变的情况下，通常建议将其声明为 staticprivate static Random random = new Random();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li>基于<code>Func&lt;&gt;</code>定义匿名委托</li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 基于委托求一个数的平方// 该委托输入参数为 num，输出结果为 num*numprivate Func&lt;int, int&gt; Operation = (num) =&gt;{    // 模拟耗时，使当前进程暂停    Thread.Sleep(random.Next(5) * 1000);    return num * num;};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>定义回调方法<code>AutoCallBack()</code></li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 回调函数// 通过 IAsyncResult.AsyncState 可获取传递给异步操作的标识参数// 通过 Operation.EndInvoke() 获取异步操作的结果private void AutoCallBack(IAsyncResult result){    int res = Operation.EndInvoke(result);    Console.WriteLine($"第{result.AsyncState}个计算结果是{res}");}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>启动多线程</li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">private void btnExec_Click(object sender, EventArgs e){    for(int i =1; i &lt; 11; i++)    {        // 异步        // 通过循环将 10 个任务同时发布出去        // 各自执行，互不影响        // 参数中的回调函数，是当该异步任务执行完成后，需要自动调用的方法        // 启动异步任务，每个任务会执行 Operation 委托，并传入参数 i*10        // Operation 委托执行完成后，调用 AutoCallBack 回调方法，并传入标识参数 i        Operation.BeginInvoke(i * 10, AutoCallBack, i);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h6 id="6-2-3-1-2-一些问题"><a href="#6-2-3-1-2-一些问题" class="headerlink" title="6.2.3.1.2 一些问题"></a>6.2.3.1.2 一些问题</h6><ul><li><code>Operation.BeginInvoke(i*10,AutoCallBack,i);</code>中的标识参数<code>i</code>有什么用？<ul><li>将不同的 <code>i</code> 传递给异步操作，<strong>标识线程</strong>，以便<strong>在异步操作完成后</strong>能够在回调函数中<strong>识别是哪个线程完成了</strong></li></ul></li><li><code>int res = Operation.EndInvoke(result);</code>怎么理解？<ul><li><code>result</code>是传入的标识参数<code>i</code>，<code>EndInvoke()</code>通过使用该标识去获取对应线程的运行结果</li></ul></li></ul><h5 id="6-2-3-2-基于Thread多线程"><a href="#6-2-3-2-基于Thread多线程" class="headerlink" title="6.2.3.2 基于Thread多线程"></a>6.2.3.2 基于Thread多线程</h5><ul><li><code>D:\Program Files\Microsoft Visual Studio\projects\异步-多线程\多线程\Threads</code></li></ul><h6 id="6-2-3-2-1-跨线程调用控件"><a href="#6-2-3-2-1-跨线程调用控件" class="headerlink" title="6.2.3.2.1 跨线程调用控件"></a>6.2.3.2.1 跨线程调用控件</h6><ul><li><p>前面记<code>Thread</code>，此处新增==跨线程调用控件==的方法</p><ul><li><p><code>Control.CheckForIllegalCrossThreadCalls = false;</code>取消跨线程检测，尽量不用</p></li><li><p>主要代码</p></li></ul></li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// Control.Invoke() 实现跨线程调用// Control.InvokeRequired 该属性在 Control 不是UI线程时为 true；反之，为 falseif (this.lalResult1.InvokeRequired)    {        this.lalResult1.Invoke(            new Action&lt;string&gt;(s =&gt; { this.lalResult1.Text = s; }),            num.ToString() );    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>示例代码</li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">private void btnExecute1_Click(object sender, EventArgs e){    // 任务一    int num = 0;    Thread thread = new Thread(() =&gt;    {        for(int i = 1; i &lt; 20; i++)        {            num += i;                        // 跨线程调用控件            if (this.lalResult1.InvokeRequired)            {                this.lalResult1.Invoke(                    new Action&lt;string&gt;(s =&gt; { this.lalResult1.Text = s; }),                    num.ToString() );            }            Thread.Sleep(300);        }    });    thread.IsBackground = true; // 设置为后台线程    thread.Start();    // 关于前台线程和后台线程：    // 一个程序如果有前台线程，必须在所有的前台线程都结束后，才能退出    // 一个程序如果开启的都是后台线程，则程序关闭后，后台线程就会自动全部退出}private void btnExecute2_Click(object sender, EventArgs e){        Thread th = new Thread(() =&gt;    {        for(int i = 1;i &lt; 20; i++)        {            if (this.lalResult2.InvokeRequired)            {                this.lalResult2.Invoke(                    new Action&lt;string&gt;(s =&gt; { this.lalResult2.Text = s; }),                    i.ToString());            }            Thread.Sleep(i*100);        }    });    th.IsBackground = true;    th.Start();}private void btnRead_Click(object sender, EventArgs e){    Thread th = new Thread(() =&gt;    {        if (this.txtV.InvokeRequired)        {            this.txtV.Invoke(new Action&lt;string&gt;(s =&gt; { this.lalV.Text = s; }),            txtV.Text);            //Thread.Sleep(100);        }    });    th.IsBackground = true;    th.Start();}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h6 id="6-2-3-2-2-跨控件访问数据库"><a href="#6-2-3-2-2-跨控件访问数据库" class="headerlink" title="6.2.3.2.2 跨控件访问数据库"></a>6.2.3.2.2 跨控件访问数据库</h6><ul><li><code>D:\Program Files\Microsoft Visual Studio\projects\异步-多线程\多线程\ThreadDataBase</code></li></ul><p>先把数据库学了来！！！！！</p><h3 id="6-3-Socket"><a href="#6-3-Socket" class="headerlink" title="6.3 Socket"></a>6.3 Socket</h3><h4 id="6-3-1-关于Socket的一些问题"><a href="#6-3-1-关于Socket的一些问题" class="headerlink" title="6.3.1 关于Socket的一些问题"></a>6.3.1 关于Socket的一些问题</h4><ul><li><p>怎么理解Socket</p><ul><li>人通过 <strong>电话</strong> 进行通信，==程序通过 Socket 来通==，套接字就是程序间的电话机</li><li>Socket是进程通信机制，也称作“套接字”，用于<strong>描述IP地址和端口</strong>，是一个通信链的句柄，是两个程序间通信用的</li><li>Socket类型<ul><li><strong>流式Socket</strong>（STREAM）：一种面向连接的Socket，针对<strong>TCP</strong>服务应用，安全，但是效率低</li><li><strong>数据报式Socket</strong>（DATAGRAM）：一种无连接Socket，对应于<strong>UDP</strong>服务应用，不安全（丢失，顺序紊乱，在接收端要分析重排及要求重发），但效率高</li></ul></li><li>以电话网为例，电话的通话双方相当于通信的2个程序，<strong>电话号码就是IP地址</strong>。任何用户在通话前，首先要占有<strong>一部电话机，相当于申请一个Socket</strong>；同时要知道对方的号码，对方也得有一部电话，即一个Socket。然后向对方<strong>拨号呼叫，相当于发出连接请求</strong>。对方假如在场并空闲，拿起电话话筒，双方就可以进行正式<strong>通话，相当于连接成功</strong>。双方通话的过程，是一方向电话机发出信号，和对方从电话机接收信号的过程，相当于<strong>向Socket发送数据和从Socket接收数据</strong>。通话结束后，一方挂起电话机，相当于<strong>关闭Socket，撤销连接</strong>。</li><li>关于端口，客户端与服务器使用<strong>IP地址建立联系</strong>，而客户端只需要与服务器中的某一个程序进行连接，在服务器中使用<strong>端口号标记各程序</strong>。</li></ul></li><li><p>Socket一般==应用模式==（服务端和客户端）</p><ul><li>服务端 welcoming Socket 监听端口，检测客户端的连接请求</li><li>客户端 client Socket 连接服务端指定端口，并用于接收和发送 服务端消息</li><li>服务端 welcoming Socket 监听到客户端连接，创建 connection Socket，实现与客户端的通信</li><li>以男生去女生宿舍找女同学为例，男生要想找到女生宿舍得某一个的女生，首先要找到宿管大妈，告诉大妈找人的原因（如生病了来看望女同学），宿管大妈再去找到并通知对应的女生，进而建立男生与女生之间的联系。过程中，男生相当于客户端，宿管阿姨扮演负责监听的Socket，女生相当于服务端里的应用程序，当男生发出请求，宿管阿姨就创建一个负责通信的Socket，用于男生和女生通信</li></ul></li><li><p>Socket中的==端口==</p><ul><li>Internet上有很多主机，每台主机同时运行了多个服务软件，提供多种服务，每种服务都打开一个Socket，并绑定到一个端口上，不同的端口对应于不同的服务。例如，http使用80端口，ftp使用21端口，smtp使用25端口</li></ul></li><li><p>什么是==协议==</p><ul><li><p>我和ikun打电话，中文是规定好的语言，电脑与电脑进行<strong>联系就需要协议</strong></p></li><li><p><strong>TCP</strong>协议，有<strong>三次握手</strong>，要求必须要有服务器，请求必须由客户端发起，因为服务器不知道客户端在哪。三次握手的过程：首先客户端给服务器发送消息“你有空吗？”，服务器收到客户端的消息后，回复“我有空”，最后客户端再给服务器发送消息“我知道你有空了”。<strong>只有完成三次握手连接上后，客户端才跟服务器相收发数据，否则不会进行数据的沟通</strong>。所以TCP协议<strong>安全、稳定、但是效率低</strong>（需要花时间去握手）</p></li><li><p><img src="/2024/01/13/shang-wei-ji/image-20240206173133057.png"></p></li><li><p><strong>UDP</strong>协议，<strong>快速，效率高，但是不稳定，容易发生数据丢失</strong>，客户端不管服务器是否有空，直接把消息发送到服务器，当服务器繁忙的时候不能即使对接收到的数据进行处理，进而造成数据丢失</p></li><li><p>两种协议各有好坏，视频传输使用的就是UDP协议</p></li></ul></li></ul><h4 id="6-3-2-Socket通信流程"><a href="#6-3-2-Socket通信流程" class="headerlink" title="6.3.2 Socket通信流程"></a>6.3.2 Socket通信流程</h4><ul><li><p>Socket通信流程图</p><ul><li><p><img src="/2024/01/13/shang-wei-ji/image-20240206173230194.png"></p></li><li><p>服务端<code>Bind()</code>：负责绑定监听端口；<code>Listen()</code>：设置监听队列：<code>Accept()</code>：放循环中，等待客户连接</p></li></ul></li></ul><h5 id="6-3-2-1-服务端"><a href="#6-3-2-1-服务端" class="headerlink" title="6.3.2.1 服务端"></a>6.3.2.1 服务端</h5><ul><li><strong>创建</strong>一个负责<strong>监听的Socket</strong></li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 创建监Socket，初始化地址簇、套接字类型、协议类型Socket socketWatch = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtoolType.Tcp);// 让 socketWatch 监听所有网络接口的连接请求IPAdress ip = IPAdress.Any;// 创建终结点IPEndPoint point = new IPEndPoint(ip, Convert.ToInt32(txtPort.Text));// socketWatch 绑定指定的终结点socketWatch.Bind(point);// 设置并发连接数，监听队列长度socketWatch.Listen(10);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>开启线程<strong>等待连接</strong>，连接成功后，<strong>创建通信socket</strong></li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 调用的自定义的 Listen 函数Thread th = new Thread(Listen);th.IsBackground = true;th.start(scoketWatch);// 将 socketSend 设置为全局变量Socket socketSend;private void Listen(object o){    socket socketWatch = o as socket;    // socketWatch 循环监听连接请求    while(true)    {        // Accept()是一个 阻塞 方法        // 有客户端请求连接时，返回一个新的 Socket，表示与客户端建立了连接        // 创建一个用于通信的 Socket        socketSend = socketWatch.Accept();                        // 连接成功后，可进行一些内部处理                // 如开启线程，接收客户端数据        Thread th = new Thread(Receive);        th.IsBackground = true;        th.Start(socketSend);            }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>当发生跨线程调用控件时，可在窗体加载时 <strong>关闭跨线程检查</strong></li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">Controls.CheckForIllegalCrossThreadCalls = false;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>服务器<strong>接收数据</strong></li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">private void Receive(object o){socket socketSend = o as socket;    try    {        // 循环接收数据，知道把数据接收完        while(true)        {            byte buffer = new byte[1024 * 1024 * 3];                        // 当 buffer 长度小于待接收的数据时，截取满buffer长度，就进行阶段，等待继续下次接收            int r = socketSend.Receive(buffer);                        // 当数据接收完            if(r == 0)            {                break;            }                        // 将 buffer 解码为字符串            // string str = Encoding.UTF8.GetString(buffer);        }        catch        {                    }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>服务器<strong>发送数据</strong></li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 以按键点击发送数据为例private void btnSend_Click(object sender, EvenArgs e){    string str = txtSend.Text;    byte[] buffer = Encoding.UTF8.GetBytes(str);        // 此处 socketSend 为前面创建的全局变量    socketSend.Send(buffer);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="6-3-2-2-客户端"><a href="#6-3-2-2-客户端" class="headerlink" title="6.3.2.2 客户端"></a>6.3.2.2 客户端</h5><ul><li>创建<strong>客户端Socket</strong>，并连接指定终结点</li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 做全局变量Socket socketSend;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">socketSend = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);IPAdress ip = IPAdress.Parse(txtServer.Text);IPEndPoint point = new IPEndPoint(ip, Convert.ToInt32(txtPort.Text));socketSend.Connect(point);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>客户端<strong>接收消息</strong></li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">private void Receive(){    while(true)    {        byte[] buffer = new byte[1024 * 1024 * 3];        int r = socketSend.Receive(buffer);        if(r == 0)        {            break;        }                string str = Encoding.UTF8.GetString(buffer);            }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>客户端<strong>发送消息</strong></li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 同样以按键点击发送消息private btnSend_Click(object sender, EventArgs e){    string str = txtMsg.Text.Trim();    byte[] buffer = Encoding.UTF8.GetBytes(str);    socketSend.Send(buffer);    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="6-4-3-基于Socket的聊天程序"><a href="#6-4-3-基于Socket的聊天程序" class="headerlink" title="6.4.3 基于Socket的聊天程序"></a>6.4.3 基于Socket的聊天程序</h4><h5 id="6-4-3-1-实现功能"><a href="#6-4-3-1-实现功能" class="headerlink" title="6.4.3.1 实现功能"></a>6.4.3.1 实现功能</h5><ul><li>传送文件</li><li>判断接收数据是文件还是文字</li><li>设计协议<ul><li>在传递的字节数组前加上一个字节作为标识：0表示文字，1表示文件</li><li>文字：0 + 字节数组</li><li>文件：1 + 文件二进制信息</li></ul></li></ul><h5 id="6-4-3-2-服务器"><a href="#6-4-3-2-服务器" class="headerlink" title="6.4.3.2 服务器"></a>6.4.3.2 服务器</h5><ul><li>创建<code>socketWatch</code><strong>监听连接</strong></li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">private void btnStart_Click(object sender, EventArgs e){    try    {        Socket socketWatch = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);        IPAddress ip = IPAddress.Any;        int port = Convert.ToInt32(txtPort.Text);        IPEndPoint point = new IPEndPoint(ip, port);        socketWatch.Bind(point);        showMsg("开始监听");        socketWatch.Listen(10);        Thread th = new Thread(Accept);        th.IsBackground = true;        th.Start(socketWatch);    }    catch    {    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><strong>接收客户端连接</strong>，并开启<code>Receive</code>线程</li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">Socket socketServer = null;private void Accept(object socketWatchObj){    Socket socketWatch = (Socket)socketWatchObj;    while (true)    {        try        {            socketServer = socketWatch.Accept();            showMsg(socketServer.RemoteEndPoint.ToString() + "  连接成功");            Thread th = new Thread(Receive);            th.IsBackground = true;            th.Start();//(socketServer);        }        catch        {        }            }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><strong>打印信息</strong></li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">private void showMsg(string str){    txtLog.AppendText(str+"\r\n");}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li><strong>接收数据</strong></li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">private void Receive()//(object socketServerObj){    //Socket socketServer = socketServerObj as Socket;    while (true)    {        try        {            byte[] buffer = new byte[1024 * 1024 * 3];            int num = socketServer.Receive(buffer);            if (num == 0)            {                showMsg("与客户端连接中断");                break;            }            string str = Encoding.UTF8.GetString(buffer, 0, num);            showMsg(socketServer.RemoteEndPoint.ToString() + "  " + str);        }        catch        {        }    }    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>发送<strong>文本数据</strong></li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">private void btnSend_Click(object sender, EventArgs e){    string str = txtMsg.Text;    byte[] buffer = Encoding.UTF8.GetBytes(str);    // 数组长度不可变    // 使用 List 来增加协议标识，并转为 数组    List&lt;byte&gt; list = new List&lt;byte&gt;();    list.Add(0);    list.AddRange(buffer);    byte[] newBuffer = list.ToArray();    socketServer.Send(newBuffer);    txtMsg.Clear();}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>选择并<strong>发送文件</strong></li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">private void btnSelect_Click(object sender, EventArgs e){    OpenFileDialog ofd = new OpenFileDialog();    ofd.InitialDirectory = @"";    ofd.Title = "请选择要发送的文件";    ofd.Filter = "所有文件|*.*";    ofd.ShowDialog();    txtPath.Text = ofd.FileName;}private void btnSendFile_Click(object sender, EventArgs e){    //  获取发送文件的路径    string path = txtPath.Text;    using (FileStream fsRead = new FileStream(path, FileMode.Open, FileAccess.Read))    {        byte[] buffer = new byte[1024 * 1024 * 5];        int r = fsRead.Read(buffer, 0, buffer.Length);        List&lt;byte&gt; list = new List&lt;byte&gt;();        list.Add(1);        list.AddRange(buffer);        byte[] newBuffer = list.ToArray();                socketServer.Send(newBuffer,0,r+1,SocketFlags.None);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="6-4-3-3-客户端"><a href="#6-4-3-3-客户端" class="headerlink" title="6.4.3.3 客户端"></a>6.4.3.3 客户端</h5><ul><li><strong>连接服务器</strong></li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">private void btnConnect_Click(object sender, EventArgs e){    try    {        socketClient = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);        IPEndPoint point = new IPEndPoint(IPAddress.Parse(txtIP.Text), Convert.ToInt32(txtPort.Text));        socketClient.Connect(point);        showMsg(socketClient.RemoteEndPoint.ToString() + "  连接成功");        Thread th = new Thread(Receive);        th.IsBackground = true;        th.Start();    }    catch    {    }    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><strong>打印信息</strong></li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">private void showMsg(string str){    txtLog.AppendText(str + "\r\n");}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li><strong>接收消息</strong></li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">private void Receive()//(object socketClientObj){    // Socket socketClient = socketClientObj as Socket;    while (true)    {        try        {            byte[] buffer = new byte[1024 * 1024 * 3];            int num = socketClient.Receive(buffer);            if (num == 0)            {                showMsg("断开连接");                break;            }            // 根据标识执行对应动作            // 文字消息            if (buffer[0] == 0)            {                string str = Encoding.UTF8.GetString(buffer, 1, num-1);                showMsg(socketClient.RemoteEndPoint.ToString() + "  " + str);            }            else if (buffer[0] == 1)            {                SaveFileDialog sfd = new SaveFileDialog();                sfd.InitialDirectory = @"";                sfd.Title = "请选择要保存的文件";                sfd.Filter = "所有文件|*.*";                sfd.ShowDialog(this);                string path = sfd.FileName;                using(FileStream fsWrite = new FileStream(path, FileMode.OpenOrCreate, FileAccess.Write))                {                    fsWrite.Write(buffer, 1, num-1);                }                MessageBox.Show("保存成功");            }        }        catch        {        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><strong>发送消息</strong></li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">private void btnSend_Click(object sender, EventArgs e){    string str = txtMsg.Text;    byte[] buffer = Encoding.UTF8.GetBytes(str);    socketClient.Send(buffer);    txtMsg.Clear();}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="6-4-委托"><a href="#6-4-委托" class="headerlink" title="6.4 委托"></a>6.4 委托</h3><h4 id="6-4-1-关于委托的一些问题"><a href="#6-4-1-关于委托的一些问题" class="headerlink" title="6.4.1 关于委托的一些问题"></a>6.4.1 关于委托的一些问题</h4><ul><li>为什么要使用委托<ul><li>为了将一个方法作为参数传递给另一个方法，此时传递的的方法应是委托类型</li></ul></li><li>==注意==<ul><li>委托所指向的函数必须与委托具有相同的签名</li><li>委托声明放在<code>class</code>外，<code>namespace</code>内</li></ul></li></ul><h4 id="6-4-2-委托的使用"><a href="#6-4-2-委托的使用" class="headerlink" title="6.4.2 委托的使用"></a>6.4.2 委托的使用</h4><h5 id="6-4-2-1-基本使用"><a href="#6-4-2-1-基本使用" class="headerlink" title="6.4.2.1 基本使用"></a>6.4.2.1 基本使用</h5><ul><li>有两个<strong>签名一致</strong>的函数</li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">public static void SayHiChinese(string name){    Console.WriteLine("早上好" + name);}public static void SayHiEnglish(string name){    Console.WriteLine("Nice to meet you " + name);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><strong>声明委托</strong>，委托需要与函数签名一致</li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">public delegate void DelSayHi(string name);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><p><strong>使用委托</strong></p><ul><li><strong>new</strong> 声明</li></ul></li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">DelSayHi del = new DelSayHi(SayHichinese);del("张山");<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li><strong>赋值</strong></li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 直接赋值DelSayHi del = SayHiChinese;del("张山");<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 传参赋值Test("张山", SayHiChinese);public static void Test(string name, DelSayHi del){    del(name);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="6-4-2-2-匿名函数"><a href="#6-4-2-2-匿名函数" class="headerlink" title="6.4.2.2 匿名函数"></a>6.4.2.2 匿名函数</h5><ul><li><p>当某个方法只需要执行一次的时候，可用将方法写成匿名函数</p></li><li><p>以前文代码为例</p></li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 当只需要中文的问好时// 可删掉 SayHiChines()，减少代码量DelSayHi del = delegate(string name){    Console.WriteLine("早上好"+name);};// 前几行代码也可以写为 lambda表达式// 参数指向方法体DelSayHi del = (string name) =&gt; {Console.WriteLine("早上好"+name);};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="6-4-2-3-泛型委托"><a href="#6-4-2-3-泛型委托" class="headerlink" title="6.4.2.3 泛型委托"></a>6.4.2.3 泛型委托</h5><ul><li><p>求任意数组的最大值（int[] 为数值最大，string[] 为长度最长）</p></li><li><p><strong>初始代码</strong></p></li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 返回 int 最大值public static int GetMax(int[] nums){    int max = nums[0];    for(int i = 0; i &lt; nums.Length; i++)    {        if(max &lt; nums[i])        {            max = nums[i];        }    }    return max;}// 返回 string 最长字符串// 函数重载public static string GetMax(string[] names){    string max = names[0];    for(int i = 0; i &lt; names.Length; i++)    {        if(max.Length &lt; names[i].Length)        {            max = names[i];        }    }    return max;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>为减少代码量，将两个方法使用**<code>object</code>替换**一个方法，并使用委托作为<code>if</code>的判断条件</li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 声明一个委托去处理判断条件的真假// 委托的返回值为 int// 参数与 GetMax 一致，使用 objectpublic delegate int DelCompare(object o1, object o2);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">public static object GetMax(object[] nums, DelCompare del){    object max = nums[0];    for(int i = 0; i &lt; nums.Length; i++)    {        // 传一个比较方法        if(del(max, nums[i]) &lt; 0)        {            max = nums[i];        }    }    return max;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 根据委托签名书写调用的比较函数// int类public static int Compare1(object o1, object o2){    int n1 = (int)o1;    int n2 = (int)o2;    return n1 - n2;}// string类public static string Compare2(object o1, object o2){string s1 = (string)o1;    string s2 = (string)o2;    return s1.Length - s2.Length;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// Main方法public static void Main(string[] args){    // 比较 int    object o1 = {1, 2, 3, 4, 5};    object result1 = GetMax(o1, Compare1);    Console.WriteLine(result1);        // 比较 string    object o2 = {"qwhdaj", "gakddnajdhowiud"};    object result2 = GetMax(o2, Compare2);    Console.WriteLine(result2);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>使用<code>object</code>类型涉及 装箱拆箱 ，继续使用 <strong>泛型</strong> 减少代码量</li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 使用泛型委托public static int DelCompare&lt;T&gt;(T o1, T o2);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 修改前文 public static object GetMax(object[] nums, DelCompare del)public static T GetMax&lt;T&gt;(T[] nums, DelCompare&lt;T&gt; del){    T max = nums[0];    for(int i = 0; i &lt; nums.Length; i++)    {        if(del(max, nums[i]) &lt; 0)        {            max = nums[i];        }    }    return max;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">public static int Compare1(int o1, int o2){    return o1 - o2;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// Main函数public static void Main(string[] args){    // int 类    int[] nums = {1, 2, 3, 4, 5};    int max = GetMax&lt;int&gt;(nums, Compare1);    Console.WriteLine(max);        // string 类    string[] names = {"hdakd", "hsadopjadlja"};    string result = GetMax&lt;string&gt;(names, (string s1, string s2) =&gt; {        return s1.Length - s2.Length;});    COnsole.WriteLine(result);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="6-4-2-4-Lambda表达式"><a href="#6-4-2-4-Lambda表达式" class="headerlink" title="6.4.2.4 Lambda表达式"></a>6.4.2.4 Lambda表达式</h5><ul><li><code>Lambda表达式</code>本质上还是<code>匿名函数</code></li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">DelCompare del = (string name) =&gt; {Console.WriteLine(name)};<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">List&lt;int&gt; list = new List&lt;int&gt;(){1, 2, 3, 4, 5, 6, 7};// 将 大于4 的全部删除list.RemoveAll(n =&gt; n&gt;4);foreach(var item in list){    Console.WriteLine(item);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="6-5-事件"><a href="#6-5-事件" class="headerlink" title="6.5 事件"></a>6.5 事件</h3><h4 id="6-5-1-关于事件的一些问题"><a href="#6-5-1-关于事件的一些问题" class="headerlink" title="6.5.1 关于事件的一些问题"></a>6.5.1 关于事件的一些问题</h4><ul><li>==委托与事件的区别==<ul><li>委托是对方法的引用，而事件是一种特殊的委托，用于实现观察者模式，方便对象在状态变化时通知其他对象</li><li>委托不安全，事件的本质是一个安全的委托</li><li>委托在哪都可以调用，而事件只能在类内进行调用</li><li>委托是一种类型，事件是基于委托的一种机制，通过”Event”关键字进行声明</li><li>委托允许直接调用委托实例所引用的方法，而事件只能通过”+=“和”-=“来添加移除事件处理程序</li><li>实际应用时，事件能够提供更灵活的机制来处理对象间的通信</li></ul></li></ul><h4 id="6-5-2-事件的使用"><a href="#6-5-2-事件的使用" class="headerlink" title="6.5.2 事件的使用"></a>6.5.2 事件的使用</h4><h5 id="6-5-2-1-基本使用"><a href="#6-5-2-1-基本使用" class="headerlink" title="6.5.2.1 基本使用"></a>6.5.2.1 基本使用</h5><ul><li><p>以按键播放音乐为例</p></li><li><p>创建<code>PlayMusic</code>类，并在其中<strong>定义委托事件</strong></p></li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 声明事件之前要先创建委托public delegate void DelPlayOver();internal class PlayMusic{// 声明事件    // 若没有event，那么public DelPlayOver Del;就是委托    public event DelPlayOver Del;        // 音乐名    public string Name{get;set;}    public PlayMusic(string name)    {        this.Name = name;    }        // 播放音乐    public void PlaySongs()    {        Console.WriteLine("正在播放" + this.Name);                // 模拟播放耗时        Thread.Sleep(3000);                if(Del != null)        {            // 执行对应事件            Del();        }    }    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><strong>绑定事件</strong>，并执行相应方法</li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">private void button1_Click(object sender, EventArgs e){    PlayMusic p = new PlayMusic("哈哈哈哈哈");        // 注册事件    // 委托在调用方法时，p.Del = Test;    p.Del += Test;        p.PlaySongs();}// 事件绑定方法public void Test(){    Console.WriteLine("播放完成了！！！");}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="6-6-关于文件"><a href="#6-6-关于文件" class="headerlink" title="6.6 关于文件"></a>6.6 关于文件</h3><h4 id="6-6-1-File-类"><a href="#6-6-1-File-类" class="headerlink" title="6.6.1 File 类"></a>6.6.1 File 类</h4><ul><li>用于==读小文件==，因为<code>File</code>类是一下读完问文本，所以在读大文件会对内存造成较大的负荷</li></ul><h5 id="6-6-1-1-基本操作"><a href="#6-6-1-1-基本操作" class="headerlink" title="6.6.1.1 基本操作"></a>6.6.1.1 基本操作</h5><ul><li><strong>创建</strong>文件</li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">File.Create(@"C:\Users\echo\Desktop\new.txt");<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><strong>删除</strong>文件</li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">File.Delete(@"C:\Users\echo\Desktop\new.txt");<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><strong>复制</strong>文件</li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">File.Copy(@"C:\Users\echo\Desktop\old.txt",@"C:\Users\echo\Desktop\new.txt");<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><strong>剪切</strong>文件</li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">File.Move(@"C:\Users\echo\Desktop\old.txt",@"C:\Users\echo\Desktop\new.txt")<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h5 id="6-6-1-2-读取文本"><a href="#6-6-1-2-读取文本" class="headerlink" title="6.6.1.2 读取文本"></a>6.6.1.2 读取文本</h5><ul><li><p><code>ReadAllBytes()</code>可读取任何文件（文本、图片、音乐等），需要转为字节；后两个方法<code>ReadAllLines()</code>和<code>ReanAllText()</code>，只能读文本文件</p></li><li><p>将文本<strong>读取为字节</strong></p></li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">byte[] buffer = File.ReadAllBytes(@"C:\Users\echo\Desktop\old.txt");// 字节看不懂，转为字符串// GetEncoding()，指定编码格式string s = Encoding.GetEncoding("GB2312").GetString(buffer);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><strong>按行读取</strong></li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 按行读取，返回字符串数组string[] contents = File.ReadAllLines(@"C:\Users\echo\Desktop\old.txt",Encoding.Deffault);foreach(string item in contents){    Console.WriteLine(item);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><strong>全部读完</strong></li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 一下读完，返回一个stringstring str = File.ReanAllText(@"C:\Users\echo\Desktop\old.txt",Encoding.Deffault);Console.WriteLine(str);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h5 id="6-6-1-3-写入文本"><a href="#6-6-1-3-写入文本" class="headerlink" title="6.6.1.3 写入文本"></a>6.6.1.3 写入文本</h5><ul><li><strong>覆盖写入字节</strong></li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 读取时，如果没有对应文件，会自行创建；有的话，进行覆盖// 将字符串转为字节存储到文件中string str = "你干嘛哎哟";// Default 默认编码byte[] buffer = Encoding.Default.GetBytes(str);File.WriteAllBytes(@"C:\Users\echo\Desktop\new.txt",buffer);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><strong>覆盖按行写入</strong></li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">string[] str = new string[] {"sdf","jklj"};File.WriteAllLines(@"C:\Users\echo\Desktop\new.txt",str);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li><strong>覆盖全部写入</strong></li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">string str = "gakjfhlahfl";File.WriteAllText(@"C:\Users\echo\Desktop\new.txt",str);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li><strong>追加写入</strong></li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">File.AppendAllText();File.AppendAllLines();File.AppendText();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="6-6-2-编码简介"><a href="#6-6-2-编码简介" class="headerlink" title="6.6.2 编码简介"></a>6.6.2 编码简介</h4><ul><li>文本文件编码，文本文件有不同的存储方式，将字符串以特定的形式保存为二进制就是编码<ul><li>编码有<code>UTF8（web）、ASCII（字母、数字、音标）、Unicode（包含各种字体，但是解析慢）、GB2312（简体字）、Big5（简体 + 繁体字）</code></li><li><code>Unicode = UTF7 + UTF8 + UTF32</code></li></ul></li><li>文本<strong>乱码</strong>原因<ul><li>产生乱码的原因是  保存文件  时所采用的编码格式与  打开文件  时的编码格式不一样</li></ul></li></ul><h4 id="6-6-3-FileStream-类"><a href="#6-6-3-FileStream-类" class="headerlink" title="6.6.3 FileStream 类"></a>6.6.3 FileStream 类</h4><ul><li>读取文件时，是一点一点去读，不会对内存造成压力</li><li><code>FileStream</code>用于==操作字节==</li><li><code>FileStream</code>不会被垃圾回收机制处理，需要手动释放流所占用的内存</li></ul><h5 id="6-6-3-1-读取"><a href="#6-6-3-1-读取" class="headerlink" title="6.6.3.1 读取"></a>6.6.3.1 读取</h5><ul><li>读小文件</li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 创建FileStream对象// FileMode：对文件要进行的操作// FileAccess；对文本内容要进行的操作FileStream fsRead = new FileStream(@"C:\Users\echo\Desktop\new.txt",FileMode.OpenOrCreate,FileAccess.Read);// 创建 byte[] 去接收读取到的字节信息byte[] buffer = new byte[1024 * 1024 * 5];// 返回实际 读取到的有效字节数int r =fsRead.Read(buffer,0,buffer.Length);// 将字节数组中每一个元素按照指定编码格式解码为字符串string s = Encoding.Default.GetString(buffer,0,r);// 关闭流，释放流所占用的资源fsRead.Close();fsRead.Dispose();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="6-6-3-2-写入"><a href="#6-6-3-2-写入" class="headerlink" title="6.6.3.2 写入"></a>6.6.3.2 写入</h5><ul><li><strong>自动释放流</strong>的写法</li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 自动释放流using(FileStream name = new FileStream()){    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">using(FileStream fsWrite = new FileStream(@"C:\Users\echo\Desktop\new.txt",FileMode.OpenOrCreate,FileAccess.Write)){    string str = "oaflalfjklaj";    byte[] buffer = Encoding.Default.GetBytes(str);    fsWrite.Write(buffer,0,buffer.Length);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="6-6-3-3-基于FileStream的多媒体文件复制"><a href="#6-6-3-3-基于FileStream的多媒体文件复制" class="headerlink" title="6.6.3.3 基于FileStream的多媒体文件复制"></a>6.6.3.3 基于FileStream的多媒体文件复制</h5><ul><li><code>CopyFile</code>方法</li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 传入源文件路径、复制文件路径public static void CopyFile(string source,string target){    // 首次创建一个负责读取的流    using (FileStream fsRead = new FileStream(source,FileMode.Open,FileAccess.Read))    {        // 创建写入流        using (FileStream fsWrite = new FileStream(target,FileMode.OpenOrCreate,FileAccess.Write))        {            byte[] buffer = new byte[1024 * 1024 * 5];            // 因为文件可能会比较大，所以循环读取            while (true)            {                // Read：读取相应字节长度，然后将文件流的位置移动到已读取位置之后                int r = fsRead.Read(buffer, 0, buffer.Length);                // 读取完成                if(r == 0)                {                    break;                }                // 追加写入                fsWrite.Write(buffer, 0, r);            }        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>Main()</code>方法</li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">static void Main(string[] args){    string source = @"C:\Users\echo\Desktop\Music\解解的神仙现场 - 海阔天空 - 邓紫棋 (2023时光音乐会老友记现场).wav";    string target = @"C:\Users\echo\Desktop\解解的神仙现场.wav";    CopyFile(source, target);    Console.WriteLine("复制成功");}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="6-6-4-StreamReader和StreamWriter"><a href="#6-6-4-StreamReader和StreamWriter" class="headerlink" title="6.6.4 StreamReader和StreamWriter"></a>6.6.4 StreamReader和StreamWriter</h4><ul><li>操作字符、文本</li></ul><h5 id="6-6-4-1-StreamReader"><a href="#6-6-4-1-StreamReader" class="headerlink" title="6.6.4.1 StreamReader"></a>6.6.4.1 StreamReader</h5><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">using (StreamReader sr = new StreamReader(@"C:\Users\echo\Desktop\解解的神仙现场.txt", Encoding.Default)){    // 当没有读到文本末尾，循环打印读取到的行    while (!sr.EndOfStream)    {        Console.WriteLine(sr.ReadLine());    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="6-6-4-2-StreamWriter"><a href="#6-6-4-2-StreamWriter" class="headerlink" title="6.6.4.2 StreamWriter"></a>6.6.4.2 StreamWriter</h5><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 不存在的文件，会自行创建using (StreamWriter sw = new StreamWriter(@"C:\Users\echo\Desktop\new.txt",true)){    // 会覆盖源文本    // 添加一个 true 后，不会进行覆盖    sw.WriteLine("你赶紧的卡");}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="七、SQL数据库"><a href="#七、SQL数据库" class="headerlink" title="七、SQL数据库"></a>七、SQL数据库</h2><ul><li>存储数据的仓库</li><li><strong>增删改查</strong></li></ul><h3 id="7-1-SQLServer使用"><a href="#7-1-SQLServer使用" class="headerlink" title="7.1 SQLServer使用"></a>7.1 SQLServer使用</h3><h4 id="7-1-1-创建登录名"><a href="#7-1-1-创建登录名" class="headerlink" title="7.1.1 创建登录名"></a>7.1.1 创建登录名</h4><ul><li><p>创建<code>SQL Server</code>身份，设置用户名和密码<img src="image-20240108190413092-1705156191297-37.png" alt="" style="zoom: 50%;"></p></li><li><p><code>服务器角色</code>，服务器名最大权限为<code>sysadmin</code>，要作为管理员身份对数据库进行使用，可以将其勾选上<img src="image-20240108190723983-1705156191297-38.png" alt="" style="zoom: 50%;"></p></li><li><p>带  ×  的账户，可通过<code>双击</code>，并将<code>强制实施密码策略</code>取消勾选，并将<code>状态/登录名</code>勾选为<code>启动</code></p></li></ul><h4 id="7-1-2-登录SQL账户"><a href="#7-1-2-登录SQL账户" class="headerlink" title="7.1.2 登录SQL账户"></a>7.1.2 登录SQL账户</h4><ul><li><p>创建好登录名后，首先修改<code>服务器身份验证</code>，选中<code>服务器</code>，右键<code>属性</code>，点击<code>安全性</code>，勾选<code>SQL Server 和 Windows 身份验证模式</code></p></li><li><p>然后电脑底部搜索框搜索<code>SQL</code>，进入<code>SQL Server 网络配置</code>，进入<code>MSSQLSERVER 的协议</code>，启用<code>Named Pipes</code>和<code>TCP/IP</code></p></li><li><p>再选中<code>服务器名称</code>，右键选择<code>重新启动</code>，进行<code>SQL 账户</code>登录</p></li><li><p>若二次登录，出现==无法连接==的情况</p><ul><li><p><a href="https://blog.csdn.net/l5615461/article/details/123120106">安装完SQL Server后,解决本地服务器连接失败的方法(仅供参考)_sql server连不上本地服务器-CSDN博客</a></p></li><li><blockquote><p>此电脑 –&gt; 右键-管理 –&gt; 服务与应用程序-服务 –&gt; SQL Server(MSSQLSERVER) –&gt; 右键-启动</p></blockquote></li></ul></li></ul><h4 id="7-1-3-创建数据库"><a href="#7-1-3-创建数据库" class="headerlink" title="7.1.3 创建数据库"></a>7.1.3 创建数据库</h4><ul><li>选中<code>数据库</code>文件夹，右键<code>新建数据库</code></li><li>设置<code>数据库名称</code>，自动生成<code>数据库文件（数据文件 和 日志文件）</code></li><li>对于两个数据库文件，可以自定义<code>初始大小（初始内存）</code>，并设置<code>增长大小（当文件内容长度超过初始大小后，自动增加内存）</code>，另外可更改 数据库文件 <code>存放路径</code></li><li>如，建立一个名为 <u>SQL学习测试</u> 的数据库，初始内存大小及增长 使用默认参数，文件路径改为 <u>D:\Program Files\Microsoft SQL Server\学习测试\数据库</u><img src="image-20240108200949234-1705156191297-39.png" alt="" style="zoom: 33%;"></li></ul><h4 id="7-1-4-删除数据库"><a href="#7-1-4-删除数据库" class="headerlink" title="7.1.4 删除数据库"></a>7.1.4 删除数据库</h4><ul><li><p>==删除数据库文件==，直接删除是删除不了的，因为数据库有一个监听端口，创建一个数据库就会自动建立一个监听连接，数据库被管理起来<img src="image-20240108201202870-1705156191297-40.png" alt="" style="zoom:50%;"></p></li><li><p>若要删除，首先选中 数据库 文件夹，右键<code>任务 -&gt; 分离</code>，并勾选<code>删除连接</code>，点击<code>确认</code>，移除该数据库<img src="/2024/01/13/shang-wei-ji/image-20240108201621911-1705156191297-41.png" alt="image-20240108201621911"></p></li><li><p>移除之后，便可对两个<code>数据库文件</code>进行删除</p></li></ul><h4 id="7-1-5-还原数据库"><a href="#7-1-5-还原数据库" class="headerlink" title="7.1.5 还原数据库"></a>7.1.5 还原数据库</h4><ul><li>若<code>数据文件</code>还存在，通过选中<code>数据库</code>，右键<code>附加</code>，然后<code>添加</code>，选择<code>.mdf</code>文件，<code>确认</code>即可还原<img src="/2024/01/13/shang-wei-ji/image-20240108202327547-1705156191297-42.png" alt="image-20240108202327547"></li></ul><h4 id="7-1-6-新建表"><a href="#7-1-6-新建表" class="headerlink" title="7.1.6 新建表"></a>7.1.6 新建表</h4><ul><li><p>选中<code>数据库</code>下的<code>表</code>文件夹，右键<code>新建 -&gt; 表</code>，设置<code>列名</code>等<img src="image-20240108205049779-1705156191297-43.png" alt="" style="zoom:50%;"></p></li><li><p>录入数据<img src="image-20240108205259257.png" alt="" style="zoom: 33%;"><img src="image-20240108205432705-1705156191297-45.png" alt="" style="zoom: 33%;"></p></li></ul><h4 id="7-1-7-使用SQL脚本"><a href="#7-1-7-使用SQL脚本" class="headerlink" title="7.1.7 使用SQL脚本"></a>7.1.7 使用SQL脚本</h4><ul><li><p>首先进入脚本界面，选中数据库，并<code>新建查询</code><img src="image-20240108205832210-1705156191297-46.png" alt="" style="zoom: 50%;"></p></li><li><p>一些脚本代码</p><ul><li>启动数据库</li></ul></li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">/*-- 启动指定数据库-- use 数据库名-- go*/// 下面代码为 SQL 语言，之后的代码也一样use SQL学习测试go<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>添加数据</li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// -- 添加  insert into ，into这个关键词可以省略// SQL 语言insert Product([ProductNo], [ProductName], [ProductImage], [Price])values(1002,'华为','image/xxx.jpg',9000)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>删除数据</li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// -- 删除 delete from，from这个关键词也可以省略// SQL 语言delete Productwhere productName='华为'   -- where 关键词是条件<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>修改数据</li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// -- 修改 update// SQL 语言update Productset productname='华为mate40',productimage='image/huawei.jpg',price=10000where productNo=1003<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>查询数据</li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// -- 查询 select ... from ...// SQL 语言select * from Product  -- * 代表所有列select [ProductNo], [ProductName] from Product  -- 查询指定列where not productno=1001  -- 逻辑关键词 not and or 举例：where prductno=1003 or price&gt;5000<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="7-1-8-数据关联"><a href="#7-1-8-数据关联" class="headerlink" title="7.1.8 数据关联"></a>7.1.8 数据关联</h4><h5 id="7-1-8-1-创建数据关联关系"><a href="#7-1-8-1-创建数据关联关系" class="headerlink" title="7.1.8.1 创建数据关联关系"></a>7.1.8.1 创建数据关联关系</h5><ul><li>选中表格，右键<code>关系</code>，<code>添加</code>一个关系</li><li>在<code>常规</code>里，选中<code>表和列规范</code>的<code>...</code>，设置主键表和外键表</li><li>并将<code>在创建或重新启用时检查现有数据</code>设置为<code>否</code></li></ul><img src="image-20240109165325630-1705156191297-47.png" alt="" style="zoom:33%;"><h5 id="7-1-8-2-关联表查询"><a href="#7-1-8-2-关联表查询" class="headerlink" title="7.1.8.2 关联表查询"></a>7.1.8.2 关联表查询</h5><ul><li><p>一些查询代码示例</p><ul><li>外联接</li></ul></li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// -- 外联接 inner join// -- as 关键字可以进行重命名// -- 表格也可以取别名 如：Product a// SQL 语言select [ProductNo] as 编号, [ProductName], [ProductImage], [Price], a.[typeId], b.typeName// -- 对表格取别名from Product a inner join ProductType bon(a.typeId = b.typeId)// -- 如果还有表需要关联检索，继续写 inner join... on...// -- inner join otherTable// -- on(a.ProductName=otherTable.Name)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>内联接</li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// -- 左外联接 left join    以左表为基准进行匹配，匹配到了就显示，没匹配到就不显示// SQL 语言select [ProductNo], [ProductName], [ProductImage], [Price], Product.[typeId], ProductType.typeNamefrom ProductType left join Producton(Product.typeId = ProductType.typeId)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// -- 右外联接 right join// SQL 语言select [ProductNo], [ProductName], [ProductImage], [Price], Product.[typeId], ProductType.typeNamefrom ProductType right join Producton(Product.typeId = ProductType.typeId)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="7-1-9-聚合函数"><a href="#7-1-9-聚合函数" class="headerlink" title="7.1.9 聚合函数"></a>7.1.9 聚合函数</h4><ul><li><p>除了<code>count()</code>，其余的<code>avg() / sum() / max() / min()</code>均针对<strong>数字类型和日期</strong></p></li><li><p>计数<code>count()</code></p></li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// -- count 统计记录条数，当有一列中的某个单元格值为 NULL 时，不对其进行计数// SQL 语言select COUNT(ProductName) from Product// -- 统计全部，count()参数可写 */1select count(*) from Productselect count(1) from Product<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>求均值<code>avg()</code></li></ul><pre class="line-numbers language-C#" data-language="C#"><code class="language-C#">// SQLselect avg(Price) from Product<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>求和<code>sum()</code></li></ul><pre class="line-numbers language-C#" data-language="C#"><code class="language-C#">// SQLselect sum(Price) from Product<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>求最值<code>max() / min()</code></li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// SQLselect max(Price) from Productselect min(Price) from Product<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="7-1-10-排序与分组查询"><a href="#7-1-10-排序与分组查询" class="headerlink" title="7.1.10 排序与分组查询"></a>7.1.10 排序与分组查询</h4><ul><li>排序<code>order by ... asc/desc</code></li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// -- 排序 order by asc/desc  升序/降序// SQLselect * from Product// -- 先用 Price 降序排列，若 Price 有相同值，再用 typeId 进行二次降序排列order by Price desc,typeId asc  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>分组<code>group by</code></li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// -- 分组 group by // SQLselect ProductType.typeName as 类型, count(Product.ProductNo) as 数量from Product left join ProductTypeon(Product.typeId=ProductType.typeId)// -- wheregroup by ProductType.typeNameorder by 数量 desc<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>一些==注意事项==</p><ul><li><blockquote><p>– 语法有一定顺序<br>– order 一定在最后<br>– group 在 order 前面<br>– where 在 group 前面，select…from …on..后面</p></blockquote></li></ul></li></ul><h3 id="7-2-C-中使用SQL"><a href="#7-2-C-中使用SQL" class="headerlink" title="7.2 C#中使用SQL"></a>7.2 C#中使用SQL</h3><h4 id="7-2-1-基本步骤"><a href="#7-2-1-基本步骤" class="headerlink" title="7.2.1 基本步骤"></a>7.2.1 基本步骤</h4><blockquote><p>案例见<code>D:\Program Files\Microsoft Visual Studio\projects\毕设\数据库学习\用户登录\UserLogIn</code></p></blockquote><ul><li>第一步：创建数据库对象</li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">/*字符串参数分别为：Server   : 服务器名称uid     : 登录名pwd      : 密码database : 数据库名称*/SqlConnection conn = new SqlConnection("Server = LAPTOP-H5KQEA5B;uid = demo; pwd = 123456;database = SQL学习测试");<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>第二步：打开数据库</li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">conn.Open();<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>第三步：创建执行脚本对象</li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">string qq = this.txtQQ.Text;string pwd = this.txtPwd.Text;// SQL脚本代码string sql = $"select count(1) from UserInfos where qq = '{qq}' and pwd = '{pwd}'";// 脚本对象构造函数参数：(脚本代码字符串, 数据库对象)SqlCommand cmd = new SqlCommand(sql, conn);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>第四步：执行脚本</li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 执行脚本，并调用相应方法获取指定返回值// 如：返回脚本执行后结果的第一行第一列int result = (int)cmd.ExecuteScalar();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li>第五步：关闭数据库连接对象</li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">conn.Close();<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="7-2-2-防SQL注入"><a href="#7-2-2-防SQL注入" class="headerlink" title="7.2.2 防SQL注入"></a>7.2.2 防SQL注入</h4><blockquote><p>按 《用户登录》项目输入账号<code>10001</code> ，密码不输入<code>123456</code>，而输入<code>' or 1=1 --</code>，也会成功登录，为了避免此情况发生，在c#程序中，对代码进行处理，避免SQL注入</p></blockquote><ul><li>首先，通过<code>SqlParameter</code>对象进行参数化</li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 构造函数参数为：("@数据库元素名称", 用户输入Text)SqlParameter para1 = new SqlParameter("@qq", qq);SqlParameter para2 = new SqlParameter("@Pwd", pwd);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li>然后，在脚本对象<code>SqlCommand</code>后，对<code>SqlParameter</code>对象进行添加</li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">cmd.Parameters.Add(para1);cmd.Parameters.Add(para2);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="八、曲线绘制"><a href="#八、曲线绘制" class="headerlink" title="八、曲线绘制"></a>八、曲线绘制</h2><ul><li>使用<strong>chart</strong>控件进行曲线绘制</li></ul><h3 id="8-1-关于-chart-的一些属性"><a href="#8-1-关于-chart-的一些属性" class="headerlink" title="8.1 关于 chart 的一些属性"></a>8.1 关于 chart 的一些属性</h3><ul><li>假设只有一个 <code>ChartAreas</code>，即<code>ChartAreas[0]</code></li></ul><h4 id="8-1-1-坐标轴-显示范围-及-刻度间隔"><a href="#8-1-1-坐标轴-显示范围-及-刻度间隔" class="headerlink" title="8.1.1 坐标轴 显示范围 及 刻度间隔"></a>8.1.1 坐标轴 显示范围 及 刻度间隔</h4><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">chart1.ChartAreas[0].AxisY.Maximum = 45;  // 设置y轴 最大取值chart1.ChartAreas[0].AxisY.Minimum = -5;  // 设置y轴 最小取值chart1.ChartAreas[0].AxisY.Interval = 5;  // 设置y轴 刻度间隔chart1.ChartAreas[0].AxisX.Maximum = 45;  // 设置x轴 最大取值chart1.ChartAreas[0].AxisX.Minimum = -5;  // 设置x轴 最小取值chart1.ChartAreas[0].AxisX.Interval = 5;  // 设置x轴 刻度间隔<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="8-1-2-次网格"><a href="#8-1-2-次网格" class="headerlink" title="8.1.2 次网格"></a>8.1.2 次网格</h4><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 开启y轴次网格chart1.ChartAreas[0].AxisY.MinorGrid.Enabled = true;// 设置次网格线条样式，dash为破折号即虚线chart1.ChartAreas[0].AxisY.MinorGrid.LineDashStyle = ChartDashStyle.Dash;// 设置次网格线条颜色chart1.ChartAreas[0].AxisY.MinorGrid.LineColor = Color.DarkGray;// 设置次网格刻度间隔chart1.ChartAreas[0].AxisY.MinorGrid.Interval = chart1.ChartAreas[0].AxisY.Interval/2;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="8-1-3-图例"><a href="#8-1-3-图例" class="headerlink" title="8.1.3 图例"></a>8.1.3 图例</h4><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 清除图例chart1.Legends.Clear();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="8-1-4-条状带"><a href="#8-1-4-条状带" class="headerlink" title="8.1.4 条状带"></a>8.1.4 条状带</h4><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 实例化条状带StripLine stripLine1 = new StripLine();// 条状带宽stripLine1.StripWidth = 5;// 设置各条状带间隔，值为0，表示所有条状带重合stripLine1.Interval = 0;// 条状带底部起始刻度stripLine1.IntervalOffset = 3.5;// 条状带颜色stripLine1.BackColor = Color.FromArgb(120, Color.Red); //alpha 120，为透明度，取值0-255 // 将条状带添加到 ChartAreas[0] 处chart1.ChartAreas[0].AxisY.StripLines.Add(stripLine1);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="8-1-5-数据序列-Series"><a href="#8-1-5-数据序列-Series" class="headerlink" title="8.1.5 数据序列 Series"></a>8.1.5 数据序列 Series</h4><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 设置线宽chart1.Series[0].BorderWidth = 3;// 设置曲线类型chart1.Series[0].ChartType = SeriesChartType.Line;// 添加序列chart1.Series[0].Points.AddXY(0, 10);chart1.Series[0].Points.AddXY(1, 20);// 数据绑定，当 xVals,yVals 的值变化，曲线对应变化chart1.Series[0].Points.DataBindXY(xVals,yVals);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="8-2-一些应用"><a href="#8-2-一些应用" class="headerlink" title="8.2 一些应用"></a>8.2 一些应用</h3><h4 id="8-2-1-设置-时间轴"><a href="#8-2-1-设置-时间轴" class="headerlink" title="8.2.1 设置 时间轴"></a>8.2.1 设置 时间轴</h4><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 设置轴标签样式chart1.ChartAreas[0].AxisX.LabelStyle.Format = "HH:mm:ss";// 设置x轴值类型为 DateTimechart1.Series[0].XValueType = ChartValueType.DateTime;// 使用 ToOADate() 将时间对象转换为可显示的 数值chart1.ChartAreas[0].AxisX.Minimum = DateTime.Now.ToOADate();// 将 x轴 显示的最大时间设置为 3分钟 后的时刻chart1.ChartAreas[0].AxisX.Maximum = DateTime.Now.AddMinutes(3).ToOADate();// 设置 x轴 每一刻度间隔类型chart1.ChartAreas[0].AxisX.IntervalType = DateTimeIntervalType.Seconds;// 设置刻度间隔为 5schart1.ChartAreas[0].AxisX.Interval = 5;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="九、Async-Await"><a href="#九、Async-Await" class="headerlink" title="九、Async / Await"></a>九、Async / Await</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Jupter及Anaconda常用命令</title>
      <link href="/2023/01/14/jupter-ji-anaconda-chang-yong-ming-ling/"/>
      <url>/2023/01/14/jupter-ji-anaconda-chang-yong-ming-ling/</url>
      
        <content type="html"><![CDATA[<h3 id="conda命令"><a href="#conda命令" class="headerlink" title="conda命令"></a>conda命令</h3><table><thead><tr><th align="center">命令</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">conda list</td><td align="center">查询</td></tr><tr><td align="center">conda install *</td><td align="center">安装</td></tr><tr><td align="center">conda update *</td><td align="center">升级</td></tr><tr><td align="center">conda remove *</td><td align="center">卸载</td></tr><tr><td align="center">conda creat -n xx python=3.6</td><td align="center">创建虚拟环境</td></tr><tr><td align="center">activate xx</td><td align="center">进入虚拟环境</td></tr></tbody></table><hr><h3 id="jupyter-notebook使用"><a href="#jupyter-notebook使用" class="headerlink" title="jupyter notebook使用"></a>jupyter notebook使用</h3><h4 id="打开方式"><a href="#打开方式" class="headerlink" title="打开方式"></a>打开方式</h4><blockquote><p>cmd命令,在指定目录下输入jupyter notebook</p></blockquote><h4 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h4><table><thead><tr><th align="center">快捷键</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">shift+回车</td><td align="center">运行</td></tr><tr><td align="center">Tab</td><td align="center">自动补全</td></tr><tr><td align="center">shift+双击Tab</td><td align="center">查看函数文档</td></tr></tbody></table><h4 id="魔术命令"><a href="#魔术命令" class="headerlink" title="魔术命令"></a>魔术命令</h4><table><thead><tr><th align="center">命令代码</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">%pwd</td><td align="center">显示当前目录</td></tr><tr><td align="center">%matplotlib inline</td><td align="center">在代码下方绘制图形</td></tr><tr><td align="center">%timeit[代码]</td><td align="center">查看代码运行时间</td></tr></tbody></table>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2023/01/14/hello-world/"/>
      <url>/2023/01/14/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new "My New Post"<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
