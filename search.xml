<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>c#上位机开发</title>
      <link href="/2024/01/13/shang-wei-ji/"/>
      <url>/2024/01/13/shang-wei-ji/</url>
      
        <content type="html"><![CDATA[<h2 id="一、C"><a href="#一、C" class="headerlink" title="一、C#"></a>一、C#</h2><h3 id="1-1-编译过程"><a href="#1-1-编译过程" class="headerlink" title="1.1 编译过程"></a>1.1 编译过程</h3><ul><li><p>C# —- 编译器编译 —-IL中间语言 —- 通过.NET平台的CLR动态转换为机器指令</p></li><li><p>提升开发效率，代码直接转化为机器指令比较耗时</p></li><li><p>性能较c/c++较低</p></li></ul><h3 id="1-2-代码结构"><a href="#1-2-代码结构" class="headerlink" title="1.2 代码结构"></a>1.2 代码结构</h3><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 命名空间namespace HelloWorldCS{    // 类型    internal class Program    {        // 函数 方法        static void Main(String[] args)        {                    }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="1-2-1-命名空间"><a href="#1-2-1-命名空间" class="headerlink" title="1.2 1 命名空间"></a>1.2 1 命名空间</h4><ul><li><p>命名空间在导入时，可取别名<code>using 别名 = 要调用的命名空间</code></p></li><li><p>命名空间使用<code>.</code>标识符，进入命名空间下一级</p></li><li><p>全局命名空间<code>using global::要调用的命名空间</code></p></li></ul><h5 id="1-2-1-1-基本命名空间"><a href="#1-2-1-1-基本命名空间" class="headerlink" title="1.2.1.1 基本命名空间"></a>1.2.1.1 基本命名空间</h5><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">using System;  // 使用基本的数据类型等using System.Collections.Generic;  // 加载泛型等using System.ComponentModel;  // 控件组件模型工具using System.Data;  // 加载与数据库连接类等有关空间using System.Drawing;  // 绘制using System.Linq;  // 简化数据增删改查的一种语法using System.Text;  // 文本空间using System.Threading.Tasks;  // 线程using System.Windows.Forms;  // 窗体<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="1-2-1-2-命名空间定义"><a href="#1-2-1-2-命名空间定义" class="headerlink" title="1.2.1.2 命名空间定义"></a>1.2.1.2 命名空间定义</h5><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">namespace 空间名{  }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="1-3-数据类型"><a href="#1-3-数据类型" class="headerlink" title="1.3 数据类型"></a>1.3 数据类型</h3><h4 id="1-3-1-值类型"><a href="#1-3-1-值类型" class="headerlink" title="1.3.1 值类型"></a>1.3.1 值类型</h4><ul><li><p>从类<code>System.ValueType</code>中派生来</p></li><li><p>值类型变量可以直接分配给一个值</p></li><li><p>可用值类型</p><table><thead><tr><th align="center">类型</th><th align="center">描述</th><th align="center">默认值</th></tr></thead><tbody><tr><td align="center">bool</td><td align="center">布尔值</td><td align="center">False</td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">sbyte</td><td align="center">8位有符号整数</td><td align="center">0</td></tr><tr><td align="center">byte</td><td align="center">8位无符号整数</td><td align="center">0</td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">char</td><td align="center">16位Unicode字符</td><td align="center">‘\0’</td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">short</td><td align="center">16 位有符号整数</td><td align="center">0</td></tr><tr><td align="center">ushort</td><td align="center">16 位无符号整数</td><td align="center">0</td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">int</td><td align="center">32位有符号整数</td><td align="center">0</td></tr><tr><td align="center">uint</td><td align="center">32 位无符号整数</td><td align="center">0</td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">long</td><td align="center">64位有符号整数</td><td align="center">0L</td></tr><tr><td align="center">ulong</td><td align="center">64 位无符号整数</td><td align="center">0</td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">float</td><td align="center">32位单精度浮点型</td><td align="center">0.0F</td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">double</td><td align="center">64位双精度浮点型</td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">decimal</td><td align="center">128位精确十进制值，28-29有效位数</td><td align="center">0.0M</td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td></tr></tbody></table></li></ul><h4 id="1-3-2-引用类型"><a href="#1-3-2-引用类型" class="headerlink" title="1.3.2 引用类型"></a>1.3.2 引用类型</h4><ul><li>引用类型指向一个内存位置</li></ul><h4 id="1-3-3-Object类型"><a href="#1-3-3-Object类型" class="headerlink" title="1.3.3 Object类型"></a>1.3.3 Object类型</h4><ul><li>Object类型是所有数据类型的终极基类</li><li>可被分配任何其他类型（值类型、引用类型、预定义类型、自定义类型）的值</li><li>当一个值类型转换位Object类时，称为<strong>装箱</strong>，反之为<strong>拆箱</strong></li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">object obj;obj = 100;    // 装箱<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="1-3-4-String类"><a href="#1-3-4-String类" class="headerlink" title="1.3.4 String类"></a>1.3.4 String类</h4><h5 id="1-3-4-1-拼接字符串"><a href="#1-3-4-1-拼接字符串" class="headerlink" title="1.3.4.1 拼接字符串"></a>1.3.4.1 拼接字符串</h5><ul><li><p>使用**<code>+</code>运算符**，对多个<code>string</code>进行拼接</p></li><li><p>会产生一个<strong>新的<code>String</code>对象</strong></p></li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">string s1 = "hello";string s2 = "world";// 拼接后产生新的 String 对象string s = s1 + " " + s2;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="1-3-4-2-比较字符串"><a href="#1-3-4-2-比较字符串" class="headerlink" title="1.3.4.2 比较字符串"></a>1.3.4.2 比较字符串</h5><ul><li><p>使用**<code>==</code>比较运算符**</p></li><li><p>**<code>Equals()</code>**方法</p></li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">/*两种常用方法*/// 第一种public bool Equals(string strB)    // 第二种public static bool Equals(string strA, string strB)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>**<code>Compare()</code>**方法</li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">/*    两种重载方法    Int 返回值，strA == strB 返回 0               strA &gt; strB 返回 1               strA &lt; strB 返回 -1*/// 第一种public static int Compare(string strA, string strB)// 第二种// ignorCase 若设置为 True ，则在比较字符串时会  忽略大小写！！！public static int Compare(string strA, string strB, bool ignorCase)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>**<code>CompareTo()</code>**方法</li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">/*该方法返回值情况同 Compare()*/public int CompareTo(string strB)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h5 id="1-3-4-3-格式化字符串"><a href="#1-3-4-3-格式化字符串" class="headerlink" title="1.3.4.3 格式化字符串"></a>1.3.4.3 格式化字符串</h5><ul><li><code>String</code>类提供了一个静态<code>Format()</code>方法，将字符串格式化为指定格式</li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">/*format 参数格式：{参数列表索引:格式字符串}，如{0:C}、{0:F2}数值类型格式说明符（大小写均可）：c - 货币 - ￥123d - Decimal- 123e - 指数 - 1.025e+003f - 定点 - 124.76f2: 取2位小数n - Number - 12,800p - 百分比 - 100.00%   p0: 0位小数x - 十六进制 - 00FF   x4: 4位    日期时间的格式化（区分大小写）：    d - 简短日期：YYYY-MM-dd    D - 完整日期：YYYY年MM月dd日    t - 简短时间：hh:mm    T - 完整时间：hh:mm:ss    f - 简短日期/时间：YYYY-MM-dd hh:mm    F - 完整日期/时间：YYYY年MM月dd日 hh:mm:ss    g - 简短的可排序的日期/时间：YYYY-MM-dd hh:mm    G - 完整的可排序的日期/时间：YYYY-MM-dd hh:mm:ss    M/m - 月/日：MM月dd日    Y/y - 年/月：YYYY年MM月    */public static string Format(string format, object obj)    // 数值举例    运行结果：天才是1%的灵感，加上99%的汗水Console.WriteLine(string.Format("天才是{0:P0}的灵感，加上{1:P0}的汗水",0.01,0.99));// 日期时间举例    运行结果：2023年11月3日DateTime dt = DateTime.Now;string strB = String.Format("{0:D}",dt);Console.WriteLine(strB);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>ToString()</code>方法也可传入指定格式说明符，对数值/日期时间数据进行格式化</li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">int money = 1298;Console.WriteLine(money.ToString("C")); // 转换为货币形式DateTime dTime = DateTime.Now;Console.WriteLine(dTime.ToString("Y")); // 转换为年月// 运行结果：// ￥1298// 2023年11月<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="1-3-4-4-截取字符串"><a href="#1-3-4-4-截取字符串" class="headerlink" title="1.3.4.4 截取字符串"></a>1.3.4.4 截取字符串</h5><ul><li><code>Substring()</code>方法，截取指定位置和指定长度的子字符串</li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">/*参数：startIndex：字符串截取索引位置Length：截取长度，当Length大于字符串长度时，截取完为止*/public string Substring(int startIndex, int length)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="1-3-4-5-分割字符串"><a href="#1-3-4-5-分割字符串" class="headerlink" title="1.3.4.5 分割字符串"></a>1.3.4.5 分割字符串</h5><ul><li><code>Split()</code>方法，分割字符串，返回字符串数组对象</li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">/*params关键字：函数传参时用，意为函数参数不固定，此处跟char[]，表示其是一个可变数量数组参数：separator：分隔符数组*/public string[] Split(params char[] separator)    // 举例string strA = "你干嘛，哎哟";char[] separator = {'，'};String[] splitstring = new String[100];splitstring = strA.Split(separator);for(int i = 0; i&lt;splitstring.Length; i++{    Console.WriteLine("item{0}:{1}", i, splitstring[i]);}    // 运行结果：//    item0:你干嘛//   item1:哎哟<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="1-3-4-6-插入字符"><a href="#1-3-4-6-插入字符" class="headerlink" title="1.3.4.6 插入字符"></a>1.3.4.6 插入字符</h5><ul><li><code>Insert()</code>方法，向字符串任意位置插入新元素</li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">/*参数：startIndex：插入字符串索引value：要插入的字符串*/public string Insert(int startIndex, string value)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>PadLeft()</code>和<code>PadRight()</code>，分别在字符串左侧和右侧填充字符</li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">/*参数：totalWidth：填充后的字符串长度paddingChar：要填充的字符，若省略，填充空格*/public string PadLeft(int totalWidth, char paddingChar)public string PadRight(int totalWidth, char paddingChar)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="1-3-4-7-删除字符串"><a href="#1-3-4-7-删除字符串" class="headerlink" title="1.3.4.7 删除字符串"></a>1.3.4.7 删除字符串</h5><ul><li><code>Remove()</code>方法</li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 两种重载方法/*参数：startIndex：开始删除索引count：删除字符数目*/public String Remove(int startIndex)  // 删到最后一个字符public String Remove(int startIndex, int count)  // 删除指定个数字符<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="1-3-4-8-复制字符串"><a href="#1-3-4-8-复制字符串" class="headerlink" title="1.3.4.8 复制字符串"></a>1.3.4.8 复制字符串</h5><ul><li><code>Copy()</code>和<code>CopyTo()</code>，分别复制到另一个字符串或<code>Char[]</code></li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">public static string Copy(string str)/*参数：sourceIndex：待复制字符的起始位置destination：目标字符数组destinationIndex：目标数组开始存放字符的位置count：要复制的个数*/public void CopyTo(int sourceIndex, cahr[] destination, int destinationIndex, int count)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="1-3-4-9-替换字符串"><a href="#1-3-4-9-替换字符串" class="headerlink" title="1.3.4.9 替换字符串"></a>1.3.4.9 替换字符串</h5><ul><li><code>Replace()</code>方法，替换字符或字符串</li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">public string Replace(char OChar, char NChar)public string Replace(string OValue, string NValue)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="1-3-5-数组"><a href="#1-3-5-数组" class="headerlink" title="1.3.5 数组"></a>1.3.5 数组</h4><ul><li>一组相同数据类型的数据序列</li><li><code>String</code>类型本身就是由<code>char</code>类型组成的数组</li></ul><h5 id="1-3-3-1-初始化数组"><a href="#1-3-3-1-初始化数组" class="headerlink" title="1.3.3.1 初始化数组"></a>1.3.3.1 初始化数组</h5><ul><li>声明一个长度为2的<code>String</code>数组，<code>string a = new string[2];</code></li><li>声明并初始化，<code>string a = new string[2]{"你干嘛","哎哟"}</code></li></ul><h4 id="1-3-6-正则表达式"><a href="#1-3-6-正则表达式" class="headerlink" title="1.3.6 正则表达式"></a>1.3.6 正则表达式</h4><ul><li>作用：查找符合某些复杂规则的字符串</li><li>实质：正则表达式是记录文本规则的代码</li></ul><h5 id="1-3-6-1-行定位符"><a href="#1-3-6-1-行定位符" class="headerlink" title="1.3.6.1 行定位符"></a>1.3.6.1 行定位符</h5><ul><li><p>用来描述字符串的边界</p></li><li><p><code>^</code>和<code>$</code>分别用于表示行的开始和结尾</p></li><li><p><code>^tm</code>可用于<code>tm</code>开头的字符串，如<code>tm123dhak</code></p><ul><li><code>tm$</code>用于匹配<code>tm</code>结尾的字符串，如<code>dkah123tm</code></li></ul></li><li><p>若<code>tm</code>可出现在字符串任意部位，正则表达式可直接写为<code>tm</code></p></li></ul><h5 id="1-3-6-2-元字符"><a href="#1-3-6-2-元字符" class="headerlink" title="1.3.6.2 元字符"></a>1.3.6.2 元字符</h5><ul><li><p>常用元字符</p><table><thead><tr><th align="center">元字符</th><th align="center">说明</th><th align="center">元字符</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">.</td><td align="center">匹配除换行符外的任意字符</td><td align="center">\b</td><td align="center">匹配单词的开或结束</td></tr><tr><td align="center">\w</td><td align="center">匹配字母、数字、下划线或汉字</td><td align="center">^</td><td align="center">匹配字符串的开始</td></tr><tr><td align="center">\s</td><td align="center">匹配任意的空白字符</td><td align="center">$</td><td align="center">匹配字符串的结束</td></tr><tr><td align="center">\d</td><td align="center">匹配数字</td><td align="center"></td><td align="center"></td></tr></tbody></table><ul><li>如<code>\bmr\w*\b</code>，该正则表达式表示，匹配以<code>mr</code>开头的单词，先匹配单词开始处<code>\b</code>，然后匹配字母<code>mr</code>，接着匹配任意数量的字母或数字<code>\w*</code>，最后匹配单词结束处<code>\b</code>。该表达式可匹配<code>mrsoft、mrbook、mr123456</code>等</li></ul></li></ul><h5 id="1-3-6-3-限位符"><a href="#1-3-6-3-限位符" class="headerlink" title="1.3.6.3 限位符"></a>1.3.6.3 限位符</h5><ul><li><p>匹配指定数量的字符</p></li><li><p>常用限位符</p><table><thead><tr><th align="center">限位符</th><th align="center">说明</th><th align="center">举例</th></tr></thead><tbody><tr><td align="center">?</td><td align="center">匹配前面的字符零次或一次</td><td align="center">go?gle，该表达式可匹配ggle和gogle</td></tr><tr><td align="center">+</td><td align="center">匹配前面的字符一次或多次</td><td align="center">go+gle，该表达式可匹配范围从gogle到goo…gle</td></tr><tr><td align="center">*</td><td align="center">匹配前面的字符零次或多次</td><td align="center">go*gle，该表达式可匹配范围从ggle到goo…gle</td></tr><tr><td align="center">{n}</td><td align="center">匹配前面的字符n次</td><td align="center">go{2}gle，只能匹配google</td></tr><tr><td align="center">{n,}</td><td align="center">匹配前面的字符至少n次</td><td align="center">go{2,}gle，该表达式可匹配范围从google到goo…gle</td></tr><tr><td align="center">{n,m}</td><td align="center">匹配前面的字符[n, m]次</td><td align="center">go{0,2}gle，该表达式可匹配范围从ggle、gogle、google</td></tr></tbody></table><ul><li>如<code>\d{8}$</code>，匹配8位数字</li></ul></li></ul><h5 id="1-3-6-4-自定义字符"><a href="#1-3-6-4-自定义字符" class="headerlink" title="1.3.6.4 自定义字符"></a>1.3.6.4 自定义字符</h5><ul><li>使用<code>[]</code>，匹配指定字符<ul><li>例，要匹配元音字母，<code>[aeiou]</code>，该表达式即可匹配任意一个元音字母</li></ul></li><li>若要排除指定字符，在<code>[]</code>内使用<code>^</code><ul><li>例，<code>[^a-zA-Z]</code>，匹配一个非字母字符</li></ul></li></ul><h5 id="1-3-6-5-选择字符"><a href="#1-3-6-5-选择字符" class="headerlink" title="1.3.6.5 选择字符"></a>1.3.6.5 选择字符</h5><ul><li>在面对身份证的匹配时，身份证号码长度为15或18，如果15位则全是数字；如果为18位，则前17位为数字最后一位是校验位，既可以是数字也可以是字符X或x</li><li>该匹配规则隐含选择逻辑，使用字符<code>|</code>来实现<ul><li><code>(^\d{15}$)|(^\d{18}$)|(^\d{17}(X|x)$)</code></li></ul></li></ul><h5 id="1-3-6-6-转义字符"><a href="#1-3-6-6-转义字符" class="headerlink" title="1.3.6.6 转义字符"></a>1.3.6.6 转义字符</h5><ul><li>当需要匹配<code>.</code>、<code>?</code>、<code>\</code>等字符时，由于正则表达式已有相应含有，可通过转义字符转换为普通字符<ul><li>例，需要匹配127.0.0.1这样的IP地址，可使用<code>\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}</code>进行匹配</li></ul></li></ul><h5 id="1-3-6-7-分组"><a href="#1-3-6-7-分组" class="headerlink" title="1.3.6.7 分组"></a>1.3.6.7 分组</h5><ul><li>使用小括号<code>()</code>，其除了可以改变限定符的作用范围，还可以进行分组<ul><li>例，<code>(\.[0-9]{1,3}){3}</code>，对分组<code>\.[0-9]{1,3}</code>进行3次重复操作</li></ul></li></ul><h5 id="1-3-6-8-使用正则表达式"><a href="#1-3-6-8-使用正则表达式" class="headerlink" title="1.3.6.8 使用正则表达式"></a>1.3.6.8 使用正则表达式</h5><ul><li>借助<code>System.Text.RegularExpression</code>命名空间下的<code>Regex</code>类</li><li>该类有许多静态方法<ul><li><code>IsMatch()</code>，指示正则表达式在输入字符串中是否找到匹配项</li><li><code>Match()</code>，在输入字符串中搜索正则表达式的匹配项，并将精确结果作为单个<code>Match</code>对象进行返回</li><li><code>Matches()</code>，返回正则表达式所有成功的匹配，相当于多次调用<code>Match()</code></li><li><code>Replace()</code>，用指定替换字符串去替换匹配正则表达式的所有匹配项</li><li><code>Split()</code>，在正则表达式定义的位置将输入字符串拆分为一个字符串数组</li></ul></li></ul><h4 id="1-3-7-哈希表"><a href="#1-3-7-哈希表" class="headerlink" title="1.3.7 哈希表"></a>1.3.7 哈希表</h4><ul><li>集合类型，类似于python字典，键值对</li><li>哈希表每一个元素都是存储在<code>DictionaryEntry</code>对象中的键值对，键不能为空，值可用</li></ul><h5 id="1-3-7-1-构造函数"><a href="#1-3-7-1-构造函数" class="headerlink" title="1.3.7.1 构造函数"></a>1.3.7.1 构造函数</h5><ul><li><code>Hashtable()</code>构造方法创建<code>Hashtable</code>对象</li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 使用默认的初始容量、加载因子、哈希代码来创建实例public Hashtable()// 使用指定初始容量、默认加载因子、默认哈希代码来创建实例public Hashtable(int capacity)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="1-3-7-2-Hashtable属性"><a href="#1-3-7-2-Hashtable属性" class="headerlink" title="1.3.7.2 Hashtable属性"></a>1.3.7.2 Hashtable属性</h5><ul><li><code>Count</code>：获取键值对数目</li><li><code>Item</code>：获取或设置与指定键相关联的值</li><li><code>Keys</code>：获取<code>Hashtable</code>中键的<code>ICollection</code></li><li><code>Values</code>：获取值的<code>ICollection</code></li></ul><h5 id="1-3-7-3-添加元素"><a href="#1-3-7-3-添加元素" class="headerlink" title="1.3.7.3 添加元素"></a>1.3.7.3 添加元素</h5><ul><li><code>Add()</code>，添加键值对</li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 参数 value可为空public virtual void Add(Object key, Object value)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 例Hashtable hash = new Hashtable();hash.Add("id", "Bh001");hash.Add("name", "TM");hash.Add("sex", "男");Console.WriteLine(hash,Count);// 运行结果为：3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="1-3-7-4-删除元素"><a href="#1-3-7-4-删除元素" class="headerlink" title="1.3.7.4 删除元素"></a>1.3.7.4 删除元素</h5><ul><li><code>Clear()</code>和<code>Remove()</code></li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// Clear()，清空Hashtablepublic virtual void Clear()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// Remove()，删除指定键元素// 参数：key 为待删除元素的键public virtual void Remove(Object key)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h5 id="1-3-7-5-遍历哈希表"><a href="#1-3-7-5-遍历哈希表" class="headerlink" title="1.3.7.5 遍历哈希表"></a>1.3.7.5 遍历哈希表</h5><ul><li>因为哈希表元素是键值对，所以要使用<code>DictionaryEntry</code>结构进行遍历，其表示一个键值对的集合</li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 遍历哈希表，假设哈希表中已有元素foreach(DictionaryEntry dic in hash){Console.WriteLine("\t" + dic.Key + "\t" + dic.Value);    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="1-3-7-6-查找元素"><a href="#1-3-7-6-查找元素" class="headerlink" title="1.3.7.6 查找元素"></a>1.3.7.6 查找元素</h5><ul><li><code>Contains()、ContainsKey()、ContainsValue()</code></li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 寻找指定 键// Contains() 和 ContainsKey() 方法功能、语法相同// 只介绍Contains()方法public virtual bool Contains(Object key)    // 寻找指定 值public virtual bool ContainsValue(Object Value)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-4-类与对象"><a href="#1-4-类与对象" class="headerlink" title="1.4 类与对象"></a>1.4 类与对象</h3><h4 id="1-4-1-类"><a href="#1-4-1-类" class="headerlink" title="1.4.1 类"></a>1.4.1 类</h4><ul><li>类是一种数据类型，包含<strong>数据成员</strong>（常量和变量）、<strong>函数成员</strong>（方法、属性、事件、索引器、运算符、构造函数和析构函数）和<strong>嵌套类型</strong></li><li>==类可在不同源文件之间进行拆分==</li></ul><h5 id="1-4-1-1-类的声明"><a href="#1-4-1-1-类的声明" class="headerlink" title="1.4.1.1 类的声明"></a>1.4.1.1 类的声明</h5><ul><li>类的声明</li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">访问修饰符 class 类名{    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h5 id="1-4-1-2-构造函数和析构函数"><a href="#1-4-1-2-构造函数和析构函数" class="headerlink" title="1.4.1.2 构造函数和析构函数"></a>1.4.1.2 构造函数和析构函数</h5><ul><li><p>对象的生命周期从构造函数开始，析构函数结束</p></li><li><p>构造函数：用于对对象进行初始化，实例化对象时自动调用</p><ul><li>定义类时，若未定义构造函数，编译器会自动创建一个不带参数的默认构造函数</li></ul></li><li><p>要使用有参构造函数，需显式实例化，传入参数</p></li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">public class Book{    public Book()  // 无参构造函数    {            }        public Book(int args)  // 有参构造函数    {        args = 2 + 3;}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>析构函数：用于回收对象资源，销毁对象时自动调用</p><ul><li><p>当某个实例化对象被认为不再有效，并符合析构条件时，<code>.NET Framework</code>类库的垃圾回收功能会自动调用析构函数实现垃圾回收</p></li><li><p>一个类只有一个析构函数，且无法调用析构函数，它是自动调用的</p></li></ul></li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// Main()函数执行完后，创建的demo实例pro不再有效，调用~demo析构函数，并打印字符串public class demo{    ~demo()    {        Console.WriteLine("析构函数自动调用");    }    static void Main(string[] args)    {        demo pro = new demo();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="1-4-1-3-属性"><a href="#1-4-1-3-属性" class="headerlink" title="1.4.1.3 属性"></a>1.4.1.3 属性</h5><ul><li><p>对象拥有的所有特征，在类中表示时称为类的属性</p></li><li><p>属性可以像使用公共数据成员一样使用，但它实际上是一种称为“访问器”的特殊方法，其指定了属性值被读取或写入时要执行的语句。通过该机制，可以把读取、写入对象的某些特性于操作关联起来</p></li><li><p>调用<code>对象名.属性名</code></p></li><li><p>属性的声明</p></li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">访问修饰符 数据类型 属性名{    // get访问器必须返回属性类型的值    get    {        return 变量名;    }        // 使用value隐式参数，此参数的类型是属性的类型    set    {        // set访问器可以包含大量语句，可对能赋予的值进行检查，避免给属性值设置错误        变量名 = value;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// c#支持自动实现的属性，即在访问器中没有任何逻辑// 自动实现的属性，必须同时拥有get和set两个访问器public int Age{    get;    set;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="1-4-1-4-方法"><a href="#1-4-1-4-方法" class="headerlink" title="1.4.1.4 方法"></a>1.4.1.4 方法</h5><ul><li><p>声明方法时，除了可以使用访问修饰符外，还可以使用<code>new、static、virtual、override、sealed、abstract、extern</code>等修饰符</p></li><li><p>关于新修饰符</p><ul><li><code>static、virtual、override</code>最多包含一个</li><li><code>new、override</code>最多包含一个</li><li>若声明中使用了<code>abstract</code>，则不能使用<code>static、virtual、sealed、extern </code></li><li>若使用了<code>private</code>，不能使用<code>virtual、override、abstract</code></li><li>若使用了<code>sealed</code>，那么还得包含<code>override</code>修饰符</li></ul></li><li><p>方法声明</p></li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">修饰符 返回值类型 方法名(参数列表){    // 方法的具体实现}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>方法形参的声明，可使用<code>params、ref、out</code>修饰</p><ul><li><p>==属性不能作为<code>ref、out</code>参数进行传递==</p></li><li><p><code>params</code>用来指定在参数数目可变的方法参数，<strong>必须是一维数组</strong></p></li></ul></li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">static void demo(params string[] list){    for(int i = 0; i &lt; list.Length; i++)    {        Consolde.WriteLine(list[i]);    }}static void Main(){    string[] a = new string[]{"我","是","中","国","人"};    demo(a);    Console.Read();}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p><code>ref</code>表示按<strong>引用传递</strong>参数</p><ul><li><p>如果使用<code>ref</code>参数，那么在方法声明和调用方法时都必须显式使用<code>ref</code>关键字</p></li><li><p>实参在传递前必须初始化</p></li></ul></li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">public static void Method(ref int i){    i = 44;}public static void Main(){    int val = 0;    Method(ref val);    Console.WriteLine(val);    Console.Read();}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p><code>out</code>同样是<strong>引用传递</strong></p><ul><li><p>在方法声明和调用方法时都必须显式使用<code>out</code>关键字</p></li><li><p>实参不需要初始化</p></li></ul></li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">public static void Method(out int i){    i = 44;}public static void Main(){    int val;    Method(out val);    Console.WriteLine(val);    Console.Read();}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="1-4-2-对象"><a href="#1-4-2-对象" class="headerlink" title="1.4.2 对象"></a>1.4.2 对象</h4><h5 id="1-4-2-1-对象的创建"><a href="#1-4-2-1-对象的创建" class="headerlink" title="1.4.2.1 对象的创建"></a>1.4.2.1 对象的创建</h5><ul><li>使用<code>new</code>关键字，如有一个<code>demo</code>类，实例化，<code>demo a = new demo()</code></li></ul><h5 id="1-4-2-2-访问对象的属性和行为"><a href="#1-4-2-2-访问对象的属性和行为" class="headerlink" title="1.4.2.2 访问对象的属性和行为"></a>1.4.2.2 访问对象的属性和行为</h5><ul><li>使用<code>.</code>操作符调用类的成员变量和成员方法</li></ul><h5 id="1-4-2-3-对象销毁"><a href="#1-4-2-3-对象销毁" class="headerlink" title="1.4.2.3 对象销毁"></a>1.4.2.3 对象销毁</h5><ul><li>有以下两种情况时，会被<code>.NET</code>垃圾回收器视为垃圾并进行回收<ul><li>对象引用超过其作用范围，</li><li>将对象赋值为<code>null</code></li></ul></li></ul><h4 id="1-4-3-静态类及其成员"><a href="#1-4-3-静态类及其成员" class="headerlink" title="1.4.3 静态类及其成员"></a>1.4.3 静态类及其成员</h4><ul><li><p>当属性和方法被修饰为<code>static</code>时，它们不属任一实例对象，直接通过类名进行调用</p></li><li><p>c# 不支持静态局部变量，==不能在方法中声明静态变量==</p></li><li><p>静态成员的作用</p><ul><li>保留已实例化的对象数的计数</li><li>存储必须在所有实例间共享的值</li></ul></li><li><p>若在定义类时加上关键字<code>static</code></p><ul><li>那么该类中只能包含静态成员</li><li>其无法实例化，所以也不能定义实例构造函数</li></ul></li><li><p>静态类会进行密封，<strong>无法继承</strong>，它们不能继承自任何的类或接口（<strong>除了Object</strong>）</p></li></ul><h4 id="1-4-4-this关键字"><a href="#1-4-4-this关键字" class="headerlink" title="1.4.4 this关键字"></a>1.4.4 this关键字</h4><ul><li><p><code>this</code>引用的是本类的一个对象</p></li><li><p>当局部变量或方法参数覆盖了成员变量时，就需要添加关键字<code>this</code>，来明确引用的是类成员还是局部变量或方法参数</p></li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">private void setName(String name){    // 如果写为 name = name ，则只会把参数name的值赋给参数变量，成员变量name不会改变    this.name = name;  // 将参数值赋予类中的成员变量}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>this</code>还可作为方法返回值</li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">public Book getBook(){    return this;  // 返回Book类的引用}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="1-4-5-继承"><a href="#1-4-5-继承" class="headerlink" title="1.4.5 继承"></a>1.4.5 继承</h4><h5 id="1-4-5-1-继承的实现"><a href="#1-4-5-1-继承的实现" class="headerlink" title="1.4.5.1 继承的实现"></a>1.4.5.1 继承的实现</h5><ul><li><p>基本思想：基于某个父类的扩展，指定出一个新的子类（派生类）</p></li><li><p>子类可以继承父类原有的属性和方法，也可以增加父类不具备的属性和方法，或者重写父类的方法</p></li><li><p>使用<code>:</code>来标识两个类的继承关系，当对一个类使用<code>sealed</code>修饰后，该类将不能被继承</p></li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">public class Computer{    // 父类}public class Pad:Computer  // Pad继承于Computer{    // 子类}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="1-4-5-2-base关键字"><a href="#1-4-5-2-base关键字" class="headerlink" title="1.4.5.2 base关键字"></a>1.4.5.2 base关键字</h5><ul><li><p>当子类对父类成员方法进行重写后，若要访问父类原有的方法，需要使用关键字<code>base</code>，使用方法同<code>this</code></p><ul><li>==重写父类方法时，修饰权限只能变大或者不变，变小访问权限是错误的==</li></ul></li><li><p>若要使用<code>base</code>调用父类的属性或方法，父类相应的属性和方法必须定义为<code>public</code>或<code>protected</code></p></li><li><p>另外，使用<code>base</code>关键字还可以指定创建子类实例时应调用的父类构造函数</p><ul><li>访问父类成员只能在构造函数、实例方法或实例属性中进行，==在静态方法中使用<code>base</code>关键字是错误的==</li></ul></li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 父类构造函数public Goods(string tradecode, string fullname){    TradeCode = tradecode;    FullName = fullname;}// 子类基于父类定义构造函数public JHInfo(string jhid, string tradecode, string fullname):base(tradecode,fullname){    JHID = jhid;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="1-4-5-3-继承中的构造-析构函数"><a href="#1-4-5-3-继承中的构造-析构函数" class="headerlink" title="1.4.5.3 继承中的构造/析构函数"></a>1.4.5.3 继承中的构造/析构函数</h5><ul><li>调用顺序，构造函数从最顶层父类依次调用到子类，析构函数反之<img src="image-20231107213904383-1705156191266-1.png" alt="" style="zoom:50%;"></li></ul><h4 id="1-4-6-多态"><a href="#1-4-6-多态" class="headerlink" title="1.4.6 多态"></a>1.4.6 多态</h4><h5 id="1-4-6-1-重写虚方法"><a href="#1-4-6-1-重写虚方法" class="headerlink" title="1.4.6.1 重写虚方法"></a>1.4.6.1 重写虚方法</h5><ul><li><p>方法默认情况下不是虚拟的，除构造函数外，其他方法可以显式地声明为<code>virtual</code></p></li><li><p>在方法前面加上关键字<code>virtual</code>，则该方法称为虚方法</p><ul><li><p>==类中的成员字段和静态方法不能声明为<code>virtual</code>==</p></li><li><p><code>virtual</code>只对类中的实例函数和属性有意义</p></li></ul></li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 声明一个虚方法public virtual void Move(){    Console.WriteLine("交通工具可以移动");}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>定义虚方法后，可以在派生类中重写虚方法，使用关键字<code>override</code></li></ul><pre class="line-numbers language-C#" data-language="C#"><code class="language-C#">// 在派生类中重写虚方法public override void Move(){    Console。WriteLine("火车可以移动");}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="1-4-6-2-方法重载"><a href="#1-4-6-2-方法重载" class="headerlink" title="1.4.6.2 方法重载"></a>1.4.6.2 方法重载</h5><ul><li><p>指的是方法名相同，但参数的数据类型、个数和顺序不同的方法</p></li><li><p>当类中有两种以上同名方法（重载），需清楚要调用哪种方法</p></li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 定义静态方法Add()，参数为两个int，返回值为intpublic static int Add(int x, int y){    return x+y;}// 重载Add()，参数为一个int一个double，返回值为doublepublic double Add(int x, double y){    return x+y;}// 再次重载Add()，其参数个数较第一个函数增加为3个public int Add(int x, int y, int z){    return x+y+z;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="1-4-7-结构"><a href="#1-4-7-结构" class="headerlink" title="1.4.7 结构"></a>1.4.7 结构</h4><ul><li>值类型，用来封装一组相关变量</li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">结构修饰符 struct 结构名{    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li>结构可包括构造函数、常量、字段、方法、属性、运算符、事件和嵌套类型等</li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 声明一个矩形结构，定义宽高，Area()方法public struct Rect{    public double width;    public double height;    public double Area()    {        return width*height;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>向方法传递结构时，结构是通过传值方式进行传递的，不是作为引用传递</p></li><li><p>结构可以声明构造函数，但必须带参数</p></li><li><p>结构实例化，可以不用<code>new</code></p></li><li><p>所有结构都直接继承自<code>System.ValueType</code>，所以一个结构不能继承于另一个结构或类</p></li><li><p>在结构中初始化实例字段是错误的</p></li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">public struct Rect{    public double width;    public double height;        // 构造函数    public Rect(double x, double y)    {        width = x;        height = y;    }        public double Area()    {        return width*height;    }}static void Main(string[] args){    Rect rect1;  // 实例化一个矩形结构    rect1.width = 5;    rect1.height = 3;    Console.WriteLine("矩形面积为：" + rect1.Area());        Rect rect2 = new Rect(6, 4);  // 使用构造函数实例化矩形结构    Console.WriteLine("矩形面积为：" + rect2.Area());}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-5-控制台应用程序"><a href="#1-5-控制台应用程序" class="headerlink" title="1.5 控制台应用程序"></a>1.5 控制台应用程序</h3><h4 id="1-5-1-主要语句"><a href="#1-5-1-主要语句" class="headerlink" title="1.5.1 主要语句"></a>1.5.1 主要语句</h4><ul><li><strong>打印</strong></li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 打印且换行// cw + 2下Tab  快捷生成该语句System.Console.WriteLine();// 打印不换行System.Console.Write();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><strong>读取</strong></li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 读取单个按键System.Console.ReadKey();// 读取字串System.Console.ReadLine();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="1-5-2-示例"><a href="#1-5-2-示例" class="headerlink" title="1.5.2 示例"></a>1.5.2 示例</h4><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">using System;namespace fund{    internal static class Program    {        static void Main()        {           int temp = 0;            // 使用int类方法Parse()，将接收的string强转为int            temp = int.Parse(Console.ReadLine());            // "结果为："+temp+30    temp和30会自动转为字符串，与"结果为："进行拼接            Console.WriteLine("结果为："+temp+30);            Console.ReadKey();        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-6-文件操作"><a href="#1-6-文件操作" class="headerlink" title="1.6 文件操作"></a>1.6 文件操作</h3><ul><li>使用命名空间<code>using System.IO;</code></li></ul><h4 id="1-6-1-获取文件"><a href="#1-6-1-获取文件" class="headerlink" title="1.6.1 获取文件"></a>1.6.1 获取文件</h4><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 获取对应路径下的文件string path = @"C:\Users\echo\Desktop";DirectoryInfo root = new DirectoryInfo(path);FileInfo[] files = root.GetFiles();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="1-6-2-删除指定文件"><a href="#1-6-2-删除指定文件" class="headerlink" title="1.6.2 删除指定文件"></a>1.6.2 删除指定文件</h4><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 遍历文件集合for (int i = 0; i &lt; files.Length; i++){FileInfo fi = files[i];        // 打印 文件绝对路径    //Console.WriteLine(fi.FullName);    // 打印 文件名    //Console.WriteLine(fi.Name);    // 删除 指定文件    if (fi.Name == "123.txt")    {        // 传入绝对路径        File.Delete(fi.FullName);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="1-6-3-更改文件名"><a href="#1-6-3-更改文件名" class="headerlink" title="1.6.3 更改文件名"></a>1.6.3 更改文件名</h4><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 文件改名bool isHave = fi.Name.Contains("123");  // 也可参数补全文件后缀，删更改指定文件类型的文件名if (isHave){    // 获取原始绝对路径文件名    string srcFileName = fi.FullName;    // 定义新绝对路径文件名，不更改文件类型    string dstFileName = fi.Directory.FullName+@"\ddd"+fi.Extension;    // 对文件进行更名，并移动到指定位置    File.Move(srcFileName, dstFileName);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-7-随机数"><a href="#1-7-随机数" class="headerlink" title="1.7 随机数"></a>1.7 随机数</h3><h4 id="1-7-1-Random类"><a href="#1-7-1-Random类" class="headerlink" title="1.7.1 Random类"></a>1.7.1 Random类</h4><ul><li>通过<code>Random</code>类产生，该类并非静态类，所以必须通过实例化产生</li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 实例化一个random类，并产生1-33的随机整数Random a = new random();a.Next(1,34);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="1-7-2-例程1-–-双色球"><a href="#1-7-2-例程1-–-双色球" class="headerlink" title="1.7.2 例程1 – 双色球"></a>1.7.2 例程1 – 双色球</h4><ul><li><p>具体代码文件见<code>D:\Program Files\Microsoft Visual Studio\projects\start\write</code></p></li><li><p>以双色球开奖为例，6个红色球取值为1-33，1个蓝色球取值为1-16</p></li><li><p>界面搭建如图</p><ul><li><img src="image-20231031162713259-1705156191295-2.png" alt="" style="zoom: 25%;"></li></ul></li><li><p>通过<code>开始抽奖</code>按钮（button1），启动时钟，并设置时间间隔；<code>停止抽奖</code>按钮（button2）关闭时钟；<code>timer1</code>时钟触发<code>tick</code>事件内，执行产生7位随机数</p></li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 开始抽奖按钮private void button1_Click(object sender, EventArgs e){    timer1.Enabled = true;    timer1.Interval = 100;    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 停止抽奖按钮private void button2_Click(object sender, EventArgs e){    timer1.Enabled=false;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 时钟触发事件 private void timer1_Tick(object sender, EventArgs e) { Random a = new Random(); // 感觉生成7个随机数的代码有些冗余，不知道能不能通过循环实现，后续优化！！！      /* // 简化代码 // 设置文本的 Label 集合    Label[] labels = {label1, label2, label3, label4, label5, label6};    // 循环设置每个 Label 的文本    foreach (Label label in labels)    {        label.Text = Convert.ToString(random.Next(1, 34));    }    label7.Text = Convert.ToString(a.Next(1, 17)); */         label1.Text = Convert.ToString(a.Next(1,34));    label2.Text = Convert.ToString(a.Next(1, 34));    label3.Text = Convert.ToString(a.Next(1, 34));    label4.Text = Convert.ToString(a.Next(1, 34));    label5.Text = Convert.ToString(a.Next(1, 34));    label6.Text = Convert.ToString(a.Next(1, 34));    label7.Text = Convert.ToString(a.Next(1, 17)); }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>效果如下<img src="双色球-1705156191295-3.gif" alt="" style="zoom: 33%;"></li></ul><h4 id="1-7-3-例程2-–-按键图片切换"><a href="#1-7-3-例程2-–-按键图片切换" class="headerlink" title="1.7.3 例程2 – 按键图片切换"></a>1.7.3 例程2 – 按键图片切换</h4><ul><li><p>具体代码文件见<code>D:\Program Files\Microsoft Visual Studio\projects\start\write2</code></p></li><li><p>每次按键，随机切换图片</p></li><li><p>在<code>debug</code>文件夹下新建一个<code>img</code>文件夹，并在其中存入<code>1-6.jpg</code></p></li><li><p>搭建界面如下</p><ul><li><img src="image-20231031180022076-1705156191295-5.png" alt="" style="zoom: 25%;"></li></ul></li><li><p>通过点击<code>button</code>按钮，触发<code>click</code>事件，产生随机数，导入图片到<code>pictureBox</code>展示</p></li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// button_click事件private void button2_Click(object sender, EventArgs e){    Random a = new Random();    double num = a.NextDouble();    // 产生1-6的数字    int picnum = Convert.ToInt32(Math.Floor(num*6) + 1);    // 图片载入    pictureBox1.SizeMode = PictureBoxSizeMode.StretchImage;        // 相对路径，默认路径为项目文件下的debug文件    pictureBox1.Image = Image.FromFile(@"img\" + picnum + ".jpg");}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>效果如下<img src="/2024/01/13/shang-wei-ji/%E6%8C%89%E9%94%AE%E5%9B%BE%E7%89%87%E5%88%87%E6%8D%A2-1705156191295-4.gif" alt="按键图片切换"></li></ul><h3 id="1-8-访问修饰符"><a href="#1-8-访问修饰符" class="headerlink" title="1.8 访问修饰符"></a>1.8 访问修饰符</h3><ul><li><p>所有的<strong>类型及其成员</strong>都具有可访问性级别</p></li><li><p><strong>程序集</strong>通过编译单个或多个<code>.cs</code>文件产生的<code>.dll</code>或<code>.exe</code></p></li><li><p><code>public</code>：同一程序集中的<strong>任何其他代码</strong>或引用该程序集的其他程序集<strong>都可访问该类型或成员</strong></p></li><li><p><code>private</code>：只有<strong>同一<code>class</code>或<code>struct</code>中的代码</strong>可以访问类型或成员</p></li><li><p><code>protected</code>：只有**同一<code>class</code>或从其派生出的<code>class</code>**可以访问</p></li><li><p><code>internal</code>：<strong>同一程序集中的任何代码</strong>均可访问，但外部程序集不行</p></li><li><p><code>protected internal</code>：本程序集中及其他程序集的派生<code>class</code></p></li><li><p><code>private protected</code>：在类内及本程序集派生类中可访问</p></li><li><p>访问修饰符摘要表</p><ul><li><img src="image-20231031224437966-1705156191295-6.png" alt="" style="zoom: 50%;"></li></ul></li></ul><h3 id="1-9-字段"><a href="#1-9-字段" class="headerlink" title="1.9 字段"></a>1.9 字段</h3><ul><li>什么是字段<ul><li>字段(field)是一种表示与对象或类型（类与结构体）相关联的变量</li><li>字段是类型的成员，也被称为“成员变量”</li><li>类型方法体内定义的变量属于局部变量，不是字段</li><li>分类<ul><li>实例字段：与实例化对象相关联的成员变量</li><li>静态字段：与类型相关联的成员变量，由<code>static</code>修饰</li></ul></li></ul></li></ul><h3 id="1-10-属性"><a href="#1-10-属性" class="headerlink" title="1.10 属性"></a>1.10 属性</h3><h2 id="二、控件及事件-–-B站刘金玉视频总结"><a href="#二、控件及事件-–-B站刘金玉视频总结" class="headerlink" title="二、控件及事件 – B站刘金玉视频总结"></a>二、控件及事件 – B站刘金玉视频总结</h2><h3 id="2-1-控件简介"><a href="#2-1-控件简介" class="headerlink" title="2.1 控件简介"></a>2.1 控件简介</h3><ul><li>所有的控件都是对象，对象三要素<strong>属性、方法、事件</strong></li><li>当控件从工具箱被拖到form窗体后，变成实例对象</li><li>控件分类<ul><li>公共控件：以表单为主</li><li>容器控件：界面布局使用，使界面干净整洁</li><li>菜单和工具栏控件</li><li>组件</li><li>打印控件</li><li>对话框控件</li><li>数据控件</li><li>WPF互操作性</li></ul></li><li>控件基本操作：点选控件 =&gt; 更改其属性</li></ul><h3 id="2-2-Form窗体"><a href="#2-2-Form窗体" class="headerlink" title="2.2 Form窗体"></a>2.2 Form窗体</h3><h4 id="2-2-1-基本介绍"><a href="#2-2-1-基本介绍" class="headerlink" title="2.2.1 基本介绍"></a>2.2.1 基本介绍</h4><ul><li><p><code>Form1.cs[设计]</code> 文件：可视化窗体界面</p></li><li><p><code>Form1.cs</code> 文件：后台代码界面</p></li><li><p><code>Form1.Designer.cs</code> 文件：具体窗体设计代码，其中方法被调用</p></li><li><p>Form窗体加载过程：</p><ul><li>项目起点，<code>Program.cs</code>中的<code>Main()</code>，创建Form实例</li><li>到<code>Form1.cs</code>中调用<code>InitializeComponent()</code>，初始化窗体界面</li><li>再到<code>Form1.Designer.cs</code>中执行相应代码，实现窗体和控件布局</li></ul></li></ul><h4 id="2-2-2-例程-–-Form窗体控制"><a href="#2-2-2-例程-–-Form窗体控制" class="headerlink" title="2.2.2 例程 – Form窗体控制"></a>2.2.2 例程 – Form窗体控制</h4><ul><li><p>具体代码文件见<code>D:\Program Files\Microsoft Visual Studio\projects\start\控件</code></p></li><li><p>以两按钮分别控制Form窗体背景颜色及标题</p></li><li><p>拖两个<code>Button</code>控件到<code>Form</code>窗体内，分别修改<code>Text</code>为：背景变色、换标题</p></li><li><p>分别双击创建相应<code>ButtonClick</code>事件，并自动跳转到<code>Form.cs</code>中生成相应方法</p></li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 背景变色private void button1_Click(object sender, EventArgs e){    // 注意ActiveForm，窗体必须是被激活的当前窗体，才能修改其属性    Form1.ActiveForm.BackColor = Color.AliceBlue;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 换标题private void button2_Click(object sender, EventArgs e){    Form1.ActiveForm.Text = "换标题";}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>效果如下<img src="form窗体控制-1705156191295-7.gif" alt="" style="zoom:33%;"></li></ul><h3 id="2-3-鼠标事件"><a href="#2-3-鼠标事件" class="headerlink" title="2.3 鼠标事件"></a>2.3 鼠标事件</h3><ul><li><p>具体代码文件见<code>D:\Program Files\Microsoft Visual Studio\projects\start\Mouse</code></p></li><li><p>以<code>PictureBox</code>显示本地图片，通过鼠标触发<code>Click、MouseClick、DoubleClick、MouseHover事件</code></p></li></ul><h4 id="2-3-1-PictureBox显示图片"><a href="#2-3-1-PictureBox显示图片" class="headerlink" title="2.3.1 PictureBox显示图片"></a>2.3.1 PictureBox显示图片</h4><ul><li>拖动该控件到<code>Form1</code>窗体内</li><li>找到<code>Image</code>属性，通过<code>...</code>导入本地图片即可</li></ul><h4 id="2-3-2-例程1-–-Click事件"><a href="#2-3-2-例程1-–-Click事件" class="headerlink" title="2.3.2 例程1 – Click事件"></a>2.3.2 例程1 – Click事件</h4><ul><li><p>任意<strong>单击</strong>事件，包括鼠标、键盘等</p></li><li><p>点击后通过<code>MessageBox</code>进行提示</p></li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 单击事件private void pictureBox1_Click(object sender, EventArgs e){    MessageBox.Show("Click事件");}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>效果如下<img src="Click事件-1705156191295-8.gif" alt="" style="zoom:33%;"></li></ul><h4 id="2-3-3-例程2-–-MouseClick事件"><a href="#2-3-3-例程2-–-MouseClick事件" class="headerlink" title="2.3.3 例程2 – MouseClick事件"></a>2.3.3 例程2 – MouseClick事件</h4><ul><li><strong>鼠标单击</strong>事件</li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">private void pictureBox1_MouseClick(object sender, MouseEventArgs e){    // e.Button.ToString()的取值分别为Left、Middle、Right，为鼠标三个按键    // 可用于条件判断    MessageBox.Show(e.Button.ToString());}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>效果如下<img src="/2024/01/13/shang-wei-ji/MouseClick%E4%BA%8B%E4%BB%B6-1705156191295-9.gif" alt="MouseClick事件"></li></ul><h4 id="2-3-4-例程3-–-DoubleClick事件"><a href="#2-3-4-例程3-–-DoubleClick事件" class="headerlink" title="2.3.4 例程3 – DoubleClick事件"></a>2.3.4 例程3 – DoubleClick事件</h4><ul><li><p>任意<strong>双击</strong>事件（双击包含单击事件，当同时存在单击事件时，只触发单击事件）</p></li><li><p>同样通过<code>MessageBox</code>提示</p></li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">private void pictureBox1_DoubleClick(object sender, EventArgs e){    MessageBox.Show("DoubleClick事件");}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li>效果如下<img src="DoubleClick事件-1705156191295-10.gif" alt="DoubleClick事件" style="zoom:33%;"></li></ul><h4 id="2-3-5-例程4-–-MouseHover事件"><a href="#2-3-5-例程4-–-MouseHover事件" class="headerlink" title="2.3.5 例程4 – MouseHover事件"></a>2.3.5 例程4 – MouseHover事件</h4><ul><li>当鼠标移动到上方时触发</li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">private void pictureBox1_MouseHover(object sender, EventArgs e){    MessageBox.Show("MouseHover事件");}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li>效果如下<img src="MouseHover事件-1705156191295-11.gif" alt="" style="zoom:33%;"></li></ul><h3 id="2-4-多窗体"><a href="#2-4-多窗体" class="headerlink" title="2.4 多窗体"></a>2.4 多窗体</h3><h4 id="2-4-1-创建启动窗体"><a href="#2-4-1-创建启动窗体" class="headerlink" title="2.4.1 创建启动窗体"></a>2.4.1 创建启动窗体</h4><ul><li>创建一个登录界面，点击登陆后（此处不对账号密码进行判断），跳转界面</li><li>登录界面<code>Form1</code>如下图所示<ul><li><img src="image-20231029181612428-1705156191295-12.png" alt="" style="zoom: 50%;"></li></ul></li></ul><h4 id="2-4-2-创建跳转窗体"><a href="#2-4-2-创建跳转窗体" class="headerlink" title="2.4.2 创建跳转窗体"></a>2.4.2 创建跳转窗体</h4><ul><li>跳转窗体界面<code>Form2</code>如下图所示<ul><li><img src="image-20231029182144541-1705156191295-13.png" alt="" style="zoom: 50%;"></li></ul></li></ul><h4 id="2-4-3-跳转"><a href="#2-4-3-跳转" class="headerlink" title="2.4.3 跳转"></a>2.4.3 跳转</h4><ul><li><p>具体代码文件见<code>D:\Program Files\Microsoft Visual Studio\projects\start\MutipleForm</code></p></li><li><p>点击启动界面的<code>登录</code>按钮后，跳转到新窗体</p></li></ul><h5 id="2-4-3-1-例程1-–-跳转-不关闭原窗口"><a href="#2-4-3-1-例程1-–-跳转-不关闭原窗口" class="headerlink" title="2.4.3.1 例程1 – 跳转-不关闭原窗口"></a>2.4.3.1 例程1 – 跳转-不关闭原窗口</h5><ul><li>双击<code>Form1</code>登录按钮，生成<code>Click</code>事件</li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 登录弹窗private void button2_Click(object sender, EventArgs e){    Form2 f2 = new Form2();    f2.Show();}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>实现效果如下图，此时，关闭<code>Form1</code>，<code>Form2</code>也自动关闭（因为<code>Form2</code>在<code>Form1</code>类内部生成，视作<code>Form1</code>窗体的一部分）；反之需逐一关闭<img src="/2024/01/13/shang-wei-ji/%E8%B7%B3%E8%BD%AC-%E4%B8%8D%E5%85%B3%E9%97%AD%E5%8E%9F%E7%AA%97%E5%8F%A3-1705156191295-14.gif" alt="跳转-不关闭原窗口"></li></ul><h5 id="2-4-3-2-例程2-–-跳转-隐藏原窗口"><a href="#2-4-3-2-例程2-–-跳转-隐藏原窗口" class="headerlink" title="2.4.3.2 例程2 – 跳转-隐藏原窗口"></a>2.4.3.2 例程2 – 跳转-隐藏原窗口</h5><ul><li><p>隐藏窗口后，该窗口仍然占据内存空间，正常运行，需通过任务管理器进行关闭！！！</p></li><li><p>修改<code>button2_Click</code>方法</p></li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">private void button2_Click(object sender, EventArgs e){    Form2 f2 = new Form2();    f2.Show();        // 因为button2_Click()方法在类Form1内，所以以下两种方法皆可，都是对Form1窗口进行隐藏    this.Hide();    // Hide();}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>效果如下<img src="跳转-隐藏原窗口-1705156191295-15.gif" alt="" style="zoom:33%;"></li></ul><h5 id="2-4-3-3-例程3-–-跳转-关闭原窗口"><a href="#2-4-3-3-例程3-–-跳转-关闭原窗口" class="headerlink" title="2.4.3.3 例程3 – 跳转-关闭原窗口"></a>2.4.3.3 例程3 – 跳转-关闭原窗口</h5><ul><li><p>扩展</p><ul><li><p>窗体<code>ShowDialog()</code>方法，默认使用模态方式</p></li><li><p>模态：以当前窗体为焦点，不能点击该程序的其他窗体</p></li></ul></li></ul><p><strong>（1）委托线程</strong></p><ul><li><p>首先在<code>Form1.cs</code>导入命名空间<code>using System.Threading;</code></p></li><li><p>接着修改<code>button2_Click()</code></p></li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">private void button2_Click(object sender, EventArgs e){    Form2 f2 = new Form2();    //f2.Show();    //this.Hide();    // 委托一个线程去显示新窗体    Thread t1 = new Thread(delegate () { f2.ShowDialog(); });    // 开启线程    t1.Start();    Close();}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>效果如下<img src="跳转-关闭原窗口-委托线程-1705156191295-16.gif" alt="" style="zoom:33%;"></li></ul><p><strong>（2）Application.Run()方法</strong></p><ul><li>通过在<code>Program.cs</code>启动文件中建立标志变量监测第一个窗口关闭，之后打开<code>Form2</code></li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// Program.cs文件 Prigram类internal static class Program {     // 定义标志变量flag     public static bool flag = false;     /// &lt;summary&gt;     /// 应用程序的主入口点。     /// &lt;/summary&gt;     [STAThread]     static void Main()     {         Application.EnableVisualStyles();         Application.SetCompatibleTextRenderingDefault(false);         Application.Run(new Form1());                  // 当原窗口被关闭，flag==true时，打开新窗口         if (flag)         {             Application.Run(new Form2());         }     } }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// Form1.cs文件中方法 button2_Click()private void button2_Click(object sender, EventArgs e){    // 因为flag定义在Program类中，所以重新赋值时，需要加上前缀Program.flag    Program.flag = true;    // 关闭Form1    Close();}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>效果如下<img src="/2024/01/13/shang-wei-ji/%E8%B7%B3%E8%BD%AC-%E5%85%B3%E9%97%AD%E5%8E%9F%E7%AA%97%E5%8F%A3-Application.Run()%E6%96%B9%E6%B3%95.gif" alt="跳转-关闭原窗口-Application.Run(./../../../../Typora/Projects/上位机/assets/跳转-关闭原窗口-Application.Run()方法.gif)方法"></li></ul><h3 id="2-5-复选框及复选框列表"><a href="#2-5-复选框及复选框列表" class="headerlink" title="2.5 复选框及复选框列表"></a>2.5 复选框及复选框列表</h3><ul><li><code>CheckBox</code>复选框控件</li><li><code>CheckBoxList</code>复选框列表控件：内含多个复选框控件（需要自行配置）</li></ul><h4 id="2-5-1-CheckBox控件"><a href="#2-5-1-CheckBox控件" class="headerlink" title="2.5.1 CheckBox控件"></a>2.5.1 CheckBox控件</h4><ul><li><p>图例：<img src="image-20231030181830622-1705156191295-17.png" alt="" style="zoom:50%;"></p></li><li><p><code>CheckBox.Checked</code>属性：获取该复选框有没有被勾选</p></li><li><p><code>CheckBox.Text</code>属性：获取该复选框文本内容</p></li></ul><h4 id="2-5-2-CheckBoxList控件"><a href="#2-5-2-CheckBoxList控件" class="headerlink" title="2.5.2 CheckBoxList控件"></a>2.5.2 CheckBoxList控件</h4><ul><li>选择时，首先会定位，然后才能选中</li><li><code>CheckBoxList.SelectItem</code>属性：获取当前选中项</li><li><code>checkedListBox.Items.Add(string)</code>：<strong>动态添加</strong>选项</li><li><code>checkedListBox.Items.Remove</code>：<strong>动态删除</strong>选项</li><li><code>ItemCheck</code>事件：当复选框被勾选时触发</li><li><code>SelectedIndexChanged</code>事件：未勾选选项，选中选项标题时就会触发</li></ul><h3 id="2-6-时钟"><a href="#2-6-时钟" class="headerlink" title="2.6 时钟"></a>2.6 时钟</h3><ul><li><p>时间单位<code>ms</code></p></li><li><p>作用：对有规律的事物进行输出，每隔指定时间，对一程序进行输出</p></li><li><p><code>Timer</code>配置</p><ul><li><p>配置时间，<code>Interval</code>属性</p></li><li><p>是否启动，<code>Enabled</code>属性</p></li><li><p>配置事件，<code>Tick</code>事件，在其中执行相应事件</p></li></ul></li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// Enable后，每隔Interval时间，执行一次Tick事件private void timer1_Tick(object sender, EventArgs e){    // 通过label控件，将当前时间显示在窗口，并每隔Interval时间刷新一下    label1.Text = DateTime.Now.ToString();}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-7-图片"><a href="#2-7-图片" class="headerlink" title="2.7 图片"></a>2.7 图片</h3><h4 id="2-7-1-PictureBox控件"><a href="#2-7-1-PictureBox控件" class="headerlink" title="2.7.1 PictureBox控件"></a>2.7.1 PictureBox控件</h4><ul><li><p><code>PictureBox</code>控件</p></li><li><p><code>Picture.SizeMode</code>属性，更改图片显示拉伸情况</p></li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 将图片设置为自动拉伸，大小随展示图片框变化pictureBox1.SizeMode = PictureBoxSizeMode.StretchImage;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li><code>PictureBox.Image</code>属性，导入图片</li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 传入图片例子PictureBox.Image = Image.FromFile("图片位置");// Application.StartupPath，位置为xx\bin\debugPictureBox.Image = Image.FromFile(Application.StartupPath + @"\自建图片位置");<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p><strong>图片位置坐标</strong></p><ul><li><p><code>PictureBox.Left</code>属性，int类型，为控件左边缘与form窗体左边缘的<strong>像素距离</strong>，即可代表**<code>x</code>坐标**的值</p></li><li><p><code>PictureBox.Top</code>属性，控件上边缘与Form窗体上边缘的像素距离，代表**<code>y</code>坐标**的值</p><ul><li>（x, y）坐标为图片左上角顶点坐标，<strong>xy轴方向同图像坐标</strong></li></ul></li></ul></li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 使用时钟控件，实现图片的自动水平移动private void timer1_Tick(object sender, EventArgs e){  // enable时钟后，随interval时间间隔改变图片x坐标  pictureBox1.Left += 1;  // 改变图片y坐标  pictureBox1.Top += 1;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-7-2-例程1-–-猫咪避障"><a href="#2-7-2-例程1-–-猫咪避障" class="headerlink" title="2.7.2 例程1 – 猫咪避障"></a>2.7.2 例程1 – 猫咪避障</h4><ul><li><p>具体代码文件见<code>D:\Program Files\Microsoft Visual Studio\projects\start\plane</code></p></li><li><p>通过使用<code>MouseDown、MouseUp、MouseMove</code>三个事件，实现鼠标拖动猫咪避障</p></li><li><p>首先定外部变量</p></li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 标志变量记录鼠标左键是否按下bool flag = false;// 图片初始坐标int oldX = 0;int oldY = 0;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>当鼠标左键在图片中被按下时，获取当前鼠标坐标，并作为图片初始移动坐标</li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">private void pictureBox1_MouseDown(object sender, MouseEventArgs e){    // 当被按下的键为鼠标左键时执行    if(e.Button == MouseButtons.Left)    {        flag = true;        oldX = e.X;        oldY = e.Y;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>当鼠标左键抬起时，置<code>flag</code>变量为<code>false</code>，停止鼠标拖动图片移动</li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">private void pictureBox1_MouseUp(object sender, MouseEventArgs e){    if (e.Button == MouseButtons.Left)    {        flag = false;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>当鼠标左键被按下并移动时，更新图片坐标</li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">private void pictureBox1_MouseMove(object sender, MouseEventArgs e){    if (flag)    {        // 更新xy坐标        // 拖动的效果是连续的，因为每当鼠标移动1个像素，图片立即就进行相应移动        // 所以从视觉上来看是连续的，非卡顿的        pictureBox1.Left += e.X - oldX;        pictureBox1.Top += e.Y - oldY;    }    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>效果如下<img src="/2024/01/13/shang-wei-ji/%E7%8C%AB%E5%92%AA%E9%81%BF%E9%9A%9C-1705156191295-18.gif" alt="猫咪避障"></li></ul><h4 id="2-7-3-例程2-–-画布软件"><a href="#2-7-3-例程2-–-画布软件" class="headerlink" title="2.7.3 例程2 – 画布软件"></a>2.7.3 例程2 – 画布软件</h4><ul><li><p>具体代码文件见<code>D:\Program Files\Microsoft Visual Studio\projects\start\draw</code></p></li><li><p>同样使用<code>MouseDown、MouseUp、MouseMove、ButtonClick</code>事件实现复制粘贴图片、画笔绘图操作</p></li><li><p>搭建界面如图</p><ul><li><img src="image-20231101163806614-1705156191295-19.png" alt="" style="zoom: 50%;"></li></ul></li><li><p>首先定义全局变量</p></li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 定义图片对象Image curImg;// 记录鼠标第一次点击bool moving = false;// 定义图片尺寸int curImgWidth = 0;int curImgHeight = 0;// 记录画笔颜色Color curColor;// 是否使用画笔bool usePen = false;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>当已有的两张图片被点击，获取该图片路径及尺寸，并把<code>usePen</code>置为<code>false</code></li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 第一张图的MouseDown事件private void pictureBox1_MouseDown(object sender, MouseEventArgs e){    curImg = Image.FromFile(@"img\1.jpg");    curImgWidth = pictureBox1.Width;    curImgHeight = pictureBox1.Height;        // 为避免在图片粘贴时，同步产生画笔绘制效果，将usePen置为false    usePen = false;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 第二张图MouseDown事件private void pictureBox2_MouseDown(object sender, MouseEventArgs e){    curImg = Image.FromFile(@"img\2.jpg");    curImgWidth = pictureBox2.Width;    curImgHeight = pictureBox2.Height;    usePen = false;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>当<code>使用画笔</code>按钮被按下后，弹出颜色选框，并设定画笔颜色</li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// "使用画笔"按钮，click事件private void button1_Click(object sender, EventArgs e){    // colorDialog控件    // colorDialog1.ShowDialog()，开启颜色选框，返回颜色选择状态    // 如果选择完毕，返回ok    if (colorDialog1.ShowDialog() == DialogResult.OK)    {        // 将当前选中的颜色赋值给curColor对象        curColor = colorDialog1.Color;        // 画笔绘制时，将要粘贴的图片对象置空，避免粘贴图片与画笔绘制冲突        curImg = null;        // 将画笔标志变量置为true        usePen = true;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>对于画布，分别处理<code>MouseDown、MouseUp、MouseMOve</code>事件</li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// MouseDown事件private void pictureBox3_MouseDown(object sender, MouseEventArgs e){    moving = true;    // 创建绘制功能    Graphics g = pictureBox3.CreateGraphics();    // 当图片没有装载的时候，默认值为null        if(curImg == null &amp;&amp; usePen == false)    {        MessageBox.Show("没有点选图片或画笔");        return;    }    if(curImg != null &amp;&amp; usePen == false)    {        // 在xy坐标位置绘制图片，贴图        g.DrawImage(curImg, e.X - curImgWidth / 2, e.Y - curImgHeight / 2, curImgWidth, curImgHeight);    }    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// MouseUp事件private void pictureBox3_MouseUp(object sender, MouseEventArgs e){    moving = false;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// MouseMove事件private void pictureBox3_MouseMove(object sender, MouseEventArgs e){    if (moving &amp;&amp; usePen)    {        // 创建画布功能        Graphics g = pictureBox3.CreateGraphics();        // 画图前必须要先创建画笔        // 构造函数参数是要设置的 画笔颜色        Pen pen = new Pen(curColor);        g.DrawEllipse(pen,e.X,e.Y,2,2);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>对于<code>清空画布</code>按钮，将背景填充为白色即可</li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// "清空画布"按钮private void button2_Click(object sender, EventArgs e){    // 清空画布，填充白色    pictureBox3.CreateGraphics().Clear(Color.White);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>效果如下<img src="/2024/01/13/shang-wei-ji/%E7%94%BB%E5%9B%BE%E8%BD%AF%E4%BB%B6-1705156191296-20.gif" alt="画图软件"></li></ul><h3 id="2-8、Chart图表控件"><a href="#2-8、Chart图表控件" class="headerlink" title="2.8、Chart图表控件"></a>2.8、Chart图表控件</h3><h4 id="2-8-1-界面布局"><a href="#2-8-1-界面布局" class="headerlink" title="2.8.1 界面布局"></a>2.8.1 界面布局</h4><ul><li><code>Tablelayout</code>容器控件</li><li>每个单元格默认放置一个控件</li><li>更好地规划界面</li></ul><h4 id="2-8-2-图表界面简介"><a href="#2-8-2-图表界面简介" class="headerlink" title="2.8.2 图表界面简介"></a>2.8.2 图表界面简介</h4><ul><li><code>Chart</code>控件</li><li>关键属性的配置，如标题、坐标系、图例</li></ul><h4 id="2-8-3-例程-–-图像绘制"><a href="#2-8-3-例程-–-图像绘制" class="headerlink" title="2.8.3 例程 – 图像绘制"></a>2.8.3 例程 – 图像绘制</h4><ul><li>具体代码文件见<code>D:\Program Files\Microsoft Visual Studio\projects\start\chart</code></li></ul><h5 id="2-8-3-1-界面布局"><a href="#2-8-3-1-界面布局" class="headerlink" title="2.8.3.1 界面布局"></a>2.8.3.1 界面布局</h5><ul><li>在Form内，任意放置容器控件<code>TableLayoutPanel</code></li><li>修改属性<code>Dock</code>，填充方式，此处选用<code>Fill</code>，如下图所示<ul><li><img src="image-20231028175453329-1705156191296-21.png" alt="" style="zoom: 25%;"></li></ul></li></ul><h5 id="2-8-3-2-插入图形界面"><a href="#2-8-3-2-插入图形界面" class="headerlink" title="2.8.3.2 插入图形界面"></a>2.8.3.2 插入图形界面</h5><ul><li>在<code>TableLayoutPanel</code>任一单元格内放置<code>Chart</code>图形控件</li><li>同样修改填充属性<code>Dock</code>，全填充<code>Fill</code>，效果如图<ul><li><img src="image-20231028180056717-1705156191296-22.png" alt="" style="zoom: 25%;"></li></ul></li></ul><h6 id="2-8-3-2-1-图表类属性-Titels"><a href="#2-8-3-2-1-图表类属性-Titels" class="headerlink" title="2.8.3.2.1 图表类属性-Titels"></a>2.8.3.2.1 图表类属性-Titels</h6><ul><li><p>点击<code>...</code>打开<code>Titles</code>集合编辑器</p><ul><li><img src="image-20231028181107970-1705156191296-23.png" alt="" style="zoom:25%;"></li></ul></li><li><p>添加成员（可添加多个，即显示出来的图像会有相应个数的标题）</p><ul><li>成员属性<code>Text</code>：设置标题名称</li><li>成员属性<code>ToolTip</code>：设置提示消息，当用户鼠标放置在图形标题名称上时</li></ul></li></ul><h6 id="2-8-3-2-2-图标类属性-Series"><a href="#2-8-3-2-2-图标类属性-Series" class="headerlink" title="2.8.3.2.2 图标类属性-Series"></a>2.8.3.2.2 图标类属性-Series</h6><ul><li><p>可设置图像类型，如条形图、曲线图、扇形图</p></li><li><p>同样点击<code>...</code>打开<code>Series</code>集合编辑器</p><ul><li><img src="image-20231028182104785-1705156191296-24.png" alt="" style="zoom: 25%;"></li></ul></li><li><p>添加成员（每添加一个，显示图形上就会产生一个新的图例）</p><ul><li>成员属性<code>ChartType</code>：设置图像类型，如：<code>Column</code>、<code>Spline</code>、<code>Pie</code>等</li></ul></li></ul><h6 id="2-8-3-2-3-图标类属性-Legends"><a href="#2-8-3-2-3-图标类属性-Legends" class="headerlink" title="2.8.3.2.3 图标类属性-Legends"></a>2.8.3.2.3 图标类属性-Legends</h6><h5 id="2-8-3-3-数据传入"><a href="#2-8-3-3-数据传入" class="headerlink" title="2.8.3.3 数据传入"></a>2.8.3.3 数据传入</h5><ul><li>主要函数<code>chart1.Series[0].Points.Add(数据序列);</code></li></ul><h6 id="2-8-3-3-1-Form窗体Load事件"><a href="#2-8-3-3-1-Form窗体Load事件" class="headerlink" title="2.8.3.3.1 Form窗体Load事件"></a>2.8.3.3.1 Form窗体Load事件</h6><ul><li><p>使用<code>Form</code>窗体<code>Load</code>事件（窗体加载完成时，就绘制好图线）</p></li><li><p>双击<code>Load</code>事件，在<code>Form1_Load</code>方法中随机产生10个数据，窗体加载完成就绘制出完整图形</p></li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">private void Form1_Load(object sender, EventArgs e){Random rnd = new Random();    for (int i = 0; i &lt; 10; i++)    {        //Random rnd = new Random();        // 给图表传入数据        chart1.Series[0].Points.Add(rnd.Next(0, 101));    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h6 id="2-8-3-3-2-Timer组件"><a href="#2-8-3-3-2-Timer组件" class="headerlink" title="2.8.3.3.2 Timer组件"></a>2.8.3.3.2 Timer组件</h6><ul><li><p>行为属性<code>Enable</code>：启动<code>timer</code>计时，必须设置为<code>True</code>才会启动</p></li><li><p>行为属性<code>Interval</code>：时间间隔，单位ms，此例设置为500</p></li><li><p>双击<code>Timer</code>组件，<code>timer1_Tick</code>中每隔500ms产生一个随机数，并绘制到图形上</p></li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">private void timer1_Tick(object sender, EventArgs e){    /*    // 若只显示最新的10个点    if (chart1.Series[0].Points.Count() == 10)    {        // 当存在10个数据时，移除第一个点        chart1.Series[0].Points.RemoveAt(0);    }    */        Random rnd = new Random();    chart1.Series[0].Points.Add(rnd.Next(0, 101));}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h6 id="2-8-3-3-3-数据点取值可视化"><a href="#2-8-3-3-3-数据点取值可视化" class="headerlink" title="2.8.3.3.3 数据点取值可视化"></a>2.8.3.3.3 数据点取值可视化</h6><ul><li><p>在<code>Timer</code>组件基础上进行代码的修改</p></li><li><p>首先引入<code>using System.Windows.Forms.DataVisualization.Charting; </code></p></li><li><p>修改代码如下</p></li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">private void timer1_Tick(object sender, EventArgs e){    // 若只显示最新的10个点    if (chart1.Series[0].Points.Count() == 10)    {        // 当存在10个数据时，移除第一个点        chart1.Series[0].Points.RemoveAt(0);    }    Random rnd = new Random();    int curnum = rnd.Next(0, 101);        // 创建数据点对象    DataPoint dp1 = new DataPoint();    // 通过double[] 为数据点传入y值    dp1.YValues = new double[] { curnum };    // 定义数据点标签    dp1.Label = curnum.ToString();    chart1.Series[0].Points.Add(dp1);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="2-8-3-4-同数据-多图展示"><a href="#2-8-3-4-同数据-多图展示" class="headerlink" title="2.8.3.4 同数据-多图展示"></a>2.8.3.4 同数据-多图展示</h5><ul><li>在6.3.3.3代码基础上修改，通过for循环同时绘制4个图表</li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">private void timer1_Tick(object sender, EventArgs e){    for (int i = 1;i &lt;= 4;i++)    {        // 在tableLayoutPanel1中找到图表控件，并取返回的同名子控件（find参数要设置为true）数组的第一个，转换为Chart类型        Chart myChart = tableLayoutPanel1.Controls.Find("chart" + i.ToString(), true)[0] as Chart;                // 若只显示最新的10个点        if (myChart.Series[0].Points.Count() == 10)        {            // 当存在10个数据时，移除第一个点            myChart.Series[0].Points.RemoveAt(0);        }        Random rnd = new Random();        int curnum = rnd.Next(0, 11);        DataPoint dp1 = new DataPoint();        dp1.YValues = new double[] { curnum };            dp1.Label = curnum.ToString();        myChart.Series[0].Points.Add(dp1);    }    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>效果如下<img src="/2024/01/13/shang-wei-ji/chart%E5%9B%BE%E8%A1%A8-1705156191296-25.gif" alt="chart图表"></li></ul><h3 id="2-9-右键菜单及打开文件对话框"><a href="#2-9-右键菜单及打开文件对话框" class="headerlink" title="2.9 右键菜单及打开文件对话框"></a>2.9 右键菜单及打开文件对话框</h3><h4 id="2-9-1-右键菜单"><a href="#2-9-1-右键菜单" class="headerlink" title="2.9.1 右键菜单"></a>2.9.1 右键菜单</h4><ul><li>使用控件<code>ContexMenuStrip</code>，设置好菜单选项</li><li><code>Form窗体、PictureBox等控件</code>，有个<code>ContextMenuStrip</code>行为属性，可在控件内启用相应的右键菜单功能</li><li>设置好的<strong>每一个菜单选项，都是一个子控件</strong>，拥有自己的属性方法及触发事件</li></ul><h4 id="2-9-2-打开文件对话框"><a href="#2-9-2-打开文件对话框" class="headerlink" title="2.9.2 打开文件对话框"></a>2.9.2 打开文件对话框</h4><ul><li>使用控件<code>openFileDialog</code><ul><li><code>openFileDialog.Title</code>属性，设置对话框<strong>标题</strong></li><li><code>openFileDialog.Filter</code>属性，设置文件<strong>类型过滤</strong></li><li><code>openFileDialog.InitialDirectory</code>属性，设置文件对话框<strong>打开初始路径</strong></li><li><code>openFileDialog.ShowDialog()</code>方法，<strong>打开文件对话框</strong></li><li><code>openFileDialog.FileName</code>属性，返回打开文件的<strong>绝对路径</strong></li></ul></li></ul><h4 id="2-9-3-例程-–-右键菜单更换图片"><a href="#2-9-3-例程-–-右键菜单更换图片" class="headerlink" title="2.9.3 例程 – 右键菜单更换图片"></a>2.9.3 例程 – 右键菜单更换图片</h4><ul><li><p><code>具体代码文件见D:\Program Files\Microsoft Visual Studio\projects\start\RightMenu</code></p></li><li><p>界面设计如下</p><ul><li><img src="image-20231101190346048-1705156191296-26.png" alt="" style="zoom: 50%;"></li></ul></li><li><p>首先设置右键菜单选项，并在<code>Form</code>窗体属性中设置<code>ContextMenuStrip</code>为定义好的<code>右键菜单控件名</code></p></li><li><p>对于右键菜单第一个选项<code>你干嘛</code>，单击该选项，并创建<code>click</code>事件</p></li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 当"你干嘛"选项被选中后，触发该click事件，通过messageBox打印相应语句private void 你干嘛ToolStripMenuItem_Click(object sender, EventArgs e){    MessageBox.Show("你干嘛小黑子");}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>对于第二个选项<code>换背景</code>，同样创建<code>click</code>事件</li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">private void 换背景ToolStripMenuItem_Click(object sender, EventArgs e){    // 设置文件选框标题    openFileDialog1.Title = "请选择一张图片";    // 文件类型过滤    // 配置格式：文件说明|文件扩展名    // 同种类型文件，用分号隔开    openFileDialog1.Filter = "图片文件(*.bmp;*.jpg;*.png;*.jepg;*.gif)|*.bmp;*.jpg;*.png;*.jepg;*.gif|任意类型(*.*)|*.*";    // 选框默认打开路径为前一次文件位置    // 可对选框打开文件位置进行默认设置    // openFileDialog1.InitialDirectory = Application.StartupPath;    // 当文件成功被选择    if(openFileDialog1.ShowDialog() == DialogResult.OK)    {        pictureBox1.SizeMode = PictureBoxSizeMode.StretchImage;        // 将选择的文件绝对路径传给pictureBox进行展示        pictureBox1.Image = Image.FromFile(openFileDialog1.FileName);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>效果展示<img src="右键菜单更换图片-1705156191296-27.gif" alt="" style="zoom: 33%;"></li></ul><h3 id="2-10-（本节因没有本地用户和组，无法进行操作学习！！！！）"><a href="#2-10-（本节因没有本地用户和组，无法进行操作学习！！！！）" class="headerlink" title="2.10 （本节因没有本地用户和组，无法进行操作学习！！！！）"></a>2.10 （本节因没有本地用户和组，无法进行操作学习！！！！）</h3><h4 id="2-10-1-下拉列表"><a href="#2-10-1-下拉列表" class="headerlink" title="2.10.1 下拉列表"></a>2.10.1 下拉列表</h4><ul><li><code>ComboBox</code>控件，下拉列表<ul><li><code>ComboBox.DropDownStyle</code>属性，设置下拉列表样式，可用取值分别为</li><li><code>ComboBox.Items.Add()</code>方法，添加项</li><li><code>ComboBox.Items.Contains()</code>，判断当前下拉框是否包含指定项</li><li><code>ComboBox.Text</code>属性，获取当前选中项文本</li><li><code>ComboBox.Items.Remove()</code>方法，删除指定项</li></ul></li></ul><h4 id="2-10-2"><a href="#2-10-2" class="headerlink" title="2.10.2"></a>2.10.2</h4><ul><li><code>directoryEntry</code>控件</li></ul><h3 id="2-11-系统语音功能及日期时间"><a href="#2-11-系统语音功能及日期时间" class="headerlink" title="2.11 系统语音功能及日期时间"></a>2.11 系统语音功能及日期时间</h3><h4 id="2-11-1-语音功能"><a href="#2-11-1-语音功能" class="headerlink" title="2.11.1 语音功能"></a>2.11.1 语音功能</h4><ul><li>本质上是调用系统的<code>tts</code>功能（将<strong>文本转为语音</strong>的功能，<code>tts</code>在<code>com</code>组件中有）</li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 核心代码Type type = Type.GetTypeFromProgID("SAPI.SpVoice");dynamic spVoice = Activator.CreateInstance(type);spVoice.Speak("Text To Speech 语音朗读文本技术");<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-11-2-日期时间"><a href="#2-11-2-日期时间" class="headerlink" title="2.11.2 日期时间"></a>2.11.2 日期时间</h4><ul><li><p><code>dateTimePicker</code>控件</p><ul><li><p><code>Format</code>属性，设置日期格式</p></li><li><p><code>CustomFormat</code>属性，当<code>Format</code>设置为<code>Custom</code>自定义格式时，可自行设日期时间格式，如</p></li></ul></li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 设置为以下格式yyyy年MM月dd日 HH:mm:ss<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="2-11-3-例程-–-个性语音闹钟"><a href="#2-11-3-例程-–-个性语音闹钟" class="headerlink" title="2.11.3 例程 – 个性语音闹钟"></a>2.11.3 例程 – 个性语音闹钟</h4><ul><li><p><code>具体代码文件见D:\Program Files\Microsoft Visual Studio\projects\start\Voice</code></p></li><li><p>搭建界面如下</p><ul><li><img src="image-20231102112708004-1705156191296-28.png" alt="" style="zoom: 50%;"></li></ul></li><li><p>当按下<code>添加闹钟</code>按钮后，将<code>dateTimePicker</code>的日期时间及<code>textBox</code>中的自定义事件分别存储到<code>listBox</code>中</p></li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">private void button1_Click(object sender, EventArgs e){    // 必须使用Value属性，不能使用Text，不然没有反应！！！    listBox1.Items.Add(dateTimePicker1.Value);    listBox2.Items.Add(textBox1.Text);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>接着，在界面内添加一个<code>timer</code>时钟控件，设置默认状态<code>enable</code>为启动</p></li><li><p>程序开始运行，<code>timerTick</code>事件，不断读取<code>listBox1</code>中的时间，当其与当前系统时间一致时，启动语音模块，并朗读事件，之后删除该闹钟事件</p></li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">private void timer1_Tick(object sender, EventArgs e){    // 遍历listBox1中的时间    for(int i = 0; i &lt; listBox1.Items.Count; i++)    {        // 找到预设闹钟时间        if (listBox1.Items[i].ToString() == DateTime.Now.ToString())        {            // 执行语音            // 找到语音模块            Type t = Type.GetTypeFromProgID("SAPI.SpVoice");            // 创建语音实例            // dynamic 动态进行类型转换，可规避语法错误            dynamic mySp = Activator.CreateInstance(t);            // 语音外放            mySp.Speak(listBox2.Items[i].ToString());            // 删除闹钟事件            listBox1.Items.RemoveAt(i);            listBox2.Items.RemoveAt(i);            return;        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>效果如下</p><ul><li><video src="./video/个性语音闹钟.mp4"></video></li></ul></li></ul><h3 id="2-12-列表视图"><a href="#2-12-列表视图" class="headerlink" title="2.12 列表视图"></a>2.12 列表视图</h3><h4 id="2-12-1-comboBox、listBox、listView的区别"><a href="#2-12-1-comboBox、listBox、listView的区别" class="headerlink" title="2.12.1 comboBox、listBox、listView的区别"></a>2.12.1 comboBox、listBox、listView的区别</h4><ul><li><code>comboBox</code>控件：下拉列表，有下拉、滚动条、下拉+输入三种模式</li><li><code>listBox</code>控件：单行项目记录</li><li><code>listView</code>控件：简单的项目行，表格的感觉</li></ul><h4 id="2-12-2-配置listView"><a href="#2-12-2-配置listView" class="headerlink" title="2.12.2 配置listView"></a>2.12.2 配置listView</h4><ul><li><code>Columns</code>属性：设置列标题<ul><li>添加成员后通过<code>Text</code>设置<strong>列标题</strong>名</li><li>同时通过<code>TextAlign</code>设置居中状态</li></ul></li><li><code>view</code>属性：调整视图模式<ul><li><code>details</code>可在构建界面时展示出列表情况，如列标题</li></ul></li><li><code>Items</code>属性：<ul><li><code>Text</code>设置当前行第一个单元格名称（<strong>行标题</strong>）</li><li><code>SubItems</code>设置第二个及其之后单元格</li><li><code>ImageIndex</code>属性，配置图表，使用<code>SmallImageList</code>中的图片<ul><li>使用前先要将<code>imageList</code>控件拖到<code>Form</code>窗体中，并通过<code>Images</code>属性导入图片</li></ul></li></ul></li></ul><h4 id="2-12-3-例程1-–-表格记录软件"><a href="#2-12-3-例程1-–-表格记录软件" class="headerlink" title="2.12.3 例程1 – 表格记录软件"></a>2.12.3 例程1 – 表格记录软件</h4><ul><li><p><code>具体代码文件见D:\Program Files\Microsoft Visual Studio\projects\start\listView</code></p></li><li><p>界面搭建如下</p><ul><li><img src="image-20231102185842982-1705156191296-29.png" alt="" style="zoom: 50%;"></li></ul></li><li><p><code>imageList</code>要与<code>ListView</code>关联起来</p></li><li><p>首先是<code>添加</code>按键，在<code>textBox</code>中输入文本后，添加进表格</p></li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// "添加"按键事件private void button1_Click(object sender, EventArgs e){    // 添加一行Item    // new ListViewItem()的参数分别为每一单元格的Text数组，和ImageList索引    // listView1.Items.Add(new ListViewItem(new string[] {"1","2","3","4"}, 2));    // 输入添加    listView1.Items.Add(new ListViewItem(new string[] { textBox1.Text, textBox2.Text, textBox3.Text, textBox4.Text }, 2));    // 鼠标单击选中后，修改已有单元格}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>对于<code>修改</code>按键，鼠标选中某一行后，将改行文本显示在<code>textBox</code>中，修改文本过后，更新表格</li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 外部变量，选中对象索引int ind = -1;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 鼠标选中任意行显示到textBoxprivate void listView1_SelectedIndexChanged(object sender, EventArgs e){    // 当选中对象不为空    if (listView1.SelectedItems.Count != 0)    {        // 获取最新选择对象在listview1中的索引        ind = listView1.SelectedIndices[0];        // 将当前listview中被点击的行名称显示到textBox        textBox1.Text = listView1.Items[ind].SubItems[0].Text;        textBox2.Text = listView1.Items[ind].SubItems[1].Text;        textBox3.Text = listView1.Items[ind].SubItems[2].Text;        textBox4.Text = listView1.Items[ind].SubItems[3].Text;    }    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 修改按钮事件private void button2_Click(object sender, EventArgs e){    // 修改    if (listView1.SelectedItems.Count != 0)    {        // 获取最新选择对象在listview1中的索引        ind = listView1.SelectedIndices[0];        // 修改选中行表格数据        listView1.Items[ind].SubItems[0].Text = textBox1.Text;        listView1.Items[ind].SubItems[1].Text = textBox2.Text;        listView1.Items[ind].SubItems[2].Text = textBox3.Text;        listView1.Items[ind].SubItems[3].Text = textBox4.Text;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>对于<code>删除</code>按钮，当某行被选中时，可被删除</li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">private void button3_Click(object sender, EventArgs e){    // 删除    if(ind != -1)    {        listView1.Items.RemoveAt(ind);    }    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>效果如下</p><ul><li><video src="./video/表格记录软件.mp4"></video></li></ul></li></ul><h4 id="2-12-4-例程2-–-图片上传软件"><a href="#2-12-4-例程2-–-图片上传软件" class="headerlink" title="2.12.4  例程2 – 图片上传软件"></a>2.12.4  例程2 – 图片上传软件</h4><ul><li><p><code>具体代码文件见D:\Program Files\Microsoft Visual Studio\projects\start\listView</code></p></li><li><p>界面搭建如下</p><ul><li><img src="image-20231102191339489-1705156191296-30.png" alt="" style="zoom: 50%;"></li></ul></li><li><p><code>listview</code>要与<code>imagelist</code>关联起来</p></li><li><p>首先是<code>浏览图片</code>按键，按下后打开文件对话框，配置文件格式，当用户选中之后将其绝对路径显示到<code>图片路径</code></p></li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 浏览图片按键事件private void button1_Click(object sender, EventArgs e){    // 过滤图片类型    openFileDialog1.Filter = "图片文件(*.png;*.jpg;*.gif)|*.png;*.jpg;*.gif";    if (openFileDialog1.ShowDialog() == DialogResult.OK)    {        // 将文件绝对路径赋给textBox1        textBox1.Text = openFileDialog1.FileName;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>对于<code>立即上传</code>按键，按下后，首先根据<code>textBox1</code>中的图像路径，将图片按指定方式命名并存到相应文件夹下；同时，在<code>textBox2</code>中自定义名称，之后将该图片展示到<code>listView</code>中</li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 立即上传按钮事件private void button2_Click(object sender, EventArgs e){    // 从路径获取image对象    Image demo = Image.FromFile(textBox1.Text);        // 以时间格式命名    demo.Save(Application.StartupPath + @"\img\" + DateTime.Now.ToString("yyyyMMddHHmmss") + ".jpg");    // 首先的导入imagelist    imageList1.Images.Add(demo);    // 将imagelist与listview进行关联    listView1.LargeImageList = imageList1;    // 从imagelist获取最新的图片，并命名为textBox2，添加到listview    listView1.Items.Add(textBox2.Text, imageList1.Images.Count - 1);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>对于<code>修改名称</code>按键，首先当鼠标选中任意图片后，将其在<code>listview</code>中的名称显示到<code>textBox2</code>中；之后对该名称进行修改，按下<code>修改名称</code>按键后，更改<code>listview</code>中对应图片名称</li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 当前选中图片索引int ind = -1;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 鼠标任意选中图片private void listView1_SelectedIndexChanged(object sender, EventArgs e){    if (listView1.SelectedItems.Count != 0)    {        // 获取最新选择对象在listview1中的索引        ind = listView1.SelectedIndices[0];        // 将当前listview中被点击的图片名称显示到textBox2        textBox2.Text = listView1.Items[ind].Text;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 修改对应名称private void button3_Click(object sender, EventArgs e){    if (ind != -1)    {        listView1.Items[ind].Text = textBox2.Text;    }    else    {        MessageBox.Show("未选中图片");    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>对于<code>删除图片</code>按钮事件</li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">private void button4_Click(object sender, EventArgs e){    if(ind != -1)    {        // 从llistview中删除鼠标选中图片        listView1.Items.RemoveAt(ind);    }    else    {        MessageBox.Show("未选中图片");    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>效果如下</p><ul><li><video src="./video/图片上传软件.mp4"></video></li></ul></li></ul><h3 id="2-13-状态栏及富文本框"><a href="#2-13-状态栏及富文本框" class="headerlink" title="2.13 状态栏及富文本框"></a>2.13 状态栏及富文本框</h3><ul><li><code>menuStrip</code>控件，搭建界面菜单</li><li><code>fontDialog</code>控件，字体对话框</li><li><code>colorDialog</code>控件，颜色对话框</li><li></li></ul><h4 id="2-13-1-状态栏"><a href="#2-13-1-状态栏" class="headerlink" title="2.13.1 状态栏"></a>2.13.1 状态栏</h4><ul><li><code>statusStrip</code>控件</li></ul><h4 id="2-13-2-富文本框"><a href="#2-13-2-富文本框" class="headerlink" title="2.13.2 富文本框"></a>2.13.2 富文本框</h4><ul><li><code>richTextBox</code>控件</li></ul><h4 id="2-13-3-例程-–-个性化记事本"><a href="#2-13-3-例程-–-个性化记事本" class="headerlink" title="2.13.3 例程 – 个性化记事本"></a>2.13.3 例程 – 个性化记事本</h4><ul><li>==有bug，不知道怎么解决！！！==</li></ul><h2 id="三、开发例子-–-B站刘金玉视频总结"><a href="#三、开发例子-–-B站刘金玉视频总结" class="headerlink" title="三、开发例子 – B站刘金玉视频总结"></a>三、开发例子 – B站刘金玉视频总结</h2><h3 id="3-1-简易谷歌浏览器开发"><a href="#3-1-简易谷歌浏览器开发" class="headerlink" title="3.1 简易谷歌浏览器开发"></a>3.1 简易谷歌浏览器开发</h3><h4 id="3-1-1-主要内容"><a href="#3-1-1-主要内容" class="headerlink" title="3.1.1 主要内容"></a>3.1.1 主要内容</h4><ul><li><p><code>WebBrowser</code>控件，默认调用IE浏览器作为内核，但该内核已经久远，会报错</p></li><li><p><code>cefsharp</code>，第三方控件，通过<code>管理NuGet程序包</code>下载，使用Chrome内核</p><ul><li>使用时，需要引入命名空间</li></ul></li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">using CefSharp;using CefSharp.WinForms;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="3-1-2-实现过程"><a href="#3-1-2-实现过程" class="headerlink" title="3.1.2 实现过程"></a>3.1.2 实现过程</h4><ul><li><p>具体代码见<code>D:\Program Files\Microsoft Visual Studio\projects\start\Brower</code></p></li><li><p>搭建界面布局如下</p><ul><li><img src="image-20231109162733234-1705156191296-31.png" alt="" style="zoom: 50%;"></li></ul></li><li><p>首先在外部声明全局变量</p></li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">ChromiumWebBrowser myChrome;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>不拖动<code>CefSharp</code>控件，通过代码调用</li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 通过窗体加载事件配置浏览器private void Form1_Load(object sender, EventArgs e){    // 载入谷歌浏览器默认配置，并初始化内核    Cef.Initialize(new CefSettings());        // 设置浏览器默认打开地址    myChrome = new ChromiumWebBrowser("https://www.bilibili.com");        // 将网页显示到panel中    panel1.Controls.Add(myChrome);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>在<code>textBox1</code>中输入网址后，按回车进行调换</li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 通过textBox按键抬起事件private void textBox1_KeyUp(object sender, KeyEventArgs e){    // 当按下回车    if(e.KeyCode == Keys.Enter)    {        // webBrowser1.Url = new Uri(textBox1.Text);                // 将textBox1中文本转为字符串，传给Chrome进行网页跳转        myChrome.LoadUrl(textBox1.Text.ToString());    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>实现浏览器的前进、后退、刷新</li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 前进private void button1_Click(object sender, EventArgs e){    myChrome.Forward();}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 后退private void button2_Click(object sender, EventArgs e){    myChrome.Back();}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 刷新private void button3_Click(object sender, EventArgs e){    myChrome.Reload();}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 查看源代码    调用时一直转圈，没有显示出来，程序还卡了private void button4_Click(object sender, EventArgs e){    richTextBox1.Text = myChrome.GetSourceAsync().Result;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-2-超市商品分类树"><a href="#3-2-超市商品分类树" class="headerlink" title="3.2 超市商品分类树"></a>3.2 超市商品分类树</h3><h4 id="3-2-1-主要内容"><a href="#3-2-1-主要内容" class="headerlink" title="3.2.1 主要内容"></a>3.2.1 主要内容</h4><ul><li><code>treeView</code>树形控件，根节点，子节点</li></ul><h4 id="3-2-2-实现过程"><a href="#3-2-2-实现过程" class="headerlink" title="3.2.2 实现过程"></a>3.2.2 实现过程</h4><ul><li><p>具体代码见<code>D:\Program Files\Microsoft Visual Studio\projects\start\TreeView</code></p></li><li><p>搭建界面如下</p><ul><li><img src="image-20231109182148300-1705156191296-32.png" alt="" style="zoom: 50%;"></li></ul></li><li><p><code>全部展开</code>功能</p></li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">private void button1_Click(object sender, EventArgs e){    // 全部展开，调用ExpandAll()方法    treeView1.ExpandAll();}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>全部闭合</code>功能</li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">private void button2_Click(object sender, EventArgs e){    // 全部闭合，调用CollapseAll()方法    treeView1.CollapseAll();}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>添加根节点</code>功能</li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">private void button3_Click(object sender, EventArgs e){    // 将textBox中的文本添加到根节点    treeView1.Nodes.Add(textBox1.Text);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>添加至当前分类</code>功能</li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">private void button4_Click(object sender, EventArgs e){    // 在被选中的根节点下添加子节点    treeView1.SelectedNode.Nodes.Add(textBox1.Text);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p><code>右键删除</code></p><ul><li>使用<code>contextMenuStrip</code>控件，添加删除选项，并绑定<code>treeview</code></li></ul></li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">private void 删除选中项ToolStripMenuItem_Click(object sender, EventArgs e){    // 获取当前选中项（根节点或子节点）    TreeNode select = treeView1.SelectedNode;        // 删除该节点（根节点或子节点）    treeView1.Nodes.Remove(select);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>网页链接</code></li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">private void linkLabel1_LinkClicked(object sender, LinkLabelLinkClickedEventArgs e){    System.Diagnostics.Process.Start("http://bcczcs.com");}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-3-红绿灯交通模拟-–-调用线程"><a href="#3-3-红绿灯交通模拟-–-调用线程" class="headerlink" title="3.3 红绿灯交通模拟 – 调用线程"></a>3.3 红绿灯交通模拟 – 调用线程</h3><h4 id="3-3-1-主要内容"><a href="#3-3-1-主要内容" class="headerlink" title="3.3.1 主要内容"></a>3.3.1 主要内容</h4><ul><li><code>backgroundWorker</code>后台线程</li></ul><h4 id="3-3-2-实现过程"><a href="#3-3-2-实现过程" class="headerlink" title="3.3.2 实现过程"></a>3.3.2 实现过程</h4><ul><li><p>具体代码见<code>D:\Program Files\Microsoft Visual Studio\projects\start\Traffic</code></p></li><li><p>搭建界面</p><ul><li><img src="image-20231109194202863-1705156191296-33.png" alt="" style="zoom: 50%;"></li></ul></li><li><p>引入全局变量</p></li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">int count = 10;Graphics g;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>在面板内绘制红绿灯</li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 窗体自带一个onpaint事件用来重绘winform界面// 需要对该事件进行重写，以达到红绿灯显示的连续性，解决灯消失不显示的情况protected override void OnPaint(PaintEventArgs e){    base.OnPaint(e);    // 在面板内绘制实心圆    g = panel1.CreateGraphics();    // g.DrawEllipse(new Pen(Color.Red), 0, 0, 40, 40);    // 创建笔刷    Brush brush = new SolidBrush(Color.Red);        // 绘制红绿灯    g.FillEllipse(brush, 0, 0, 40, 40);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>按下<code>开始</code></li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">private void button1_Click(object sender, EventArgs e){    // 先判断后台线程是否已经被开启，避免多次点击报错    if (!backgroundWorker1.IsBusy)    {        // 开启后台线程        backgroundWorker1.RunWorkerAsync();    }    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 将耗时的复杂的计算或死循环放到后台进行，避免卡顿private void backgroundWorker1_DoWork(object sender, DoWorkEventArgs e){    // 判断count取值    while (true)    {        if (count &lt; 0)        {            break;        }        else if (count &lt;= 7 &amp;&amp; count &gt; 4)        {            Brush brush = new SolidBrush(Color.Green);            g.FillEllipse(brush, 0, 0, 40, 40);        }        else if (count &lt;= 4)        {            Brush brush = new SolidBrush(Color.Yellow);            g.FillEllipse(brush, 0, 0, 40, 40);        }        // 本身后台线程是一个线程，而label2控件是在主线程里创建的，直接使用开线程了，使用Invoke解决        // Invoke会一直网上进行查找，直到找到当前控件所在的线程，并对控件的值进行更新        // new action()内启用一个委托，去解决跨线程        Invoke(new Action(() =&gt;         {            label2.Text = count.ToString();            // 刷新界面，不刷新会卡死            Update();        }));        // 另一种解决方法        /*Invoke(new EventHandler(delegate        {            label2.Text = count.ToString();            // 刷新界面，不刷新会卡死            Update();        }));*/                // 暂停线程1秒        System.Threading.Thread.Sleep(1000);        count--;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>当窗体关闭时，关闭后台进程，避免报错</li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">private void Form1_FormClosing(object sender, FormClosingEventArgs e){    // 当窗体关闭时，同时关闭后台线程，避免报错    backgroundWorker1.CancelAsync();}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-4-屏幕滚动文字"><a href="#3-4-屏幕滚动文字" class="headerlink" title="3.4 屏幕滚动文字"></a>3.4 屏幕滚动文字</h3><h4 id="3-4-1主要内容"><a href="#3-4-1主要内容" class="headerlink" title="3.4.1主要内容"></a>3.4.1主要内容</h4><ul><li>通过使用<code>System.IO</code>命名空间下的<code>StreamWrite</code>类进行文件写入</li><li>使用<code>Fill.ReanAllText()</code>方法读取文件</li></ul><h4 id="3-4-2-实现过程"><a href="#3-4-2-实现过程" class="headerlink" title="3.4.2 实现过程"></a>3.4.2 实现过程</h4><ul><li><p>具体代码见<code>D:\Program Files\Microsoft Visual Studio\projects\start\Screen</code></p></li><li><p>界面搭建如下</p><ul><li><img src="image-20231109203744310-1705156191296-34.png" alt="" style="zoom: 50%;"></li></ul></li><li><p>首先设置从属关系</p></li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">private void Form1_Load(object sender, EventArgs e){    // 将label1设置为label2的父窗体    // 通过将label2的背景色设置为Transparent，跟随label1窗体背景颜色    label2.Parent = label1;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>接着启用<code>timer</code>控件，让<code>label2</code>在<code>label1</code>中动起来</li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">private void timer1_Tick(object sender, EventArgs e){    // 边界判断    if (label2.Left &lt; -label2.Width)    {        label2.Left = label1.Width;    }    label2.Left -= 10;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>对于<code>预览</code>键，点击后，将<code>textBox</code>中输入的文本显示到<code>label2</code>上</li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">private void button1_Click(object sender, EventArgs e){    label2.Text = textBox1.Text;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li>对于<code>写入文件保存</code></li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">private void button2_Click(object sender, EventArgs e){    // 通过System.IO中的streamwrite类来写入文件    // 构造函数参数传入的是文件保存名称，默认路径在debug文件下    // 该构造函数还有第二个参数，bool，是否追加    StreamWriter sw = new StreamWriter("sw.txt");    // 写入文件    sw.Write(textBox1.Text);    // 写入完成要进行关闭，关闭后才能看到保存的文本    sw.Close();}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>对于<code>checkBox 从保存文件读入文本</code>，并将文本内容写入<code>label2</code></li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">private void checkBox1_CheckedChanged(object sender, EventArgs e){    if(checkBox1.Checked)    {        label2.Text = File.ReadAllText("sw.txt");    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-5-掩码规则验证及信息提示"><a href="#3-5-掩码规则验证及信息提示" class="headerlink" title="3.5 掩码规则验证及信息提示"></a>3.5 掩码规则验证及信息提示</h3><h4 id="3-5-1-主要内容"><a href="#3-5-1-主要内容" class="headerlink" title="3.5.1 主要内容"></a>3.5.1 主要内容</h4><ul><li><code>maskedTextBox</code>掩码控件<ul><li><code>mask</code>属性设置掩码格式</li><li><code>AsciOnly</code>属性设置是否开启格式验证，若不合格输入不了</li></ul></li><li><code>toolTip</code>提示控件</li></ul><h4 id="3-5-2-实现过程"><a href="#3-5-2-实现过程" class="headerlink" title="3.5.2 实现过程"></a>3.5.2 实现过程</h4><ul><li><p>具体代码见<code>D:\Program Files\Microsoft Visual Studio\projects\start\Mask</code></p></li><li><p>界面搭建如下</p><ul><li><img src="image-20231109221329348-1705156191297-35.png" alt="" style="zoom:50%;"></li></ul></li><li><p>按键切换掩码格式，采用同类型按钮事件</p></li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 同类型按钮事件// 首先要有同类型控件// 将同类型控件选择相同的事件// 通过sender这个object，强制转为指定类型的控件// 通过转化过来的控件，直接调用某一属性去进行区分private void radioButton1_CheckedChanged(object sender, EventArgs e){    RadioButton rdbt = (RadioButton)sender;    if(rdbt.Text == "身份号码")    {        maskedTextBox1.Mask = "000000-00000000-000A";    }    else if(rdbt.Text == "电话号码")    {        maskedTextBox1.Mask = "000-0000-0000";    }    else if (rdbt.Text == "日期时间")    {        maskedTextBox1.Mask = "0000年90月90日 90时00分";    }    else if (rdbt.Text == "自动转为大写")    {        // 没有该类型掩码        // 自定义掩码：0表示0-9的数字；A代表字母数字都可以；        // &gt;&lt;表示转大小写；L只表示字母         // 指定5位字母        maskedTextBox1.Mask = "&gt;LLLLL";    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>输入提示</li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">private void maskedTextBox1_MaskInputRejected(object sender, MaskInputRejectedEventArgs e){    // 当输入不符合规则时提醒     // 提醒输入将超设置长度    if (maskedTextBox1.MaskFull)    {        // 设置提示标题        toolTip1.ToolTipTitle = "啊giao提醒您：";         // 设置提示内容，在相应控件位置显示        // 鼠标必须在控件位置，否则可能失效        toolTip1.Show("输入完成了", maskedTextBox1);    }     // 该条件与前一个情况一样，做例子    else if(e.Position == maskedTextBox1.Mask.Length)    {        toolTip1.Show("已在最后一个位置", maskedTextBox1);    }     else    {        toolTip1.Show("输入不合法", maskedTextBox1);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="四、一些有意思的操作"><a href="#四、一些有意思的操作" class="headerlink" title="四、一些有意思的操作"></a>四、一些有意思的操作</h2><h3 id="4-1-文件对话框"><a href="#4-1-文件对话框" class="headerlink" title="4.1 文件对话框"></a>4.1 文件对话框</h3><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">OpenFileDialog ofd = new OpenFileDialog();ofd.Title = "请选择音乐文件";ofd.InitialDirectory = @"C:\Users\echo\Desktop\Music";ofd.Multiselect = true;ofd.Filter = "音乐文件|*.wav|所有文件|*.*";ofd.ShowDialog();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-2-音乐播放"><a href="#4-2-音乐播放" class="headerlink" title="4.2 音乐播放"></a>4.2 音乐播放</h3><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">SoundPlayer sp = new SoundPlayer();sp.SoundLocation = "xxx";sp.Play();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="五、VS快捷键"><a href="#五、VS快捷键" class="headerlink" title="五、VS快捷键"></a>五、VS快捷键</h2><ul><li><code>Ctrl+鼠标左键点击函数名</code>：跳转该函数具体定义</li><li><code>Ctrl+}</code>：切换光标在代码块标识符<code>{}</code>的位置</li></ul><h2 id="六、TCP-IP通信"><a href="#六、TCP-IP通信" class="headerlink" title="六、TCP/IP通信"></a>六、TCP/IP通信</h2><ul><li><p>上位机是客户端，下位机是服务器，客户端发送命令，服务端做出响应</p></li><li><p>通过<code>TCP</code>传送接收数据时，必须先使用协议和网络地址信息初始化套接字，然后才能进行通信</p></li><li><p><code>TCP/IP</code>使用<strong>一个网络地址和一个服务端口号</strong>来标识唯一设备</p><ul><li>网络地址标识特定的网络目标</li><li>端口号标识该设备要连接的特定服务</li><li>网络地址和服务端口的组合称为<strong>终结点</strong><ul><li>终结点在<code>.NET</code>中由<code>EndPoint</code>类表示</li><li>对于<code>IP</code>地址类型，类为<code>IPEndPoint</code></li></ul></li></ul></li><li><p>使用<code>System.Net.Sockets</code>时，将网络终结点表示为<code>IPEndPoint</code>对象</p><ul><li><code>IPEndPoint</code>使用<code>IPAddress</code>及其端口号构造实例</li><li>在使用<code>Socket</code>发起对话前，在应用和远程目标之间创建数据通道</li></ul></li></ul><h3 id="6-1-进程"><a href="#6-1-进程" class="headerlink" title="6.1 进程"></a>6.1 进程</h3><ul><li><p>进程是操作系统中的一个<strong>执行实例</strong></p></li><li><p>进程是程序的一次执行过程，是一个<strong>程序</strong>与其<strong>关联数据</strong>以及<strong>系统资源</strong>的总称</p></li><li><p>它是计算机系统进行资源分配和调度的基本单位，可以看作是<strong>程序的运行实体</strong></p></li><li><p>打开软件</p></li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 打开edge浏览器，并跳转相应网页Process.Start("msedge","https://www.baidu.com")// 打开微信Process.Start("weixin://")<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>打开文件</li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">ProcessStartInfo psi = new ProcessStartInfo("文件路径");Pocess p = new Process();p.StartInfo = psi;p.Start();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="6-2-线程"><a href="#6-2-线程" class="headerlink" title="6.2 线程"></a>6.2 线程</h3><ul><li>线程是进程内的一个独立执行流，是操作<strong>系统调度的基本单位</strong></li><li><strong>一个进程可以包含多个线程</strong>，它们共享进程的资源，但拥有各自的执行路径和局部变量</li><li>线程是轻量级的执行单元，相比于进程，线程的<strong>创建、销毁和切换成本更低</strong></li><li>程序<strong>任何动作的响应</strong>都是由线程完成的</li></ul><h4 id="6-2-1-主要函数"><a href="#6-2-1-主要函数" class="headerlink" title="6.2.1 主要函数"></a>6.2.1 主要函数</h4><ul><li>线程主要函数分别是<code>Start()</code>和<code>Abort()</code><ul><li><code>Start()</code>：告诉cpu线程已经准好了，可以随时被执行，但是具体执行时间由cpu决定</li><li><code>Abort()</code>：终止线程</li></ul></li><li>其余方法<ul><li><code>Thread.Sleep(1)</code>：静态方法，使线程停止一段时间</li></ul></li></ul><h4 id="6-2-2-关于线程的一些问题"><a href="#6-2-2-关于线程的一些问题" class="headerlink" title="6.2.2 关于线程的一些问题"></a>6.2.2 关于线程的一些问题</h4><ul><li><p>进程与线程的关系？</p><ul><li>一个进程包含多个线程</li></ul></li><li><p>线程分类</p><ul><li>前台线程和后台线程，我们使用<strong>后台线程</strong></li></ul></li><li><p>==为什么要用多线程？==</p><ul><li><p>因为单线程容易造成<strong>程序假死</strong></p></li><li><p>如，Form窗体中只有一个button1</p></li></ul></li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 按下button1后，调用test()// 此时主线程去控制台执行Console.WriteLine()了// 若test()没有执行完，Form窗体会卡死，无法拖动或执行其他操作private void button1_Click(object sender, EventArgs e){    test();}public void test(){    for(int i = 0; i&lt;1000000; i++)    {        Console.WriteLine(i);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>通过==线程调用函数==的一些注意事项</p><ul><li>无参函数</li></ul></li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 通过线程调用无参函数private void button1_Click(object sender, EventArgs e){    Thread th = new Thread(Test);        // 开启后台进程，其会在前台进程结束后 自动终止，不会等待后台进程执行完毕    th.IsBackground = true;    th.Start();}public void test(){    for(int i = 0; i&lt;1000000; i++)    {        Console.WriteLine(i);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>有参函数</li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 对于有参函数// 形参的类型必须是 Object // 线程调用传参，通过对 Start() 写入实参进行传递private void button1_Click(object sender, EventArgs e){    Thread th = new Thread(Test);    th.IsBackground = true;    th.Start("123");}public void test(object s){    string ss = string(s)    for(int i = 0; i&lt;1000000; i++)    {        Console.WriteLine(i);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>跨线程调用控件</p><ul><li>要想跨线程调用控件，可以通过<strong>取消程序的跨线程检查</strong>实现</li></ul></li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">Control.CheckForIllegalCrossThreadCalls = false;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>3个label，1个button</li></ul><img src="image-20231211201441672-1705156191297-36.png" alt="" style="zoom:33%;"><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">bool b = false;private void Form1_Load(object sender, EventArgs e){    // 取消跨线程检查，实现控件的跨线程调用    Control.CheckForIllegalCrossThreadCalls = false;}private void button1_Click(object sender, EventArgs e){    if(b == false)    {        b = true;        button1.Text = "停止";        Thread th = new Thread(PlayGame);        th.IsBackground = true;        th.Start();    }    else    {        b = false;        button1.Text = "开始";    }}private void PlayGame(){    Random r = new Random();    while (b)    {        // 若没有取消跨线程检查，此处会报错        label1.Text = r.Next(0, 9).ToString();        label2.Text = r.Next(0, 9).ToString();        label3.Text = r.Next(0, 9).ToString();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="6-2-3-多线程"><a href="#6-2-3-多线程" class="headerlink" title="6.2.3 多线程"></a>6.2.3 多线程</h4><ul><li>多个执行流同时运行</li><li>实际还是单线程，但对CPU进行了时间切片，在每个时间片内执行一个线程</li><li>如何实现多线程？<ul><li>基于委托异步实现</li><li><code>Thread</code></li><li><code>ThreadPool</code></li><li><code>Task</code></li><li><code>TaskFactory</code></li><li><code>Parallel</code>并行编程</li></ul></li></ul><h5 id="6-2-3-1-基于委托的异步编程"><a href="#6-2-3-1-基于委托的异步编程" class="headerlink" title="6.2.3.1 基于委托的异步编程"></a>6.2.3.1 基于委托的异步编程</h5><ul><li><p>异步编程是建立在<strong>委托</strong>的基础上</p></li><li><p>异步调用的每个方法，都是在<strong>独立的进程</strong>中执行的</p></li><li><p>异步编程是<strong>多线程的一种</strong>，可以说是简化的多线程</p></li><li><p>什么时候使用异步？</p><ul><li>比较适合在后台<strong>耗费时间较长，但任务简单</strong>且各任务间相互独立的情况</li></ul></li><li><p>如果后台要求访问共享资源，并且要按照某种顺序执行，此时异步不适合，应该采用其他多线程去完成</p></li><li><p><code>D:\Program Files\Microsoft Visual Studio\projects\异步-多线程\多线程\Study1</code></p></li></ul><h6 id="6-2-3-1-1-示例"><a href="#6-2-3-1-1-示例" class="headerlink" title="6.2.3.1.1 示例"></a>6.2.3.1.1 示例</h6><ul><li>先声明一个<code>random</code>对象</li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 后续模拟线程耗时// 多线程环境或需要长期保持随机数序列不变的情况下，通常建议将其声明为 staticprivate static Random random = new Random();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li>基于<code>Func&lt;&gt;</code>定义匿名委托</li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 基于委托求一个数的平方// 该委托输入参数为 num，输出结果为 num*numprivate Func&lt;int, int&gt; Operation = (num) =&gt;{    // 模拟耗时，使当前进程暂停    Thread.Sleep(random.Next(5) * 1000);    return num * num;};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>定义回调方法<code>AutoCallBack()</code></li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 回调函数// 通过 IAsyncResult.AsyncState 可获取传递给异步操作的标识参数// 通过 Operation.EndInvoke() 获取异步操作的结果private void AutoCallBack(IAsyncResult result){    int res = Operation.EndInvoke(result);    Console.WriteLine($"第{result.AsyncState}个计算结果是{res}");}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>启动多线程</li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">private void btnExec_Click(object sender, EventArgs e){    for(int i =1; i &lt; 11; i++)    {        // 异步        // 通过循环将 10 个任务同时发布出去        // 各自执行，互不影响        // 参数中的回调函数，是当该异步任务执行完成后，需要自动调用的方法        // 启动异步任务，每个任务会执行 Operation 委托，并传入参数 i*10        // Operation 委托执行完成后，调用 AutoCallBack 回调方法，并传入标识参数 i        Operation.BeginInvoke(i * 10, AutoCallBack, i);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h6 id="6-2-3-1-2-一些问题"><a href="#6-2-3-1-2-一些问题" class="headerlink" title="6.2.3.1.2 一些问题"></a>6.2.3.1.2 一些问题</h6><ul><li><code>Operation.BeginInvoke(i*10,AutoCallBack,i);</code>中的标识参数<code>i</code>有什么用？<ul><li>将不同的 <code>i</code> 传递给异步操作，<strong>标识线程</strong>，以便<strong>在异步操作完成后</strong>能够在回调函数中<strong>识别是哪个线程完成了</strong></li></ul></li><li><code>int res = Operation.EndInvoke(result);</code>怎么理解？<ul><li><code>result</code>是传入的标识参数<code>i</code>，<code>EndInvoke()</code>通过使用该标识去获取对应线程的运行结果</li></ul></li></ul><h5 id="6-2-3-2-基于Thread多线程"><a href="#6-2-3-2-基于Thread多线程" class="headerlink" title="6.2.3.2 基于Thread多线程"></a>6.2.3.2 基于Thread多线程</h5><ul><li><code>D:\Program Files\Microsoft Visual Studio\projects\异步-多线程\多线程\Threads</code></li></ul><h6 id="6-2-3-2-1-跨线程调用控件"><a href="#6-2-3-2-1-跨线程调用控件" class="headerlink" title="6.2.3.2.1 跨线程调用控件"></a>6.2.3.2.1 跨线程调用控件</h6><ul><li><p>前面记<code>Thread</code>，此处新增==跨线程调用控件==的方法</p><ul><li><p><code>Control.CheckForIllegalCrossThreadCalls = false;</code>取消跨线程检测，尽量不用</p></li><li><p>主要代码</p></li></ul></li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// Control.Invoke() 实现跨线程调用// Control.InvokeRequired 该属性在 Control 不是UI线程时为 true；反之，为 falseif (this.lalResult1.InvokeRequired)    {        this.lalResult1.Invoke(            new Action&lt;string&gt;(s =&gt; { this.lalResult1.Text = s; }),            num.ToString() );    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>示例代码</li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">private void btnExecute1_Click(object sender, EventArgs e){    // 任务一    int num = 0;    Thread thread = new Thread(() =&gt;    {        for(int i = 1; i &lt; 20; i++)        {            num += i;                        // 跨线程调用控件            if (this.lalResult1.InvokeRequired)            {                this.lalResult1.Invoke(                    new Action&lt;string&gt;(s =&gt; { this.lalResult1.Text = s; }),                    num.ToString() );            }            Thread.Sleep(300);        }    });    thread.IsBackground = true; // 设置为后台线程    thread.Start();    // 关于前台线程和后台线程：    // 一个程序如果有前台线程，必须在所有的前台线程都结束后，才能退出    // 一个程序如果开启的都是后台线程，则程序关闭后，后台线程就会自动全部退出}private void btnExecute2_Click(object sender, EventArgs e){        Thread th = new Thread(() =&gt;    {        for(int i = 1;i &lt; 20; i++)        {            if (this.lalResult2.InvokeRequired)            {                this.lalResult2.Invoke(                    new Action&lt;string&gt;(s =&gt; { this.lalResult2.Text = s; }),                    i.ToString());            }            Thread.Sleep(i*100);        }    });    th.IsBackground = true;    th.Start();}private void btnRead_Click(object sender, EventArgs e){    Thread th = new Thread(() =&gt;    {        if (this.txtV.InvokeRequired)        {            this.txtV.Invoke(new Action&lt;string&gt;(s =&gt; { this.lalV.Text = s; }),            txtV.Text);            //Thread.Sleep(100);        }    });    th.IsBackground = true;    th.Start();}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h6 id="6-2-3-2-2-跨控件访问数据库"><a href="#6-2-3-2-2-跨控件访问数据库" class="headerlink" title="6.2.3.2.2 跨控件访问数据库"></a>6.2.3.2.2 跨控件访问数据库</h6><ul><li><code>D:\Program Files\Microsoft Visual Studio\projects\异步-多线程\多线程\ThreadDataBase</code></li></ul><p>先把数据库学了来！！！！！</p><h3 id="6-3-Socket"><a href="#6-3-Socket" class="headerlink" title="6.3 Socket"></a>6.3 Socket</h3><h4 id="6-3-1-关于Socket的一些问题"><a href="#6-3-1-关于Socket的一些问题" class="headerlink" title="6.3.1 关于Socket的一些问题"></a>6.3.1 关于Socket的一些问题</h4><ul><li><p>怎么理解Socket</p><ul><li>人通过 <strong>电话</strong> 进行通信，==程序通过 Socket 来通==，套接字就是程序间的电话机</li><li>Socket是进程通信机制，也称作“套接字”，用于<strong>描述IP地址和端口</strong>，是一个通信链的句柄，是两个程序间通信用的</li><li>Socket类型<ul><li><strong>流式Socket</strong>（STREAM）：一种面向连接的Socket，针对<strong>TCP</strong>服务应用，安全，但是效率低</li><li><strong>数据报式Socket</strong>（DATAGRAM）：一种无连接Socket，对应于<strong>UDP</strong>服务应用，不安全（丢失，顺序紊乱，在接收端要分析重排及要求重发），但效率高</li></ul></li><li>以电话网为例，电话的通话双方相当于通信的2个程序，<strong>电话号码就是IP地址</strong>。任何用户在通话前，首先要占有<strong>一部电话机，相当于申请一个Socket</strong>；同时要知道对方的号码，对方也得有一部电话，即一个Socket。然后向对方<strong>拨号呼叫，相当于发出连接请求</strong>。对方假如在场并空闲，拿起电话话筒，双方就可以进行正式<strong>通话，相当于连接成功</strong>。双方通话的过程，是一方向电话机发出信号，和对方从电话机接收信号的过程，相当于<strong>向Socket发送数据和从Socket接收数据</strong>。通话结束后，一方挂起电话机，相当于<strong>关闭Socket，撤销连接</strong>。</li><li>关于端口，客户端与服务器使用<strong>IP地址建立联系</strong>，而客户端只需要与服务器中的某一个程序进行连接，在服务器中使用<strong>端口号标记各程序</strong>。</li></ul></li><li><p>Socket一般==应用模式==（服务端和客户端）</p><ul><li>服务端 welcoming Socket 监听端口，检测客户端的连接请求</li><li>客户端 client Socket 连接服务端指定端口，并用于接收和发送 服务端消息</li><li>服务端 welcoming Socket 监听到客户端连接，创建 connection Socket，实现与客户端的通信</li><li>以男生去女生宿舍找女同学为例，男生要想找到女生宿舍得某一个的女生，首先要找到宿管大妈，告诉大妈找人的原因（如生病了来看望女同学），宿管大妈再去找到并通知对应的女生，进而建立男生与女生之间的联系。过程中，男生相当于客户端，宿管阿姨扮演负责监听的Socket，女生相当于服务端里的应用程序，当男生发出请求，宿管阿姨就创建一个负责通信的Socket，用于男生和女生通信</li></ul></li><li><p>Socket中的==端口==</p><ul><li>Internet上有很多主机，每台主机同时运行了多个服务软件，提供多种服务，每种服务都打开一个Socket，并绑定到一个端口上，不同的端口对应于不同的服务。例如，http使用80端口，ftp使用21端口，smtp使用25端口</li></ul></li><li><p>什么是==协议==</p><ul><li><p>我和ikun打电话，中文是规定好的语言，电脑与电脑进行<strong>联系就需要协议</strong></p></li><li><p><strong>TCP</strong>协议，有<strong>三次握手</strong>，要求必须要有服务器，请求必须由客户端发起，因为服务器不知道客户端在哪。三次握手的过程：首先客户端给服务器发送消息“你有空吗？”，服务器收到客户端的消息后，回复“我有空”，最后客户端再给服务器发送消息“我知道你有空了”。<strong>只有完成三次握手连接上后，客户端才跟服务器相收发数据，否则不会进行数据的沟通</strong>。所以TCP协议<strong>安全、稳定、但是效率低</strong>（需要花时间去握手）</p></li><li><pre class=" language-Mermaid"><code class="language-Mermaid">sequenceDiagram    participant Client as 客户端    participant Server as 服务器    Client->>Server: 发送消息："你有空吗？"    Server-->>Client: 回复消息："我有空"    Client->>Server: 发送消息："我知道你有空了"<pre class="line-numbers language-none"><code class="language-none">  - **UDP**协议，**快速，效率高，但是不稳定，容易发生数据丢失**，客户端不管服务器是否有空，直接把消息发送到服务器，当服务器繁忙的时候不能即使对接收到的数据进行处理，进而造成数据丢失  - 两种协议各有好坏，视频传输使用的就是UDP协议#### 6.3.2 Socket通信流程- Socket通信流程图  - ```mermaid    graph LR        id1(客户端)--->id2["Socket()"]        id2--->id3["Connect()"]        id3-->id4["Send()"]        id4-->id5["Receive()"]        id5-->id6["Close()"]                id7(服务端)-->id8["Socket()"]        id8-->id9["Bind()"]        id9-->id10["Listen()"]        id10-->id11["Accept()"]        id11-->id12["Receive()"]        id12-->id13["Send()"]        id13-->id14[捕获异常]        id14-->id15["Close()"]                id11<-->|建立连接|id3        id4-->|发送数据|id12        id13-->|接收数据|id5        id14-->|发送数据|id6        %%id3<-.->id11        %%id4<-.->id12        %%id5<-.->id13        %%id6<-.->id14    <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></code></pre></li><li><p>服务端<code>Bind()</code>：负责绑定监听端口；<code>Listen()</code>：设置监听队列：<code>Accept()</code>：放循环中，等待客户连接</p></li></ul></li></ul><h5 id="6-3-2-1-服务端"><a href="#6-3-2-1-服务端" class="headerlink" title="6.3.2.1 服务端"></a>6.3.2.1 服务端</h5><ul><li><strong>创建</strong>一个负责<strong>监听的Socket</strong></li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 创建监Socket，初始化地址簇、套接字类型、协议类型Socket socketWatch = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtoolType.Tcp);// 让 socketWatch 监听所有网络接口的连接请求IPAdress ip = IPAdress.Any;// 创建终结点IPEndPoint point = new IPEndPoint(ip, Convert.ToInt32(txtPort.Text));// socketWatch 绑定指定的终结点socketWatch.Bind(point);// 设置并发连接数，监听队列长度socketWatch.Listen(10);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>开启线程<strong>等待连接</strong>，连接成功后，<strong>创建通信socket</strong></li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 调用的自定义的 Listen 函数Thread th = new Thread(Listen);th.IsBackground = true;th.start(scoketWatch);// 将 socketSend 设置为全局变量Socket socketSend;private void Listen(object o){    socket socketWatch = o as socket;    // socketWatch 循环监听连接请求    while(true)    {        // Accept()是一个 阻塞 方法        // 有客户端请求连接时，返回一个新的 Socket，表示与客户端建立了连接        // 创建一个用于通信的 Socket        socketSend = socketWatch.Accept();                        // 连接成功后，可进行一些内部处理                // 如开启线程，接收客户端数据        Thread th = new Thread(Receive);        th.IsBackground = true;        th.Start(socketSend);            }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>当发生跨线程调用控件时，可在窗体加载时 <strong>关闭跨线程检查</strong></li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">Controls.CheckForIllegalCrossThreadCalls = false;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>服务器<strong>接收数据</strong></li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">private void Receive(object o){socket socketSend = o as socket;    try    {        // 循环接收数据，知道把数据接收完        while(true)        {            byte buffer = new byte[1024 * 1024 * 3];                        // 当 buffer 长度小于待接收的数据时，截取满buffer长度，就进行阶段，等待继续下次接收            int r = socketSend.Receive(buffer);                        // 当数据接收完            if(r == 0)            {                break;            }                        // 将 buffer 解码为字符串            // string str = Encoding.UTF8.GetString(buffer);        }        catch        {                    }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>服务器<strong>发送数据</strong></li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 以按键点击发送数据为例private void btnSend_Click(object sender, EvenArgs e){    string str = txtSend.Text;    byte[] buffer = Encoding.UTF8.GetBytes(str);        // 此处 socketSend 为前面创建的全局变量    socketSend.Send(buffer);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="6-3-2-2-客户端"><a href="#6-3-2-2-客户端" class="headerlink" title="6.3.2.2 客户端"></a>6.3.2.2 客户端</h5><ul><li>创建<strong>客户端Socket</strong>，并连接指定终结点</li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 做全局变量Socket socketSend;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">socketSend = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);IPAdress ip = IPAdress.Parse(txtServer.Text);IPEndPoint point = new IPEndPoint(ip, Convert.ToInt32(txtPort.Text));socketSend.Connect(point);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>客户端<strong>接收消息</strong></li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">private void Receive(){    while(true)    {        byte[] buffer = new byte[1024 * 1024 * 3];        int r = socketSend.Receive(buffer);        if(r == 0)        {            break;        }                string str = Encoding.UTF8.GetString(buffer);            }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>客户端<strong>发送消息</strong></li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 同样以按键点击发送消息private btnSend_Click(object sender, EventArgs e){    string str = txtMsg.Text.Trim();    byte[] buffer = Encoding.UTF8.GetBytes(str);    socketSend.Send(buffer);    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="6-4-3-基于Socket的聊天程序"><a href="#6-4-3-基于Socket的聊天程序" class="headerlink" title="6.4.3 基于Socket的聊天程序"></a>6.4.3 基于Socket的聊天程序</h4><h5 id="6-4-3-1-实现功能"><a href="#6-4-3-1-实现功能" class="headerlink" title="6.4.3.1 实现功能"></a>6.4.3.1 实现功能</h5><ul><li>传送文件</li><li>判断接收数据是文件还是文字</li><li>设计协议<ul><li>在传递的字节数组前加上一个字节作为标识：0表示文字，1表示文件</li><li>文字：0 + 字节数组</li><li>文件：1 + 文件二进制信息</li></ul></li></ul><h5 id="6-4-3-2-服务器"><a href="#6-4-3-2-服务器" class="headerlink" title="6.4.3.2 服务器"></a>6.4.3.2 服务器</h5><ul><li>创建<code>socketWatch</code><strong>监听连接</strong></li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">private void btnStart_Click(object sender, EventArgs e){    try    {        Socket socketWatch = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);        IPAddress ip = IPAddress.Any;        int port = Convert.ToInt32(txtPort.Text);        IPEndPoint point = new IPEndPoint(ip, port);        socketWatch.Bind(point);        showMsg("开始监听");        socketWatch.Listen(10);        Thread th = new Thread(Accept);        th.IsBackground = true;        th.Start(socketWatch);    }    catch    {    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><strong>接收客户端连接</strong>，并开启<code>Receive</code>线程</li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">Socket socketServer = null;private void Accept(object socketWatchObj){    Socket socketWatch = (Socket)socketWatchObj;    while (true)    {        try        {            socketServer = socketWatch.Accept();            showMsg(socketServer.RemoteEndPoint.ToString() + "  连接成功");            Thread th = new Thread(Receive);            th.IsBackground = true;            th.Start();//(socketServer);        }        catch        {        }            }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><strong>打印信息</strong></li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">private void showMsg(string str){    txtLog.AppendText(str+"\r\n");}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li><strong>接收数据</strong></li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">private void Receive()//(object socketServerObj){    //Socket socketServer = socketServerObj as Socket;    while (true)    {        try        {            byte[] buffer = new byte[1024 * 1024 * 3];            int num = socketServer.Receive(buffer);            if (num == 0)            {                showMsg("与客户端连接中断");                break;            }            string str = Encoding.UTF8.GetString(buffer, 0, num);            showMsg(socketServer.RemoteEndPoint.ToString() + "  " + str);        }        catch        {        }    }    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>发送<strong>文本数据</strong></li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">private void btnSend_Click(object sender, EventArgs e){    string str = txtMsg.Text;    byte[] buffer = Encoding.UTF8.GetBytes(str);    // 数组长度不可变    // 使用 List 来增加协议标识，并转为 数组    List&lt;byte&gt; list = new List&lt;byte&gt;();    list.Add(0);    list.AddRange(buffer);    byte[] newBuffer = list.ToArray();    socketServer.Send(newBuffer);    txtMsg.Clear();}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>选择并<strong>发送文件</strong></li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">private void btnSelect_Click(object sender, EventArgs e){    OpenFileDialog ofd = new OpenFileDialog();    ofd.InitialDirectory = @"";    ofd.Title = "请选择要发送的文件";    ofd.Filter = "所有文件|*.*";    ofd.ShowDialog();    txtPath.Text = ofd.FileName;}private void btnSendFile_Click(object sender, EventArgs e){    //  获取发送文件的路径    string path = txtPath.Text;    using (FileStream fsRead = new FileStream(path, FileMode.Open, FileAccess.Read))    {        byte[] buffer = new byte[1024 * 1024 * 5];        int r = fsRead.Read(buffer, 0, buffer.Length);        List&lt;byte&gt; list = new List&lt;byte&gt;();        list.Add(1);        list.AddRange(buffer);        byte[] newBuffer = list.ToArray();                socketServer.Send(newBuffer,0,r+1,SocketFlags.None);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="6-4-3-3-客户端"><a href="#6-4-3-3-客户端" class="headerlink" title="6.4.3.3 客户端"></a>6.4.3.3 客户端</h5><ul><li><strong>连接服务器</strong></li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">private void btnConnect_Click(object sender, EventArgs e){    try    {        socketClient = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);        IPEndPoint point = new IPEndPoint(IPAddress.Parse(txtIP.Text), Convert.ToInt32(txtPort.Text));        socketClient.Connect(point);        showMsg(socketClient.RemoteEndPoint.ToString() + "  连接成功");        Thread th = new Thread(Receive);        th.IsBackground = true;        th.Start();    }    catch    {    }    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><strong>打印信息</strong></li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">private void showMsg(string str){    txtLog.AppendText(str + "\r\n");}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li><strong>接收消息</strong></li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">private void Receive()//(object socketClientObj){    // Socket socketClient = socketClientObj as Socket;    while (true)    {        try        {            byte[] buffer = new byte[1024 * 1024 * 3];            int num = socketClient.Receive(buffer);            if (num == 0)            {                showMsg("断开连接");                break;            }            // 根据标识执行对应动作            // 文字消息            if (buffer[0] == 0)            {                string str = Encoding.UTF8.GetString(buffer, 1, num-1);                showMsg(socketClient.RemoteEndPoint.ToString() + "  " + str);            }            else if (buffer[0] == 1)            {                SaveFileDialog sfd = new SaveFileDialog();                sfd.InitialDirectory = @"";                sfd.Title = "请选择要保存的文件";                sfd.Filter = "所有文件|*.*";                sfd.ShowDialog(this);                string path = sfd.FileName;                using(FileStream fsWrite = new FileStream(path, FileMode.OpenOrCreate, FileAccess.Write))                {                    fsWrite.Write(buffer, 1, num-1);                }                MessageBox.Show("保存成功");            }        }        catch        {        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><strong>发送消息</strong></li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">private void btnSend_Click(object sender, EventArgs e){    string str = txtMsg.Text;    byte[] buffer = Encoding.UTF8.GetBytes(str);    socketClient.Send(buffer);    txtMsg.Clear();}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="6-4-委托"><a href="#6-4-委托" class="headerlink" title="6.4 委托"></a>6.4 委托</h3><h4 id="6-4-1-关于委托的一些问题"><a href="#6-4-1-关于委托的一些问题" class="headerlink" title="6.4.1 关于委托的一些问题"></a>6.4.1 关于委托的一些问题</h4><ul><li>为什么要使用委托<ul><li>为了将一个方法作为参数传递给另一个方法，此时传递的的方法应是委托类型</li></ul></li><li>==注意==<ul><li>委托所指向的函数必须与委托具有相同的签名</li><li>委托声明放在<code>class</code>外，<code>namespace</code>内</li></ul></li></ul><h4 id="6-4-2-委托的使用"><a href="#6-4-2-委托的使用" class="headerlink" title="6.4.2 委托的使用"></a>6.4.2 委托的使用</h4><h5 id="6-4-2-1-基本使用"><a href="#6-4-2-1-基本使用" class="headerlink" title="6.4.2.1 基本使用"></a>6.4.2.1 基本使用</h5><ul><li>有两个<strong>签名一致</strong>的函数</li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">public static void SayHiChinese(string name){    Console.WriteLine("早上好" + name);}public static void SayHiEnglish(string name){    Console.WriteLine("Nice to meet you " + name);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><strong>声明委托</strong>，委托需要与函数签名一致</li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">public delegate void DelSayHi(string name);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><p><strong>使用委托</strong></p><ul><li><strong>new</strong> 声明</li></ul></li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">DelSayHi del = new DelSayHi(SayHichinese);del("张山");<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li><strong>赋值</strong></li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 直接赋值DelSayHi del = SayHiChinese;del("张山");<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 传参赋值Test("张山", SayHiChinese);public static void Test(string name, DelSayHi del){    del(name);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="6-4-2-2-匿名函数"><a href="#6-4-2-2-匿名函数" class="headerlink" title="6.4.2.2 匿名函数"></a>6.4.2.2 匿名函数</h5><ul><li><p>当某个方法只需要执行一次的时候，可用将方法写成匿名函数</p></li><li><p>以前文代码为例</p></li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 当只需要中文的问好时// 可删掉 SayHiChines()，减少代码量DelSayHi del = delegate(string name){    Console.WriteLine("早上好"+name);};// 前几行代码也可以写为 lambda表达式// 参数指向方法体DelSayHi del = (string name) =&gt; {Console.WriteLine("早上好"+name);};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="6-4-2-3-泛型委托"><a href="#6-4-2-3-泛型委托" class="headerlink" title="6.4.2.3 泛型委托"></a>6.4.2.3 泛型委托</h5><ul><li><p>求任意数组的最大值（int[] 为数值最大，string[] 为长度最长）</p></li><li><p><strong>初始代码</strong></p></li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 返回 int 最大值public static int GetMax(int[] nums){    int max = nums[0];    for(int i = 0; i &lt; nums.Length; i++)    {        if(max &lt; nums[i])        {            max = nums[i];        }    }    return max;}// 返回 string 最长字符串// 函数重载public static string GetMax(string[] names){    string max = names[0];    for(int i = 0; i &lt; names.Length; i++)    {        if(max.Length &lt; names[i].Length)        {            max = names[i];        }    }    return max;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>为减少代码量，将两个方法使用**<code>object</code>替换**一个方法，并使用委托作为<code>if</code>的判断条件</li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 声明一个委托去处理判断条件的真假// 委托的返回值为 int// 参数与 GetMax 一致，使用 objectpublic delegate int DelCompare(object o1, object o2);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">public static object GetMax(object[] nums, DelCompare del){    object max = nums[0];    for(int i = 0; i &lt; nums.Length; i++)    {        // 传一个比较方法        if(del(max, nums[i]) &lt; 0)        {            max = nums[i];        }    }    return max;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 根据委托签名书写调用的比较函数// int类public static int Compare1(object o1, object o2){    int n1 = (int)o1;    int n2 = (int)o2;    return n1 - n2;}// string类public static string Compare2(object o1, object o2){string s1 = (string)o1;    string s2 = (string)o2;    return s1.Length - s2.Length;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// Main方法public static void Main(string[] args){    // 比较 int    object o1 = {1, 2, 3, 4, 5};    object result1 = GetMax(o1, Compare1);    Console.WriteLine(result1);        // 比较 string    object o2 = {"qwhdaj", "gakddnajdhowiud"};    object result2 = GetMax(o2, Compare2);    Console.WriteLine(result2);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>使用<code>object</code>类型涉及 装箱拆箱 ，继续使用 <strong>泛型</strong> 减少代码量</li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 使用泛型委托public static int DelCompare&lt;T&gt;(T o1, T o2);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 修改前文 public static object GetMax(object[] nums, DelCompare del)public static T GetMax&lt;T&gt;(T[] nums, DelCompare&lt;T&gt; del){    T max = nums[0];    for(int i = 0; i &lt; nums.Length; i++)    {        if(del(max, nums[i]) &lt; 0)        {            max = nums[i];        }    }    return max;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">public static int Compare1(int o1, int o2){    return o1 - o2;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// Main函数public static void Main(string[] args){    // int 类    int[] nums = {1, 2, 3, 4, 5};    int max = GetMax&lt;int&gt;(nums, Compare1);    Console.WriteLine(max);        // string 类    string[] names = {"hdakd", "hsadopjadlja"};    string result = GetMax&lt;string&gt;(names, (string s1, string s2) =&gt; {        return s1.Length - s2.Length;});    COnsole.WriteLine(result);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="6-4-2-4-Lambda表达式"><a href="#6-4-2-4-Lambda表达式" class="headerlink" title="6.4.2.4 Lambda表达式"></a>6.4.2.4 Lambda表达式</h5><ul><li><code>Lambda表达式</code>本质上还是<code>匿名函数</code></li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">DelCompare del = (string name) =&gt; {Console.WriteLine(name)};<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">List&lt;int&gt; list = new List&lt;int&gt;(){1, 2, 3, 4, 5, 6, 7};// 将 大于4 的全部删除list.RemoveAll(n =&gt; n&gt;4);foreach(var item in list){    Console.WriteLine(item);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="6-5-事件"><a href="#6-5-事件" class="headerlink" title="6.5 事件"></a>6.5 事件</h3><h4 id="6-5-1-关于事件的一些问题"><a href="#6-5-1-关于事件的一些问题" class="headerlink" title="6.5.1 关于事件的一些问题"></a>6.5.1 关于事件的一些问题</h4><ul><li>==委托与事件的区别==<ul><li>委托是对方法的引用，而事件是一种特殊的委托，用于实现观察者模式，方便对象在状态变化时通知其他对象</li><li>委托不安全，事件的本质是一个安全的委托</li><li>委托在哪都可以调用，而事件只能在类内进行调用</li><li>委托是一种类型，事件是基于委托的一种机制，通过”Event”关键字进行声明</li><li>委托允许直接调用委托实例所引用的方法，而事件只能通过”+=“和”-=“来添加移除事件处理程序</li><li>实际应用时，事件能够提供更灵活的机制来处理对象间的通信</li></ul></li></ul><h4 id="6-5-2-事件的使用"><a href="#6-5-2-事件的使用" class="headerlink" title="6.5.2 事件的使用"></a>6.5.2 事件的使用</h4><h5 id="6-5-2-1-基本使用"><a href="#6-5-2-1-基本使用" class="headerlink" title="6.5.2.1 基本使用"></a>6.5.2.1 基本使用</h5><ul><li><p>以按键播放音乐为例</p></li><li><p>创建<code>PlayMusic</code>类，并在其中<strong>定义委托事件</strong></p></li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 声明事件之前要先创建委托public delegate void DelPlayOver();internal class PlayMusic{// 声明事件    // 若没有event，那么public DelPlayOver Del;就是委托    public event DelPlayOver Del;        // 音乐名    public string Name{get;set;}    public PlayMusic(string name)    {        this.Name = name;    }        // 播放音乐    public void PlaySongs()    {        Console.WriteLine("正在播放" + this.Name);                // 模拟播放耗时        Thread.Sleep(3000);                if(Del != null)        {            // 执行对应事件            Del();        }    }    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><strong>绑定事件</strong>，并执行相应方法</li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">private void button1_Click(object sender, EventArgs e){    PlayMusic p = new PlayMusic("哈哈哈哈哈");        // 注册事件    // 委托在调用方法时，p.Del = Test;    p.Del += Test;        p.PlaySongs();}// 事件绑定方法public void Test(){    Console.WriteLine("播放完成了！！！");}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="6-6-关于文件"><a href="#6-6-关于文件" class="headerlink" title="6.6 关于文件"></a>6.6 关于文件</h3><h4 id="6-6-1-File-类"><a href="#6-6-1-File-类" class="headerlink" title="6.6.1 File 类"></a>6.6.1 File 类</h4><ul><li>用于==读小文件==，因为<code>File</code>类是一下读完问文本，所以在读大文件会对内存造成较大的负荷</li></ul><h5 id="6-6-1-1-基本操作"><a href="#6-6-1-1-基本操作" class="headerlink" title="6.6.1.1 基本操作"></a>6.6.1.1 基本操作</h5><ul><li><strong>创建</strong>文件</li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">File.Create(@"C:\Users\echo\Desktop\new.txt");<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><strong>删除</strong>文件</li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">File.Delete(@"C:\Users\echo\Desktop\new.txt");<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><strong>复制</strong>文件</li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">File.Copy(@"C:\Users\echo\Desktop\old.txt",@"C:\Users\echo\Desktop\new.txt");<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><strong>剪切</strong>文件</li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">File.Move(@"C:\Users\echo\Desktop\old.txt",@"C:\Users\echo\Desktop\new.txt")<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h5 id="6-6-1-2-读取文本"><a href="#6-6-1-2-读取文本" class="headerlink" title="6.6.1.2 读取文本"></a>6.6.1.2 读取文本</h5><ul><li><p><code>ReadAllBytes()</code>可读取任何文件（文本、图片、音乐等），需要转为字节；后两个方法<code>ReadAllLines()</code>和<code>ReanAllText()</code>，只能读文本文件</p></li><li><p>将文本<strong>读取为字节</strong></p></li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">byte[] buffer = File.ReadAllBytes(@"C:\Users\echo\Desktop\old.txt");// 字节看不懂，转为字符串// GetEncoding()，指定编码格式string s = Encoding.GetEncoding("GB2312").GetString(buffer);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><strong>按行读取</strong></li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 按行读取，返回字符串数组string[] contents = File.ReadAllLines(@"C:\Users\echo\Desktop\old.txt",Encoding.Deffault);foreach(string item in contents){    Console.WriteLine(item);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><strong>全部读完</strong></li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 一下读完，返回一个stringstring str = File.ReanAllText(@"C:\Users\echo\Desktop\old.txt",Encoding.Deffault);Console.WriteLine(str);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h5 id="6-6-1-3-写入文本"><a href="#6-6-1-3-写入文本" class="headerlink" title="6.6.1.3 写入文本"></a>6.6.1.3 写入文本</h5><ul><li><strong>覆盖写入字节</strong></li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 读取时，如果没有对应文件，会自行创建；有的话，进行覆盖// 将字符串转为字节存储到文件中string str = "你干嘛哎哟";// Default 默认编码byte[] buffer = Encoding.Default.GetBytes(str);File.WriteAllBytes(@"C:\Users\echo\Desktop\new.txt",buffer);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><strong>覆盖按行写入</strong></li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">string[] str = new string[] {"sdf","jklj"};File.WriteAllLines(@"C:\Users\echo\Desktop\new.txt",str);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li><strong>覆盖全部写入</strong></li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">string str = "gakjfhlahfl";File.WriteAllText(@"C:\Users\echo\Desktop\new.txt",str);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li><strong>追加写入</strong></li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">File.AppendAllText();File.AppendAllLines();File.AppendText();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="6-6-2-编码简介"><a href="#6-6-2-编码简介" class="headerlink" title="6.6.2 编码简介"></a>6.6.2 编码简介</h4><ul><li>文本文件编码，文本文件有不同的存储方式，将字符串以特定的形式保存为二进制就是编码<ul><li>编码有<code>UTF8（web）、ASCII（字母、数字、音标）、Unicode（包含各种字体，但是解析慢）、GB2312（简体字）、Big5（简体 + 繁体字）</code></li><li><code>Unicode = UTF7 + UTF8 + UTF32</code></li></ul></li><li>文本<strong>乱码</strong>原因<ul><li>产生乱码的原因是  保存文件  时所采用的编码格式与  打开文件  时的编码格式不一样</li></ul></li></ul><h4 id="6-6-3-FileStream-类"><a href="#6-6-3-FileStream-类" class="headerlink" title="6.6.3 FileStream 类"></a>6.6.3 FileStream 类</h4><ul><li>读取文件时，是一点一点去读，不会对内存造成压力</li><li><code>FileStream</code>用于==操作字节==</li><li><code>FileStream</code>不会被垃圾回收机制处理，需要手动释放流所占用的内存</li></ul><h5 id="6-6-3-1-读取"><a href="#6-6-3-1-读取" class="headerlink" title="6.6.3.1 读取"></a>6.6.3.1 读取</h5><ul><li>读小文件</li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 创建FileStream对象// FileMode：对文件要进行的操作// FileAccess；对文本内容要进行的操作FileStream fsRead = new FileStream(@"C:\Users\echo\Desktop\new.txt",FileMode.OpenOrCreate,FileAccess.Read);// 创建 byte[] 去接收读取到的字节信息byte[] buffer = new byte[1024 * 1024 * 5];// 返回实际 读取到的有效字节数int r =fsRead.Read(buffer,0,buffer.Length);// 将字节数组中每一个元素按照指定编码格式解码为字符串string s = Encoding.Default.GetString(buffer,0,r);// 关闭流，释放流所占用的资源fsRead.Close();fsRead.Dispose();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="6-6-3-2-写入"><a href="#6-6-3-2-写入" class="headerlink" title="6.6.3.2 写入"></a>6.6.3.2 写入</h5><ul><li><strong>自动释放流</strong>的写法</li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 自动释放流using(FileStream name = new FileStream()){    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">using(FileStream fsWrite = new FileStream(@"C:\Users\echo\Desktop\new.txt",FileMode.OpenOrCreate,FileAccess.Write)){    string str = "oaflalfjklaj";    byte[] buffer = Encoding.Default.GetBytes(str);    fsWrite.Write(buffer,0,buffer.Length);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="6-6-3-3-基于FileStream的多媒体文件复制"><a href="#6-6-3-3-基于FileStream的多媒体文件复制" class="headerlink" title="6.6.3.3 基于FileStream的多媒体文件复制"></a>6.6.3.3 基于FileStream的多媒体文件复制</h5><ul><li><code>CopyFile</code>方法</li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 传入源文件路径、复制文件路径public static void CopyFile(string source,string target){    // 首次创建一个负责读取的流    using (FileStream fsRead = new FileStream(source,FileMode.Open,FileAccess.Read))    {        // 创建写入流        using (FileStream fsWrite = new FileStream(target,FileMode.OpenOrCreate,FileAccess.Write))        {            byte[] buffer = new byte[1024 * 1024 * 5];            // 因为文件可能会比较大，所以循环读取            while (true)            {                // Read：读取相应字节长度，然后将文件流的位置移动到已读取位置之后                int r = fsRead.Read(buffer, 0, buffer.Length);                // 读取完成                if(r == 0)                {                    break;                }                // 追加写入                fsWrite.Write(buffer, 0, r);            }        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>Main()</code>方法</li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">static void Main(string[] args){    string source = @"C:\Users\echo\Desktop\Music\解解的神仙现场 - 海阔天空 - 邓紫棋 (2023时光音乐会老友记现场).wav";    string target = @"C:\Users\echo\Desktop\解解的神仙现场.wav";    CopyFile(source, target);    Console.WriteLine("复制成功");}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="6-6-4-StreamReader和StreamWriter"><a href="#6-6-4-StreamReader和StreamWriter" class="headerlink" title="6.6.4 StreamReader和StreamWriter"></a>6.6.4 StreamReader和StreamWriter</h4><ul><li>操作字符、文本</li></ul><h5 id="6-6-4-1-StreamReader"><a href="#6-6-4-1-StreamReader" class="headerlink" title="6.6.4.1 StreamReader"></a>6.6.4.1 StreamReader</h5><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">using (StreamReader sr = new StreamReader(@"C:\Users\echo\Desktop\解解的神仙现场.txt", Encoding.Default)){    // 当没有读到文本末尾，循环打印读取到的行    while (!sr.EndOfStream)    {        Console.WriteLine(sr.ReadLine());    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="6-6-4-2-StreamWriter"><a href="#6-6-4-2-StreamWriter" class="headerlink" title="6.6.4.2 StreamWriter"></a>6.6.4.2 StreamWriter</h5><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 不存在的文件，会自行创建using (StreamWriter sw = new StreamWriter(@"C:\Users\echo\Desktop\new.txt",true)){    // 会覆盖源文本    // 添加一个 true 后，不会进行覆盖    sw.WriteLine("你赶紧的卡");}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="七、SQL数据库"><a href="#七、SQL数据库" class="headerlink" title="七、SQL数据库"></a>七、SQL数据库</h2><ul><li>存储数据的仓库</li><li><strong>增删改查</strong></li></ul><h3 id="7-1-SQLServer使用"><a href="#7-1-SQLServer使用" class="headerlink" title="7.1 SQLServer使用"></a>7.1 SQLServer使用</h3><h4 id="7-1-1-创建登录名"><a href="#7-1-1-创建登录名" class="headerlink" title="7.1.1 创建登录名"></a>7.1.1 创建登录名</h4><ul><li><p>创建<code>SQL Server</code>身份，设置用户名和密码<img src="image-20240108190413092-1705156191297-37.png" alt="" style="zoom: 50%;"></p></li><li><p><code>服务器角色</code>，服务器名最大权限为<code>sysadmin</code>，要作为管理员身份对数据库进行使用，可以将其勾选上<img src="image-20240108190723983-1705156191297-38.png" alt="" style="zoom: 50%;"></p></li><li><p>带  ×  的账户，可通过<code>双击</code>，并将<code>强制实施密码策略</code>取消勾选，并将<code>状态/登录名</code>勾选为<code>启动</code></p></li></ul><h4 id="7-1-2-登录SQL账户"><a href="#7-1-2-登录SQL账户" class="headerlink" title="7.1.2 登录SQL账户"></a>7.1.2 登录SQL账户</h4><ul><li><p>创建好登录名后，首先修改<code>服务器身份验证</code>，选中<code>服务器</code>，右键<code>属性</code>，点击<code>安全性</code>，勾选<code>SQL Server 和 Windows 身份验证模式</code></p></li><li><p>然后电脑底部搜索框搜索<code>SQL</code>，进入<code>SQL Server 网络配置</code>，进入<code>MSSQLSERVER 的协议</code>，启用<code>Named Pipes</code>和<code>TCP/IP</code></p></li><li><p>再选中<code>服务器名称</code>，右键选择<code>重新启动</code>，进行<code>SQL 账户</code>登录</p></li><li><p>若二次登录，出现==无法连接==的情况</p><ul><li><p><a href="https://blog.csdn.net/l5615461/article/details/123120106">安装完SQL Server后,解决本地服务器连接失败的方法(仅供参考)_sql server连不上本地服务器-CSDN博客</a></p></li><li><blockquote><p>此电脑 –&gt; 右键-管理 –&gt; 服务与应用程序-服务 –&gt; SQL Server(MSSQLSERVER) –&gt; 右键-启动</p></blockquote></li></ul></li></ul><h4 id="7-1-3-创建数据库"><a href="#7-1-3-创建数据库" class="headerlink" title="7.1.3 创建数据库"></a>7.1.3 创建数据库</h4><ul><li>选中<code>数据库</code>文件夹，右键<code>新建数据库</code></li><li>设置<code>数据库名称</code>，自动生成<code>数据库文件（数据文件 和 日志文件）</code></li><li>对于两个数据库文件，可以自定义<code>初始大小（初始内存）</code>，并设置<code>增长大小（当文件内容长度超过初始大小后，自动增加内存）</code>，另外可更改 数据库文件 <code>存放路径</code></li><li>如，建立一个名为 <u>SQL学习测试</u> 的数据库，初始内存大小及增长 使用默认参数，文件路径改为 <u>D:\Program Files\Microsoft SQL Server\学习测试\数据库</u><img src="image-20240108200949234-1705156191297-39.png" alt="" style="zoom: 33%;"></li></ul><h4 id="7-1-4-删除数据库"><a href="#7-1-4-删除数据库" class="headerlink" title="7.1.4 删除数据库"></a>7.1.4 删除数据库</h4><ul><li><p>==删除数据库文件==，直接删除是删除不了的，因为数据库有一个监听端口，创建一个数据库就会自动建立一个监听连接，数据库被管理起来<img src="image-20240108201202870-1705156191297-40.png" alt="" style="zoom:50%;"></p></li><li><p>若要删除，首先选中 数据库 文件夹，右键<code>任务 -&gt; 分离</code>，并勾选<code>删除连接</code>，点击<code>确认</code>，移除该数据库<img src="/2024/01/13/shang-wei-ji/image-20240108201621911-1705156191297-41.png" alt="image-20240108201621911"></p></li><li><p>移除之后，便可对两个<code>数据库文件</code>进行删除</p></li></ul><h4 id="7-1-5-还原数据库"><a href="#7-1-5-还原数据库" class="headerlink" title="7.1.5 还原数据库"></a>7.1.5 还原数据库</h4><ul><li>若<code>数据文件</code>还存在，通过选中<code>数据库</code>，右键<code>附加</code>，然后<code>添加</code>，选择<code>.mdf</code>文件，<code>确认</code>即可还原<img src="/2024/01/13/shang-wei-ji/image-20240108202327547-1705156191297-42.png" alt="image-20240108202327547"></li></ul><h4 id="7-1-6-新建表"><a href="#7-1-6-新建表" class="headerlink" title="7.1.6 新建表"></a>7.1.6 新建表</h4><ul><li><p>选中<code>数据库</code>下的<code>表</code>文件夹，右键<code>新建 -&gt; 表</code>，设置<code>列名</code>等<img src="image-20240108205049779-1705156191297-43.png" alt="" style="zoom:50%;"></p></li><li><p>录入数据<img src="image-20240108205259257.png" alt="" style="zoom: 33%;"><img src="image-20240108205432705-1705156191297-45.png" alt="" style="zoom: 33%;"></p></li></ul><h4 id="7-1-7-使用SQL脚本"><a href="#7-1-7-使用SQL脚本" class="headerlink" title="7.1.7 使用SQL脚本"></a>7.1.7 使用SQL脚本</h4><ul><li><p>首先进入脚本界面，选中数据库，并<code>新建查询</code><img src="image-20240108205832210-1705156191297-46.png" alt="" style="zoom: 50%;"></p></li><li><p>一些脚本代码</p><ul><li>启动数据库</li></ul></li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">/*-- 启动指定数据库-- use 数据库名-- go*/// 下面代码为 SQL 语言，之后的代码也一样use SQL学习测试go<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>添加数据</li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// -- 添加  insert into ，into这个关键词可以省略// SQL 语言insert Product([ProductNo], [ProductName], [ProductImage], [Price])values(1002,'华为','image/xxx.jpg',9000)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>删除数据</li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// -- 删除 delete from，from这个关键词也可以省略// SQL 语言delete Productwhere productName='华为'   -- where 关键词是条件<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>修改数据</li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// -- 修改 update// SQL 语言update Productset productname='华为mate40',productimage='image/huawei.jpg',price=10000where productNo=1003<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>查询数据</li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// -- 查询 select ... from ...// SQL 语言select * from Product  -- * 代表所有列select [ProductNo], [ProductName] from Product  -- 查询指定列where not productno=1001  -- 逻辑关键词 not and or 举例：where prductno=1003 or price&gt;5000<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="7-1-8-数据关联"><a href="#7-1-8-数据关联" class="headerlink" title="7.1.8 数据关联"></a>7.1.8 数据关联</h4><h5 id="7-1-8-1-创建数据关联关系"><a href="#7-1-8-1-创建数据关联关系" class="headerlink" title="7.1.8.1 创建数据关联关系"></a>7.1.8.1 创建数据关联关系</h5><ul><li>选中表格，右键<code>关系</code>，<code>添加</code>一个关系</li><li>在<code>常规</code>里，选中<code>表和列规范</code>的<code>...</code>，设置主键表和外键表</li><li>并将<code>在创建或重新启用时检查现有数据</code>设置为<code>否</code></li></ul><img src="image-20240109165325630-1705156191297-47.png" alt="" style="zoom:33%;"><h5 id="7-1-8-2-关联表查询"><a href="#7-1-8-2-关联表查询" class="headerlink" title="7.1.8.2 关联表查询"></a>7.1.8.2 关联表查询</h5><ul><li><p>一些查询代码示例</p><ul><li>外联接</li></ul></li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// -- 外联接 inner join// -- as 关键字可以进行重命名// -- 表格也可以取别名 如：Product a// SQL 语言select [ProductNo] as 编号, [ProductName], [ProductImage], [Price], a.[typeId], b.typeName// -- 对表格取别名from Product a inner join ProductType bon(a.typeId = b.typeId)// -- 如果还有表需要关联检索，继续写 inner join... on...// -- inner join otherTable// -- on(a.ProductName=otherTable.Name)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>内联接</li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// -- 左外联接 left join    以左表为基准进行匹配，匹配到了就显示，没匹配到就不显示// SQL 语言select [ProductNo], [ProductName], [ProductImage], [Price], Product.[typeId], ProductType.typeNamefrom ProductType left join Producton(Product.typeId = ProductType.typeId)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// -- 右外联接 right join// SQL 语言select [ProductNo], [ProductName], [ProductImage], [Price], Product.[typeId], ProductType.typeNamefrom ProductType right join Producton(Product.typeId = ProductType.typeId)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="7-1-9-聚合函数"><a href="#7-1-9-聚合函数" class="headerlink" title="7.1.9 聚合函数"></a>7.1.9 聚合函数</h4><ul><li><p>除了<code>count()</code>，其余的<code>avg() / sum() / max() / min()</code>均针对<strong>数字类型和日期</strong></p></li><li><p>计数<code>count()</code></p></li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// -- count 统计记录条数，当有一列中的某个单元格值为 NULL 时，不对其进行计数// SQL 语言select COUNT(ProductName) from Product// -- 统计全部，count()参数可写 */1select count(*) from Productselect count(1) from Product<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>求均值<code>avg()</code></li></ul><pre class="line-numbers language-C#" data-language="C#"><code class="language-C#">// SQLselect avg(Price) from Product<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>求和<code>sum()</code></li></ul><pre class="line-numbers language-C#" data-language="C#"><code class="language-C#">// SQLselect sum(Price) from Product<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>求最值<code>max() / min()</code></li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// SQLselect max(Price) from Productselect min(Price) from Product<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="7-1-10-排序与分组查询"><a href="#7-1-10-排序与分组查询" class="headerlink" title="7.1.10 排序与分组查询"></a>7.1.10 排序与分组查询</h4><ul><li>排序<code>order by ... asc/desc</code></li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// -- 排序 order by asc/desc  升序/降序// SQLselect * from Product// -- 先用 Price 降序排列，若 Price 有相同值，再用 typeId 进行二次降序排列order by Price desc,typeId asc  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>分组<code>group by</code></li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// -- 分组 group by // SQLselect ProductType.typeName as 类型, count(Product.ProductNo) as 数量from Product left join ProductTypeon(Product.typeId=ProductType.typeId)// -- wheregroup by ProductType.typeNameorder by 数量 desc<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>一些==注意事项==</p><ul><li><blockquote><p>– 语法有一定顺序<br>– order 一定在最后<br>– group 在 order 前面<br>– where 在 group 前面，select…from …on..后面</p></blockquote></li></ul></li></ul><h3 id="7-2-C-中使用SQL"><a href="#7-2-C-中使用SQL" class="headerlink" title="7.2 C#中使用SQL"></a>7.2 C#中使用SQL</h3><h4 id="7-2-1-基本步骤"><a href="#7-2-1-基本步骤" class="headerlink" title="7.2.1 基本步骤"></a>7.2.1 基本步骤</h4><blockquote><p>案例见<code>D:\Program Files\Microsoft Visual Studio\projects\毕设\数据库学习\用户登录\UserLogIn</code></p></blockquote><ul><li>第一步：创建数据库对象</li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">/*字符串参数分别为：Server   : 服务器名称uid     : 登录名pwd      : 密码database : 数据库名称*/SqlConnection conn = new SqlConnection("Server = LAPTOP-H5KQEA5B;uid = demo; pwd = 123456;database = SQL学习测试");<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>第二步：打开数据库</li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">conn.Open();<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>第三步：创建执行脚本对象</li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">string qq = this.txtQQ.Text;string pwd = this.txtPwd.Text;// SQL脚本代码string sql = $"select count(1) from UserInfos where qq = '{qq}' and pwd = '{pwd}'";// 脚本对象构造函数参数：(脚本代码字符串, 数据库对象)SqlCommand cmd = new SqlCommand(sql, conn);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>第四步：执行脚本</li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 执行脚本，并调用相应方法获取指定返回值// 如：返回脚本执行后结果的第一行第一列int result = (int)cmd.ExecuteScalar();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li>第五步：关闭数据库连接对象</li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">conn.Close();<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="7-2-2-防SQL注入"><a href="#7-2-2-防SQL注入" class="headerlink" title="7.2.2 防SQL注入"></a>7.2.2 防SQL注入</h4><blockquote><p>按 《用户登录》项目输入账号<code>10001</code> ，密码不输入<code>123456</code>，而输入<code>' or 1=1 --</code>，也会成功登录，为了避免此情况发生，在c#程序中，对代码进行处理，避免SQL注入</p></blockquote><ul><li>首先，通过<code>SqlParameter</code>对象进行参数化</li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">// 构造函数参数为：("@数据库元素名称", 用户输入Text)SqlParameter para1 = new SqlParameter("@qq", qq);SqlParameter para2 = new SqlParameter("@Pwd", pwd);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li>然后，在脚本对象<code>SqlCommand</code>后，对<code>SqlParameter</code>对象进行添加</li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">cmd.Parameters.Add(para1);cmd.Parameters.Add(para2);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>六级技巧</title>
      <link href="/2023/03/05/liu-ji-ji-qiao/"/>
      <url>/2023/03/05/liu-ji-ji-qiao/</url>
      
        <content type="html"><![CDATA[<h1 id="写作"><a href="#写作" class="headerlink" title="写作"></a>写作</h1><h2 id="找模板"><a href="#找模板" class="headerlink" title="找模板"></a>找模板</h2><p>六级要求150字，写作时，可以去找些模板</p><ul><li>比如，写作基本上会写到某个东西会带来很多好处：</li></ul><pre class="line-numbers language-English" data-language="English"><code class="language-English">一般会写：There are many advantages.可换成：The benefits of ... are innumerable and manifold.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>大多数文章开头可以使用</li></ul><pre class="line-numbers language-none"><code class="language-none">As is known to all它不会对原文意思产生任何影响，且算作非限定性定语从句，可以加分<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="高级词汇替换"><a href="#高级词汇替换" class="headerlink" title="高级词汇替换"></a>高级词汇替换</h2><ul><li>如<code>with the development of</code>，语句本身没有什么错误，但是这么多年四六级，该语句已经被用烂了，可以换成</li></ul><pre class="line-numbers language-English" data-language="English"><code class="language-English">1. Due to the proliferation of2. Due to the pervasive use of<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li><code>a lot of</code>可替换为</li></ul><pre class="line-numbers language-none"><code class="language-none">1. a substantial number/amount of 2. plenty of<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h1 id="听力"><a href="#听力" class="headerlink" title="听力"></a>听力</h1><p>神学</p><h2 id="网上有部分蒙题技巧："><a href="#网上有部分蒙题技巧：" class="headerlink" title="网上有部分蒙题技巧："></a>网上有部分蒙题技巧：</h2><ol><li><p>阴盛阳衰-女强男弱原则：女性提出的观点和要求，男生一般都会同意；但是男生的观点，女生一般不会同意</p></li><li><p>政治敏感内容正确原则：一个选项，如果涉及国家政治方面的言论，一般这个选项都是对的</p></li><li><p>积极观点原则：一般叛逆的负能量的内容，很大可能就是错的；积极乐观的内容，一般都是对的</p></li><li><p>答案分配原则：一共25道题，平均分，再加上选项任意一个；每组听力5个选项，每组选项都是abcd加上任意一个</p></li><li><p>当两个选项意思差不多的时候，又听不出来，就选更为全面的那一个</p></li><li><p>长对话一般听到什么就选什么，一般长对话的第一个题，会在对话前3句就设置答案</p></li><li><p>短对话，需要推理，直接听到的一般都不是正确答案</p></li><li><p>出现次数多的单词，一般都是答案</p></li><li><p>故事的结果往往都是不好的，比如说买票买不上、作业很多、租房租不了、聚会迟到、飞机晚点、邀约失败、外出发生意外等等</p></li></ol><h2 id="词汇量2000以上大哥的蒙题技巧："><a href="#词汇量2000以上大哥的蒙题技巧：" class="headerlink" title="词汇量2000以上大哥的蒙题技巧："></a>词汇量2000以上大哥的蒙题技巧：</h2><ol><li><p>看选项蒙题：两个选项意思==相反或类似==，答案肯定就在这两个里面。然后就要在相似里找不同，不同里找相似，如：<img src="/2023/03/05/liu-ji-ji-qiao/image-20230305214637686.png">图中ABC都有mobile phone和on the moon，先排除D，而C与AB相似性最大，所以选C<img src="/2023/03/05/liu-ji-ji-qiao/image-20230305214828697.png"></p></li><li><p>如果找不到相似性，记住 ==“包含取大”== 原则  —-  概括+抽象 &gt; 具体+叙述性  ，就是说选项里更概括更抽象的更容易对，如：<img src="/2023/03/05/liu-ji-ji-qiao/image-20230305215224644.png">选项中，C是包含且大于AB的，所以选C<img src="/2023/03/05/liu-ji-ji-qiao/image-20230305215326589.png"></p></li><li><p>听力每个题的第一个和最后一个问，一定在原文前两句和最后两句话里。所以==重点来了==，如果四个选项各说各的，没有任何规律的话，也没有听懂原文说什么，也没有 not/but 这种转折词的话，四级听到啥选啥，六级没说我靠。。。搞错了，六级把听到原词的选项划掉，它的答案一定是同义替换或者是替换词性</p></li><li><p>如果两个选项都有听到词，那哪个选项出现的词更多就选哪个</p></li><li><p>固定场景固定剧情，从往年考题分析，对话发展趋势大概率是不好的，一般是有了冲突，才会有接下来的对话。所以听到邀请，大概率是不答应；交通工具买不到票又晚点；面试会很紧张；工作很难找；读书没读完；作业会很难；讲座会很无聊<img src="/2023/03/05/liu-ji-ji-qiao/image-20230305220339214.png"><img src="/2023/03/05/liu-ji-ji-qiao/image-20230305220403674.png"></p></li><li><p>女神大法好，一般男女对话，女生准确率会更高</p></li></ol><h1 id="阅读"><a href="#阅读" class="headerlink" title="阅读"></a>阅读</h1><p>词汇量是最可靠的技巧</p><ul><li><p>利用碎片化时间</p></li><li><p>少量多次重复背（人类记忆-艾宾浩斯曲线）</p></li><li><p>四六级官方也有单词表，可以去找来背</p></li></ul><h2 id="阅读技巧"><a href="#阅读技巧" class="headerlink" title="阅读技巧"></a>阅读技巧</h2><ul><li>出题顺序和段落顺序一致，先读题干，圈出关键词（大写、数字、特殊符号、最陌生的名动形副）</li></ul><h2 id="网传蒙题技巧"><a href="#网传蒙题技巧" class="headerlink" title="网传蒙题技巧"></a>网传蒙题技巧</h2><ol><li>蒙题逻辑原则 —- 定位</li><li>看选项蒙：照抄原文的（X），去选同义替换，选那种70%相似的选项；选表达比较概括抽象的；蒙答案更积极向上的<img src="/2023/03/05/liu-ji-ji-qiao/image-20230305220809612.png" alt="image-20230305220809612"><img src="/2023/03/05/liu-ji-ji-qiao/image-20230305220824031.png"></li><li>看语气蒙：那种特别绝对的语气词，比如must / never / have to 这一种，很少会对，除非原文就是这么绝对；那种不确定的词，如 could / might 大可能是对的</li><li>看大难分布蒙：四六级考试，答案分布非常严谨，ABCD四个选项分布占比会非常平均</li></ol><h1 id="翻译"><a href="#翻译" class="headerlink" title="翻译"></a>翻译</h1><p>考纲提到，翻译涉及中国的文化、历史、及社会发展热点</p><ul><li>官媒 China Daily ，它会总结社会热点的官方翻译</li></ul><h1 id="每日计划（假的）"><a href="#每日计划（假的）" class="headerlink" title="每日计划（假的）"></a>每日计划（假的）</h1><ul><li>起床先背半到一个小时单词</li><li>刷阅读和听力，每天半套到一套左右，因为 听力+阅读=70%</li><li>背一背高级替换词</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>python数据分析常用包</title>
      <link href="/2023/01/14/python-shu-ju-fen-xi-chang-yong-bao/"/>
      <url>/2023/01/14/python-shu-ju-fen-xi-chang-yong-bao/</url>
      
        <content type="html"><![CDATA[<h3 id="涉及python包"><a href="#涉及python包" class="headerlink" title="涉及python包"></a>涉及python包</h3><table><thead><tr><th align="center">包</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">Numpy</td><td align="center">科学计算</td></tr><tr><td align="center">Matplotlib</td><td align="center">绘图及数据可视化</td></tr><tr><td align="center">Pandas</td><td align="center">数据处理和清洗</td></tr></tbody></table><hr><hr><h3 id="分析什么数据？"><a href="#分析什么数据？" class="headerlink" title="分析什么数据？"></a>分析什么数据？</h3><ul><li>表格型数据</li><li>多维数组</li><li>用一列作为键，整合多个表格的数据</li><li>时间序列数据</li></ul><hr><hr><h3 id="Numpy"><a href="#Numpy" class="headerlink" title="Numpy"></a>Numpy</h3><h4 id="导包"><a href="#导包" class="headerlink" title="导包"></a>导包</h4><p><code>import numpy as np</code></p><hr><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><ul><li>以数组为导向的快速数值计算</li><li>灵活的广播功能</li><li>具有便利的数学函数和统计方法</li><li>线性代数，随机数生成，傅里叶变换</li></ul><hr><h4 id="数组创建"><a href="#数组创建" class="headerlink" title="数组创建"></a>数组创建</h4><p><code>np.array(可迭代对象，如列表、元组)</code></p><h5 id="一维数组创建举例"><a href="#一维数组创建举例" class="headerlink" title="一维数组创建举例"></a>一维数组创建举例</h5><p><code>a=np.array([1,2,3]) %列表</code></p><p><code>a=np.array((1,2,3)) %元组</code></p><p>两种创建方法得到的a均为:</p><blockquote><pre class="line-numbers language-none"><code class="language-none">array([1, 2, 3])<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></blockquote><h5 id="二维数组创建举例"><a href="#二维数组创建举例" class="headerlink" title="二维数组创建举例"></a>二维数组创建举例</h5><p><code>a=np.array([[1,2,3],[4,5,6]]) %对可迭代对象嵌套得到多维数组</code></p><p>得到的a:</p><blockquote><pre class="line-numbers language-none"><code class="language-none">array([[1, 2, 3],    [4, 5, 6]])<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></blockquote><h5 id="高维数组创建"><a href="#高维数组创建" class="headerlink" title="高维数组创建"></a>高维数组创建</h5><p>对可迭代对象进行嵌套实现</p><hr><h4 id="数组属性"><a href="#数组属性" class="headerlink" title="数组属性"></a>数组属性</h4><table><thead><tr><th align="center">属性</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">a.ndim</td><td align="center">查看矩阵秩即矩阵维数</td></tr><tr><td align="center">a.shape</td><td align="center">查看矩阵形状</td></tr><tr><td align="center">a.dtype</td><td align="center">查看元素Numpy数据类型</td></tr></tbody></table><hr><h4 id="numpy方法"><a href="#numpy方法" class="headerlink" title="numpy方法"></a>numpy方法</h4><h5 id="全0数组创建"><a href="#全0数组创建" class="headerlink" title="全0数组创建"></a>全0数组创建</h5><p><code>np.zeros() %参数为矩阵形状,多维用()括起来</code></p><p>举例</p><p><code>np.zeros(10) </code></p><blockquote><pre class="line-numbers language-none"><code class="language-none">array([0., 0., 0., 0., 0., 0., 0., 0., 0., 0.])<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></blockquote><h5 id="全1数组创建"><a href="#全1数组创建" class="headerlink" title="全1数组创建"></a>全1数组创建</h5><p><code>np.ones() %参数同样为矩阵形状,多维用()括起来</code></p><p>举例</p><p><code>np.ones((2,5))</code></p><blockquote><pre class="line-numbers language-none"><code class="language-none">array([[1., 1., 1., 1., 1.],    [1., 1., 1., 1., 1.]])<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></blockquote><h5 id="随机数组创建（有歧义，每次运行结果是一样的）"><a href="#随机数组创建（有歧义，每次运行结果是一样的）" class="headerlink" title="随机数组创建（有歧义，每次运行结果是一样的）"></a>随机数组创建（有歧义，每次运行结果是一样的）</h5><p><code>np.empty() %参数为矩阵形状,多维用()括起来</code></p><h5 id="序列数组创建"><a href="#序列数组创建" class="headerlink" title="序列数组创建"></a>序列数组创建</h5><p><code>np.arange() %类似range（）</code></p><p>举例</p><p><code>np.arange(10) %产生0-9的序列数组</code></p><blockquote><pre class="line-numbers language-none"><code class="language-none">array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></blockquote><h5 id="改变数组形状"><a href="#改变数组形状" class="headerlink" title="改变数组形状"></a>改变数组形状</h5><p><code>a.reshape() %参数为期望形状,多维可不用()括起来</code></p><p>举例</p><p><code>np.arange(6).reshape(2,3)</code></p><blockquote><pre class="line-numbers language-none"><code class="language-none">array([[0, 1, 2],    [3, 4, 5]])<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></blockquote><h5 id="绘图常用"><a href="#绘图常用" class="headerlink" title="绘图常用"></a>绘图常用</h5><p><code>np.linspace() %参数为：起始点（取），末端点（取），产生均匀分布的点数</code></p><p>举例</p><p><code>np.linspace(0,10,10)</code></p><blockquote><pre class="line-numbers language-none"><code class="language-none">array([ 0.        ,  1.11111111,  2.22222222,  3.33333333,  4.44444444,     5.55555556,  6.66666667,  7.77777778,  8.88888889, 10.        ])<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></blockquote><h5 id="创建指定数据类型"><a href="#创建指定数据类型" class="headerlink" title="创建指定数据类型"></a>创建指定数据类型</h5><p>举例</p><p><code>a=np.array([1,2,3],dtype=np.float32) %将默认的int32指定为float32</code></p><p><code>np.zeros(10,dtype=np.int32) %将默认的float64指定为int32</code></p><h5 id="已有数组转换数据类型"><a href="#已有数组转换数据类型" class="headerlink" title="已有数组转换数据类型"></a>已有数组转换数据类型</h5><p><code>a.astype() %参数为numpy数据类型</code></p><p>举例</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">a=np.array([True,False,False,True])a.astype(np.int16)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><blockquote><pre class="line-numbers language-none"><code class="language-none">array([1, 0, 0, 1], dtype=int16)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></blockquote><hr><h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><h5 id="int"><a href="#int" class="headerlink" title="int_"></a>int_</h5><p>int16/int32/int64，分别为占16、32、64位的有符号整形；</p><p>uint8常用于处理图片，uint16 32 64，无符号整型</p><h5 id="float"><a href="#float" class="headerlink" title="float_"></a>float_</h5><p>float16 32 64，浮点数</p><h5 id="complex"><a href="#complex" class="headerlink" title="complex"></a>complex</h5><p>complex64等，复数类型</p><h5 id="bool"><a href="#bool" class="headerlink" title="bool_"></a>bool_</h5><p>True/False，占1位，布尔</p><h5 id="string"><a href="#string" class="headerlink" title="string"></a>string</h5><hr><h4 id="数组切片及索引"><a href="#数组切片及索引" class="headerlink" title="数组切片及索引"></a>数组切片及索引</h4><h5 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h5><p>举例</p><pre class="line-numbers language-none"><code class="language-none">arr=np.arange(10)arr[5:8]arr[2:8:2]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><blockquote><pre class="line-numbers language-none"><code class="language-none">array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])   %arr=np.arange(10)array([5, 6, 7])   %arr[5:8]array([2, 4, 6])   %arr[2:8:2]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></blockquote><p>==注意：==</p><ol><li>数组视图复制，修改新数组会改变原数组</li></ol><pre class="line-numbers language-none"><code class="language-none">a2=arr[5:8]a2[0]=100<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><blockquote><pre class="line-numbers language-none"><code class="language-none">array([100,   6,   7]) %a2array([  0,   1,   2,   3,   4, 100,   6,   7,   8,   9]) %arr<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></blockquote><ol start="2"><li>数组深层复制，使用copy()方法，新数组修改不会改变原数组</li></ol><pre class="line-numbers language-none"><code class="language-none">a3=arr[5:8].copy()a3[1]=1000<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><blockquote><pre class="line-numbers language-none"><code class="language-none">array([   5, 1000,    7]) %a3array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></blockquote><h5 id="高维索引"><a href="#高维索引" class="headerlink" title="高维索引"></a>高维索引</h5><p>索引即可分层写，也可写一起</p><pre class="line-numbers language-none"><code class="language-none">a4=np.arange(24).reshape(2,3,4)%创建0-23序列的2*3*4矩阵%读取0页2行1列具体元素a4[0][2][1]a4[0,2,1]%读取所有页0行前3列元素a4[:, 0, :3]%所有页0行2列元素a4[:, 0, 2]%所有页所有行2到最后列元素a4[:, :,2:]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><pre class="line-numbers language-none"><code class="language-none">array([[[ 0,  1,  2,  3],     [ 4,  5,  6,  7],     [ 8,  9, 10, 11]],    [[12, 13, 14, 15],     [16, 17, 18, 19],     [20, 21, 22, 23]]])%a49%a4[0][2][1]9%a4[0,2,1]array([[ 0,  1,  2],    [12, 13, 14]])%a4[:, 0, :3]array([ 2, 14])%a4[:, 0, 2]array([[[ 2,  3],     [ 6,  7],     [10, 11]],    [[14, 15],     [18, 19],     [22, 23]]])%a4[:, :,2:]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></blockquote><hr><h4 id="布尔索引（条件索引）"><a href="#布尔索引（条件索引）" class="headerlink" title="布尔索引（条件索引）"></a>布尔索引（条件索引）</h4><p>举例</p><pre class="line-numbers language-none"><code class="language-none">a=np.arange(10)a&gt;5%个人理解为，将数组bool化，大于5为True,反之为Falsea[a&gt;5]%使用布尔索引，取出数组中大于5的所有元素a[(a&gt;2)&amp;(a&lt;8)]%取出大于2小于8的元素<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><pre class="line-numbers language-none"><code class="language-none">array([False, False, False, False, False, False,  True,  True,  True,     True])%a&gt;5array([6, 7, 8, 9])%a[a&gt;5]array([3, 4, 5, 6, 7])%a[(a&gt;2)&amp;(a&lt;8)]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></blockquote><p>==注意：==</p><ol><li>对于高维数组，使用条件索引获得的元素，组成的是一维数组。</li></ol><p>如：</p><pre class="line-numbers language-none"><code class="language-none">a=np.arange(24).reshape(2,3,4)a[(a&gt;10)&amp;(a%2 !=0)]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><blockquote><pre class="line-numbers language-none"><code class="language-none">array([11, 13, 15, 17, 19, 21, 23])<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></blockquote><p>2.条件取反符号  ~</p><p>如：</p><pre class="line-numbers language-none"><code class="language-none">a=np.arange(10)a[~(a&lt;5)]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><blockquote><pre class="line-numbers language-none"><code class="language-none">array([5, 6, 7, 8, 9])%a[~(a&lt;5)]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></blockquote><hr><h4 id="广播与转置"><a href="#广播与转置" class="headerlink" title="广播与转置"></a>广播与转置</h4><h5 id="广播"><a href="#广播" class="headerlink" title="广播"></a>广播</h5><p>数组与标量值进行运算时，会广播到所有元素进行相应运算</p><p>举例</p><pre class="line-numbers language-none"><code class="language-none">a=np.arange(10).reshape(2,5)a+10%广播到所有元素a+a%同形状数组，对应位置元素相运算a1=np.arange(5)a+a1%行数相同数组广播运算，a为2*5，b为1*5，每行元素对应运算%列数相同，也可进行运算<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><pre class="line-numbers language-none"><code class="language-none">array([[10, 11, 12, 13, 14],    [15, 16, 17, 18, 19]])%a+10array([[ 0,  2,  4,  6,  8],    [10, 12, 14, 16, 18]])%a+aarray([[ 0,  2,  4,  6,  8],    [ 5,  7,  9, 11, 13]])%a+a1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></blockquote><h5 id="转置"><a href="#转置" class="headerlink" title="转置"></a>转置</h5><p>array.T，进行转置</p><pre class="line-numbers language-none"><code class="language-none">a=np.arange(10).reshape(2,5)aa.T<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><pre class="line-numbers language-none"><code class="language-none">array([[0, 1, 2, 3, 4],    [5, 6, 7, 8, 9]])%aarray([[0, 5],    [1, 6],    [2, 7],    [3, 8],    [4, 9]])%a.T<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></blockquote><hr><h4 id="数据合并与元素添加"><a href="#数据合并与元素添加" class="headerlink" title="数据合并与元素添加"></a>数据合并与元素添加</h4><h5 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h5><p><code>%concatenate()</code></p><p>参数必须为元组，里面写需合并的高维数组，另有axis进行竖直水平合并选择</p><pre class="line-numbers language-none"><code class="language-none">a=np.array([[1,2],[3,4]])b=np.array([[5,6],[7,8]])np.concatenate((a,b))%默认，竖直合并np.concatenate((a,b)，axis=1)%水平合并<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><blockquote><pre class="line-numbers language-none"><code class="language-none">array([[1, 2],    [3, 4],    [5, 6],    [7, 8]])%np.concatenate((a,b))array([[1, 2, 5, 6],    [3, 4, 7, 8]])%np.concatenate((a,b)，axis=1)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></blockquote><p>==对于一维数组==，前文concate（）的用法不再适用，axis只能取0，取1会报错</p><p>且，concatenate（）对一维数组进行的是水平合并</p><p>​竖直合并得用stack（）</p><pre class="line-numbers language-none"><code class="language-none">a1=np.array([1,2,3,4])a2=np.array([5,6,7,8])np.concatenate((a1,a2))np.stack((a1,a2))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><pre class="line-numbers language-none"><code class="language-none">array([1, 2, 3, 4, 5, 6, 7, 8])%np.concatenate((a1,a2))array([[1, 2, 3, 4],    [5, 6, 7, 8]])%np.stack((a1,a2))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></blockquote><h5 id="元素添加"><a href="#元素添加" class="headerlink" title="元素添加"></a>元素添加</h5><p>np.append(修改数组，添加的具体元素)</p><pre class="line-numbers language-none"><code class="language-none">a1=np.array([1,2,3,4])np.append(a1,5)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><blockquote><pre class="line-numbers language-none"><code class="language-none">array([1, 2, 3, 4, 5])%np.append(a1,5)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></blockquote><p>==对于高维数组==，使用np.append()会得到一个一维数组。类似于concaten（），高维数组有axis参数</p><pre class="line-numbers language-none"><code class="language-none">b=np.array([[5,6],[7,8]])np.append(b,[9,10])%默认水平合并np.append(b,[9,10]，axis=0)%会报错，[9,10]会被当成一维数组，应修改为[[9,10]]np.append(b,[[9,10]]，axis=0)np.append(b,[[9],[10]],axis=1)%水平合并，应将9，10两个元素写成一列<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><pre class="line-numbers language-none"><code class="language-none">array([[5, 6],    [7, 8]])%barray([ 5,  6,  7,  8,  9, 10])%np.append(b,[9,10])array([[ 5,  6],    [ 7,  8],    [ 9, 10]])%np.append(b,[[9,10]]，axis=0)array([[ 5,  6,  9],    [ 7,  8, 10]])%np.append(b,[[9],[10]],axis=1)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></blockquote><h5 id="返回唯一值"><a href="#返回唯一值" class="headerlink" title="返回唯一值"></a>返回唯一值</h5><p>np.unique()</p><pre class="line-numbers language-none"><code class="language-none">a=np.array([1,1,1,3,3,3,4,4,5])np.unique(a)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><blockquote><pre class="line-numbers language-none"><code class="language-none">array([1, 3, 4, 5])%np.unique(a)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></blockquote><hr><h4 id="通用函数"><a href="#通用函数" class="headerlink" title="通用函数"></a>通用函数</h4><h5 id="平方根"><a href="#平方根" class="headerlink" title="平方根"></a>平方根</h5><pre class="line-numbers language-none"><code class="language-none">a=np.arange(10)np.sqrt(a)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><blockquote><pre class="line-numbers language-none"><code class="language-none">array([0.        , 1.        , 1.41421356, 1.73205081, 2.        ,    2.23606798, 2.44948974, 2.64575131, 2.82842712, 3.        ])<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></blockquote><h5 id="三角函数-参数为弧度"><a href="#三角函数-参数为弧度" class="headerlink" title="三角函数(参数为弧度)"></a>三角函数(参数为弧度)</h5><pre class="line-numbers language-none"><code class="language-none">np.sin(a)np.cos(a)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><pre class="line-numbers language-none"><code class="language-none">array([ 0.        ,  0.84147098,  0.90929743,  0.14112001, -0.7568025 ,    -0.95892427, -0.2794155 ,  0.6569866 ,  0.98935825,  0.41211849])array([ 1.        ,  0.54030231, -0.41614684, -0.9899925 , -0.65364362,     0.28366219,  0.96017029,  0.75390225, -0.14550003, -0.91113026])<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></blockquote><h5 id="幂运算"><a href="#幂运算" class="headerlink" title="幂运算"></a>幂运算</h5><pre class="line-numbers language-none"><code class="language-none">a**2a**3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><pre class="line-numbers language-none"><code class="language-none">array([ 0,  1,  4,  9, 16, 25, 36, 49, 64, 81], dtype=int32)array([  0,   1,   8,  27,  64, 125, 216, 343, 512, 729], dtype=int32)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></blockquote><h5 id="两数组对应位置元素最大值"><a href="#两数组对应位置元素最大值" class="headerlink" title="两数组对应位置元素最大值"></a>两数组对应位置元素最大值</h5><pre class="line-numbers language-none"><code class="language-none">b=np.arange(10,0,-1)np.maximum(a,b)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><blockquote><pre class="line-numbers language-none"><code class="language-none">array([10,  9,  8,  7,  6,  5,  6,  7,  8,  9])<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></blockquote><hr><h4 id="统计方法"><a href="#统计方法" class="headerlink" title="统计方法"></a>统计方法</h4><h5 id="均值"><a href="#均值" class="headerlink" title="均值"></a>均值</h5><pre class="line-numbers language-none"><code class="language-none">a=np.arange(10)np.mean(a)%也可看做对象，使用a.mean()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><blockquote><pre class="line-numbers language-none"><code class="language-none">4.5%np.mean(a)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></blockquote><pre class="line-numbers language-none"><code class="language-none">a1=a.reshape(2,5)a1.mean(axis=0)%按列求均值a1.mean(axis=1)%按行求均值<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><blockquote><pre class="line-numbers language-none"><code class="language-none">array([2.5, 3.5, 4.5, 5.5, 6.5])%a1.mean(axis=0)array([2., 7.])%a1.mean(axis=1)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></blockquote><h5 id="求和"><a href="#求和" class="headerlink" title="求和"></a>求和</h5><pre class="line-numbers language-none"><code class="language-none">np.sum(a)%a.sum()<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><pre class="line-numbers language-none"><code class="language-none">45<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></blockquote><h5 id="最大值"><a href="#最大值" class="headerlink" title="最大值"></a>最大值</h5><pre class="line-numbers language-none"><code class="language-none">a1.max()%所有元素中的最大值a1.max(0)%每列的最大值a1.max(1)%每行的最大值<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><pre class="line-numbers language-none"><code class="language-none">9array([5, 6, 7, 8, 9])array([4, 9])<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></blockquote><h5 id="最小值"><a href="#最小值" class="headerlink" title="最小值"></a>最小值</h5><p><code>min()</code>,用法同max</p><h5 id="方差"><a href="#方差" class="headerlink" title="方差"></a>方差</h5><pre class="line-numbers language-none"><code class="language-none">a1.std()a1.std(0)a1.std(1)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><pre class="line-numbers language-none"><code class="language-none">2.8722813232690143array([2.5, 2.5, 2.5, 2.5, 2.5])array([1.41421356, 1.41421356])<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></blockquote><h5 id="中位数"><a href="#中位数" class="headerlink" title="中位数"></a>中位数</h5><p>==注意：==</p><p>numpy没有median（）方法</p><pre class="line-numbers language-none"><code class="language-none">np.median(a1)np.median(a1,0)np.median(a1,1)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><pre class="line-numbers language-none"><code class="language-none">4.5array([2.5, 3.5, 4.5, 5.5, 6.5])array([2., 7.])<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></blockquote><hr><hr><h3 id="matplotlib"><a href="#matplotlib" class="headerlink" title="matplotlib"></a>matplotlib</h3><h4 id="导包-一般"><a href="#导包-一般" class="headerlink" title="导包(一般)"></a>导包(一般)</h4><p><code>import matplotlib.pyplot as plt</code></p><p>常用的绘图命令都放在了pyplot下</p><hr><h4 id="线性图"><a href="#线性图" class="headerlink" title="线性图"></a>线性图</h4><h5 id="单条曲线"><a href="#单条曲线" class="headerlink" title="单条曲线"></a>单条曲线</h5><pre class="line-numbers language-none"><code class="language-none">import numpy as npimport matplotlib.pyplot as pltx=np.arange(0,5)y=np.arange(5,10)plt.plot(x,y)%若没写x，绘图时x轴取值会默认以从0开始的序列进行取值plt.show()%在notebook中，有没有此语句都会输出图像<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><img src="D:\Typora\Projects\机器学习\数据分析\figure\线性图-举例.png" alt="线性图-举例"></p></blockquote><h5 id="多条曲线"><a href="#多条曲线" class="headerlink" title="多条曲线"></a>多条曲线</h5><pre class="line-numbers language-none"><code class="language-none">x=[1,2,3,4]y=[5,6,7,8]y1=[1,3,5,7]y2=[8,2,6,3]plt.plot(x,y)plt.plot(x,y1)plt.plot(x,y2)plt.show()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><img src="D:\Typora\Projects\机器学习\数据分析\figure\同框多线.png" alt="同框多线"></p></blockquote><p>==带标签==</p><pre class="line-numbers language-none"><code class="language-none">plt.plot(x,y,label="A")%label指定标签名plt.plot(x,y1,label="B")plt.plot(x,y2,label="C")plt.legend()%显示标签plt.show()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="D:\Typora\Projects\机器学习\数据分析\figure\多线带标签.png" alt="多线带标签"></p><h5 id="与numpy配合"><a href="#与numpy配合" class="headerlink" title="与numpy配合"></a>与numpy配合</h5><pre class="line-numbers language-none"><code class="language-none">x=np.linspace(0,7,100)y=np.sin(x)plt.plot(x,y,label='sinx')plt.legend()plt.show()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><img src="D:\Typora\Projects\机器学习\数据分析\figure\sinx.png" alt="sinx"></p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Jupter及Anaconda常用命令</title>
      <link href="/2023/01/14/jupter-ji-anaconda-chang-yong-ming-ling/"/>
      <url>/2023/01/14/jupter-ji-anaconda-chang-yong-ming-ling/</url>
      
        <content type="html"><![CDATA[<h3 id="conda命令"><a href="#conda命令" class="headerlink" title="conda命令"></a>conda命令</h3><table><thead><tr><th align="center">命令</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">conda list</td><td align="center">查询</td></tr><tr><td align="center">conda install *</td><td align="center">安装</td></tr><tr><td align="center">conda update *</td><td align="center">升级</td></tr><tr><td align="center">conda remove *</td><td align="center">卸载</td></tr><tr><td align="center">conda creat -n xx python=3.6</td><td align="center">创建虚拟环境</td></tr><tr><td align="center">activate xx</td><td align="center">进入虚拟环境</td></tr></tbody></table><hr><h3 id="jupyter-notebook使用"><a href="#jupyter-notebook使用" class="headerlink" title="jupyter notebook使用"></a>jupyter notebook使用</h3><h4 id="打开方式"><a href="#打开方式" class="headerlink" title="打开方式"></a>打开方式</h4><blockquote><p>cmd命令,在指定目录下输入jupyter notebook</p></blockquote><h4 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h4><table><thead><tr><th align="center">快捷键</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">shift+回车</td><td align="center">运行</td></tr><tr><td align="center">Tab</td><td align="center">自动补全</td></tr><tr><td align="center">shift+双击Tab</td><td align="center">查看函数文档</td></tr></tbody></table><h4 id="魔术命令"><a href="#魔术命令" class="headerlink" title="魔术命令"></a>魔术命令</h4><table><thead><tr><th align="center">命令代码</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">%pwd</td><td align="center">显示当前目录</td></tr><tr><td align="center">%matplotlib inline</td><td align="center">在代码下方绘制图形</td></tr><tr><td align="center">%timeit[代码]</td><td align="center">查看代码运行时间</td></tr></tbody></table>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2023/01/14/hello-world/"/>
      <url>/2023/01/14/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new "My New Post"<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
